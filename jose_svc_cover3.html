
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">cryptoutil/internal/apps/jose/ja/service/audit_log_service.go (97.6%)</option>

				<option value="file1">cryptoutil/internal/apps/jose/ja/service/elastic_jwk_service.go (84.8%)</option>

				<option value="file2">cryptoutil/internal/apps/jose/ja/service/jwe_service.go (82.6%)</option>

				<option value="file3">cryptoutil/internal/apps/jose/ja/service/jwks_service.go (81.4%)</option>

				<option value="file4">cryptoutil/internal/apps/jose/ja/service/jws_service.go (87.2%)</option>

				<option value="file5">cryptoutil/internal/apps/jose/ja/service/jwt_service.go (78.8%)</option>

				<option value="file6">cryptoutil/internal/apps/jose/ja/service/material_rotation_service.go (87.6%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Copyright (c) 2025 Justin Cranford
//

// Package service provides business logic services for jose-ja.
package service

import (
        "context"
        "fmt"
        "time"

        cryptoutilAppsJoseJaDomain "cryptoutil/internal/apps/jose/ja/domain"
        cryptoutilAppsJoseJaRepository "cryptoutil/internal/apps/jose/ja/repository"

        googleUuid "github.com/google/uuid"
)

// AuditLogService provides business logic for audit logging operations.
type AuditLogService interface {
        // LogOperation logs an operation for audit purposes.
        LogOperation(ctx context.Context, tenantID googleUuid.UUID, elasticJWKID *googleUuid.UUID, operation, requestID string, success bool, errorMessage *string) error

        // ListAuditLogs lists audit logs for a tenant with pagination.
        ListAuditLogs(ctx context.Context, tenantID googleUuid.UUID, offset, limit int) ([]*cryptoutilAppsJoseJaDomain.AuditLogEntry, int64, error)

        // ListAuditLogsByElasticJWK lists audit logs for a specific elastic JWK.
        ListAuditLogsByElasticJWK(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, offset, limit int) ([]*cryptoutilAppsJoseJaDomain.AuditLogEntry, int64, error)

        // ListAuditLogsByOperation lists audit logs by operation type.
        ListAuditLogsByOperation(ctx context.Context, tenantID googleUuid.UUID, operation string, offset, limit int) ([]*cryptoutilAppsJoseJaDomain.AuditLogEntry, int64, error)

        // GetAuditConfig gets the audit configuration for a tenant.
        GetAuditConfig(ctx context.Context, tenantID googleUuid.UUID) (*cryptoutilAppsJoseJaDomain.AuditConfig, error)

        // UpdateAuditConfig updates the audit configuration for a tenant.
        UpdateAuditConfig(ctx context.Context, tenantID googleUuid.UUID, config *cryptoutilAppsJoseJaDomain.AuditConfig) error

        // CleanupOldLogs removes audit logs older than the specified number of days.
        CleanupOldLogs(ctx context.Context, tenantID googleUuid.UUID, days int) (int64, error)
}

// auditLogServiceImpl implements AuditLogService.
type auditLogServiceImpl struct {
        auditLogRepo    cryptoutilAppsJoseJaRepository.AuditLogRepository
        auditConfigRepo cryptoutilAppsJoseJaRepository.AuditConfigRepository
        elasticRepo     cryptoutilAppsJoseJaRepository.ElasticJWKRepository
}

// NewAuditLogService creates a new AuditLogService.
func NewAuditLogService(
        auditLogRepo cryptoutilAppsJoseJaRepository.AuditLogRepository,
        auditConfigRepo cryptoutilAppsJoseJaRepository.AuditConfigRepository,
        elasticRepo cryptoutilAppsJoseJaRepository.ElasticJWKRepository,
) AuditLogService <span class="cov8" title="1">{
        return &amp;auditLogServiceImpl{
                auditLogRepo:    auditLogRepo,
                auditConfigRepo: auditConfigRepo,
                elasticRepo:     elasticRepo,
        }
}</span>

// LogOperation logs an operation for audit purposes.
func (s *auditLogServiceImpl) LogOperation(ctx context.Context, tenantID googleUuid.UUID, elasticJWKID *googleUuid.UUID, operation, requestID string, success bool, errorMessage *string) error <span class="cov8" title="1">{
        // Check if audit is enabled for this operation.
        shouldAudit, err := s.auditConfigRepo.ShouldAudit(ctx, tenantID, operation)
        if err != nil </span><span class="cov8" title="1">{
                // On error, default to auditing.
                shouldAudit = true
        }</span>

        <span class="cov8" title="1">if !shouldAudit </span><span class="cov8" title="1">{
                return nil // Audit disabled for this operation.
        }</span>

        // Create audit log entry.
        <span class="cov8" title="1">entry := &amp;cryptoutilAppsJoseJaDomain.AuditLogEntry{
                ID:           googleUuid.New(),
                TenantID:     tenantID,
                ElasticJWKID: elasticJWKID,
                Operation:    operation,
                Success:      success,
                ErrorMessage: errorMessage,
                RequestID:    requestID,
                CreatedAt:    time.Now(),
        }

        // Store audit log.
        if err := s.auditLogRepo.Create(ctx, entry); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create audit log: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ListAuditLogs lists audit logs for a tenant with pagination.
func (s *auditLogServiceImpl) ListAuditLogs(ctx context.Context, tenantID googleUuid.UUID, offset, limit int) ([]*cryptoutilAppsJoseJaDomain.AuditLogEntry, int64, error) <span class="cov8" title="1">{
        entries, total, err := s.auditLogRepo.List(ctx, tenantID, offset, limit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, 0, fmt.Errorf("failed to list audit logs: %w", err)
        }</span>

        <span class="cov8" title="1">return entries, total, nil</span>
}

// ListAuditLogsByElasticJWK lists audit logs for a specific elastic JWK.
func (s *auditLogServiceImpl) ListAuditLogsByElasticJWK(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, offset, limit int) ([]*cryptoutilAppsJoseJaDomain.AuditLogEntry, int64, error) <span class="cov8" title="1">{
        // Verify tenant ownership.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, 0, fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return nil, 0, fmt.Errorf("elastic JWK not found")
        }</span>

        <span class="cov8" title="1">entries, total, err := s.auditLogRepo.ListByElasticJWK(ctx, elasticJWKID, offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to list audit logs: %w", err)
        }</span>

        <span class="cov8" title="1">return entries, total, nil</span>
}

// ListAuditLogsByOperation lists audit logs by operation type.
func (s *auditLogServiceImpl) ListAuditLogsByOperation(ctx context.Context, tenantID googleUuid.UUID, operation string, offset, limit int) ([]*cryptoutilAppsJoseJaDomain.AuditLogEntry, int64, error) <span class="cov8" title="1">{
        entries, total, err := s.auditLogRepo.ListByOperation(ctx, tenantID, operation, offset, limit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, 0, fmt.Errorf("failed to list audit logs by operation: %w", err)
        }</span>

        <span class="cov8" title="1">return entries, total, nil</span>
}

// GetAuditConfig gets the audit configuration for a tenant.
func (s *auditLogServiceImpl) GetAuditConfig(ctx context.Context, tenantID googleUuid.UUID) (*cryptoutilAppsJoseJaDomain.AuditConfig, error) <span class="cov8" title="1">{
        configs, err := s.auditConfigRepo.GetAllForTenant(ctx, tenantID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get audit configs: %w", err)
        }</span>

        // Return first config or create default.
        <span class="cov8" title="1">if len(configs) &gt; 0 </span><span class="cov8" title="1">{
                return configs[0], nil
        }</span>

        // Return a default config.
        <span class="cov8" title="1">return &amp;cryptoutilAppsJoseJaDomain.AuditConfig{
                TenantID:     tenantID,
                Operation:    cryptoutilAppsJoseJaDomain.OperationGenerate, // Default operation.
                Enabled:      true,
                SamplingRate: 1.0, // 100% sampling by default.
        }, nil</span>
}

// UpdateAuditConfig updates the audit configuration for a tenant.
func (s *auditLogServiceImpl) UpdateAuditConfig(ctx context.Context, tenantID googleUuid.UUID, config *cryptoutilAppsJoseJaDomain.AuditConfig) error <span class="cov8" title="1">{
        // Ensure tenant ID is set.
        config.TenantID = tenantID

        if err := s.auditConfigRepo.Upsert(ctx, config); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update audit config: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CleanupOldLogs removes audit logs older than the specified number of days.
func (s *auditLogServiceImpl) CleanupOldLogs(ctx context.Context, tenantID googleUuid.UUID, days int) (int64, error) <span class="cov8" title="1">{
        count, err := s.auditLogRepo.DeleteOlderThan(ctx, tenantID, days)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to delete old audit logs: %w", err)
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">// Copyright (c) 2025 Justin Cranford
//

// Package service provides business logic services for jose-ja.
package service

import (
        "context"
        "encoding/base64"
        "fmt"
        "time"

        cryptoutilOpenapiModel "cryptoutil/api/model"
        cryptoutilAppsJoseJaDomain "cryptoutil/internal/apps/jose/ja/domain"
        cryptoutilAppsJoseJaRepository "cryptoutil/internal/apps/jose/ja/repository"
        cryptoutilAppsTemplateServiceServerBarrier "cryptoutil/internal/apps/template/service/server/barrier"
        cryptoutilSharedCryptoJose "cryptoutil/internal/shared/crypto/jose"
        cryptoutilSharedMagic "cryptoutil/internal/shared/magic"

        googleUuid "github.com/google/uuid"
)

// ElasticJWKService provides business logic for Elastic JWK operations.
type ElasticJWKService interface {
        // CreateElasticJWK creates a new elastic JWK container and initial material.
        CreateElasticJWK(ctx context.Context, tenantID googleUuid.UUID, algorithm, use string, maxMaterials int) (*cryptoutilAppsJoseJaDomain.ElasticJWK, *cryptoutilAppsJoseJaDomain.MaterialJWK, error)

        // GetElasticJWK retrieves an elastic JWK by ID.
        GetElasticJWK(ctx context.Context, tenantID, id googleUuid.UUID) (*cryptoutilAppsJoseJaDomain.ElasticJWK, error)

        // ListElasticJWKs lists elastic JWKs for a tenant with pagination.
        ListElasticJWKs(ctx context.Context, tenantID googleUuid.UUID, offset, limit int) ([]*cryptoutilAppsJoseJaDomain.ElasticJWK, int64, error)

        // DeleteElasticJWK deletes an elastic JWK and all its materials.
        DeleteElasticJWK(ctx context.Context, tenantID, id googleUuid.UUID) error
}

// elasticJWKServiceImpl implements ElasticJWKService.
type elasticJWKServiceImpl struct {
        elasticRepo  cryptoutilAppsJoseJaRepository.ElasticJWKRepository
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository
        jwkGenSvc    *cryptoutilSharedCryptoJose.JWKGenService
        barrierSvc   *cryptoutilAppsTemplateServiceServerBarrier.Service
}

// NewElasticJWKService creates a new ElasticJWKService.
func NewElasticJWKService(
        elasticRepo cryptoutilAppsJoseJaRepository.ElasticJWKRepository,
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository,
        jwkGenSvc *cryptoutilSharedCryptoJose.JWKGenService,
        barrierSvc *cryptoutilAppsTemplateServiceServerBarrier.Service,
) ElasticJWKService <span class="cov8" title="1">{
        return &amp;elasticJWKServiceImpl{
                elasticRepo:  elasticRepo,
                materialRepo: materialRepo,
                jwkGenSvc:    jwkGenSvc,
                barrierSvc:   barrierSvc,
        }
}</span>

// CreateElasticJWK creates a new elastic JWK container with initial material key.
func (s *elasticJWKServiceImpl) CreateElasticJWK(ctx context.Context, tenantID googleUuid.UUID, algorithm, use string, maxMaterials int) (*cryptoutilAppsJoseJaDomain.ElasticJWK, *cryptoutilAppsJoseJaDomain.MaterialJWK, error) <span class="cov8" title="1">{
        // Validate algorithm and derive key type.
        keyType := mapAlgorithmToKeyType(algorithm)
        if keyType == "" </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("invalid algorithm: %s", algorithm)
        }</span>

        // Validate use.
        <span class="cov8" title="1">if use != cryptoutilAppsJoseJaDomain.KeyUseSig &amp;&amp; use != cryptoutilAppsJoseJaDomain.KeyUseEnc </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("invalid key use: %s (must be 'sig' or 'enc')", use)
        }</span>

        // Set default max materials.
        <span class="cov8" title="1">if maxMaterials &lt;= 0 </span><span class="cov8" title="1">{
                maxMaterials = 10
        }</span>

        // Generate elastic JWK ID and KID.
        <span class="cov8" title="1">elasticID := googleUuid.New()
        elasticKID := elasticID.String()

        // Create elastic JWK record.
        elasticJWK := &amp;cryptoutilAppsJoseJaDomain.ElasticJWK{
                ID:                   elasticID,
                TenantID:             tenantID,
                KID:                  elasticKID,
                KeyType:              keyType,
                Algorithm:            algorithm,
                Use:                  use,
                MaxMaterials:         maxMaterials,
                CurrentMaterialCount: 1,
                CreatedAt:            time.Now(),
        }

        // Store elastic JWK.
        if err := s.elasticRepo.Create(ctx, elasticJWK); err != nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("failed to create elastic JWK: %w", err)
        }</span>

        // Create initial material.
        <span class="cov8" title="1">material, err := s.createMaterialJWK(ctx, elasticJWK, true)
        if err != nil </span><span class="cov0" title="0">{
                // Clean up elastic JWK on failure.
                _ = s.elasticRepo.Delete(ctx, elasticID)

                return nil, nil, fmt.Errorf("failed to create initial material: %w", err)
        }</span>

        <span class="cov8" title="1">return elasticJWK, material, nil</span>
}

// GetElasticJWK retrieves an elastic JWK by ID.
func (s *elasticJWKServiceImpl) GetElasticJWK(ctx context.Context, tenantID, id googleUuid.UUID) (*cryptoutilAppsJoseJaDomain.ElasticJWK, error) <span class="cov8" title="1">{
        elasticJWK, err := s.elasticRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        // Verify tenant ownership.
        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("elastic JWK not found")
        }</span>

        <span class="cov8" title="1">return elasticJWK, nil</span>
}

// ListElasticJWKs lists elastic JWKs for a tenant with pagination.
func (s *elasticJWKServiceImpl) ListElasticJWKs(ctx context.Context, tenantID googleUuid.UUID, offset, limit int) ([]*cryptoutilAppsJoseJaDomain.ElasticJWK, int64, error) <span class="cov8" title="1">{
        elasticJWKs, total, err := s.elasticRepo.List(ctx, tenantID, offset, limit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, 0, fmt.Errorf("failed to list elastic JWKs: %w", err)
        }</span>

        <span class="cov8" title="1">return elasticJWKs, total, nil</span>
}

// DeleteElasticJWK deletes an elastic JWK and all its materials.
func (s *elasticJWKServiceImpl) DeleteElasticJWK(ctx context.Context, tenantID, id googleUuid.UUID) error <span class="cov8" title="1">{
        // Verify ownership first.
        elasticJWK, err := s.GetElasticJWK(ctx, tenantID, id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Delete all materials first.
        <span class="cov8" title="1">materials, _, err := s.materialRepo.ListByElasticJWK(ctx, elasticJWK.ID, 0, cryptoutilSharedMagic.JoseJADefaultListLimit)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list materials for deletion: %w", err)
        }</span>

        <span class="cov8" title="1">for _, material := range materials </span><span class="cov8" title="1">{
                if err := s.materialRepo.Delete(ctx, material.ID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete material %s: %w", material.ID, err)
                }</span>
        }

        // Delete elastic JWK.
        <span class="cov8" title="1">if err := s.elasticRepo.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete elastic JWK: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// createMaterialJWK generates and stores a new material key for an elastic JWK.
func (s *elasticJWKServiceImpl) createMaterialJWK(ctx context.Context, elasticJWK *cryptoutilAppsJoseJaDomain.ElasticJWK, active bool) (*cryptoutilAppsJoseJaDomain.MaterialJWK, error) <span class="cov8" title="1">{
        // Generate material ID.
        materialID := googleUuid.New()
        materialKID := materialID.String()

        // Convert algorithm to GenerateAlgorithm.
        genAlg := mapToGenerateAlgorithm(elasticJWK.Algorithm)
        if genAlg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported algorithm for key generation: %s", elasticJWK.Algorithm)
        }</span>

        // Generate JWK using JWKGenService.
        <span class="cov8" title="1">kid, privateJWK, publicJWK, privateJWKBytes, publicJWKBytes, err := s.jwkGenSvc.GenerateJWK(genAlg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate JWK: %w", err)
        }</span>

        // Use generated KID if not already set.
        <span class="cov8" title="1">if kid != nil </span><span class="cov8" title="1">{
                materialKID = kid.String()
        }</span>

        // Set KID on JWKs.
        // Note: For symmetric keys (oct), publicJWK is nil - symmetric keys have no separate public key.
        <span class="cov8" title="1">if err := privateJWK.Set("kid", materialKID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to set private JWK kid: %w", err)
        }</span>

        // For asymmetric keys, set KID on public JWK as well.
        <span class="cov8" title="1">if publicJWK != nil </span><span class="cov8" title="1">{
                if err := publicJWK.Set("kid", materialKID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to set public JWK kid: %w", err)
                }</span>
        }

        // Encrypt private and public JWKs with barrier.
        // For symmetric keys (oct), use private JWK for both since there's no separate public key.
        <span class="cov8" title="1">privateJWEBytes, err := s.barrierSvc.EncryptContentWithContext(ctx, privateJWKBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt private JWK: %w", err)
        }</span>

        // For symmetric keys, publicJWKBytes is nil - use privateJWKBytes for both fields.
        <span class="cov8" title="1">publicBytesToEncrypt := publicJWKBytes
        if publicBytesToEncrypt == nil </span><span class="cov8" title="1">{
                publicBytesToEncrypt = privateJWKBytes
        }</span>

        <span class="cov8" title="1">publicJWEBytes, err := s.barrierSvc.EncryptContentWithContext(ctx, publicBytesToEncrypt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt public JWK: %w", err)
        }</span>

        // Convert encrypted bytes to base64 strings for storage.
        <span class="cov8" title="1">privateJWE := base64.StdEncoding.EncodeToString(privateJWEBytes)
        publicJWE := base64.StdEncoding.EncodeToString(publicJWEBytes)

        // Create material JWK record.
        // Note: MaterialJWK.PrivateJWKJWE and PublicJWKJWE are strings.
        materialJWK := &amp;cryptoutilAppsJoseJaDomain.MaterialJWK{
                ID:             materialID,
                ElasticJWKID:   elasticJWK.ID,
                MaterialKID:    materialKID,
                PrivateJWKJWE:  privateJWE,
                PublicJWKJWE:   publicJWE,
                Active:         active,
                CreatedAt:      time.Now(),
                BarrierVersion: 1, // Initial barrier version.
        }

        // Store material JWK.
        if err := s.materialRepo.Create(ctx, materialJWK); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create material JWK: %w", err)
        }</span>

        <span class="cov8" title="1">return materialJWK, nil</span>
}

// mapAlgorithmToKeyType maps algorithm string to key type.
func mapAlgorithmToKeyType(algorithm string) string <span class="cov8" title="1">{
        switch algorithm </span>{
        case cryptoutilSharedMagic.JoseAlgRS256, cryptoutilSharedMagic.JoseAlgRS384, cryptoutilSharedMagic.JoseAlgRS512,
                cryptoutilSharedMagic.JoseAlgPS256, cryptoutilSharedMagic.JoseAlgPS384, cryptoutilSharedMagic.JoseAlgPS512,
                cryptoutilSharedMagic.JoseKeyTypeRSA2048, cryptoutilSharedMagic.JoseKeyTypeRSA3072, cryptoutilSharedMagic.JoseKeyTypeRSA4096:<span class="cov8" title="1">
                return cryptoutilAppsJoseJaDomain.KeyTypeRSA</span>
        case cryptoutilSharedMagic.JoseAlgES256, cryptoutilSharedMagic.JoseAlgES384, cryptoutilSharedMagic.JoseAlgES512,
                cryptoutilSharedMagic.JoseKeyTypeECP256, cryptoutilSharedMagic.JoseKeyTypeECP384, cryptoutilSharedMagic.JoseKeyTypeECP521:<span class="cov8" title="1">
                return cryptoutilAppsJoseJaDomain.KeyTypeEC</span>
        case cryptoutilSharedMagic.JoseAlgEdDSA, cryptoutilSharedMagic.JoseKeyTypeOKPEd25519:<span class="cov8" title="1">
                return cryptoutilAppsJoseJaDomain.KeyTypeOKP</span>
        case cryptoutilSharedMagic.JoseEncA128GCM, cryptoutilSharedMagic.JoseEncA192GCM, cryptoutilSharedMagic.JoseEncA256GCM,
                cryptoutilSharedMagic.JoseEncA128CBCHS256, cryptoutilSharedMagic.JoseEncA192CBCHS384, cryptoutilSharedMagic.JoseEncA256CBCHS512,
                cryptoutilSharedMagic.JoseKeyTypeOct128, cryptoutilSharedMagic.JoseKeyTypeOct192, cryptoutilSharedMagic.JoseKeyTypeOct256,
                cryptoutilSharedMagic.JoseKeyTypeOct384, cryptoutilSharedMagic.JoseKeyTypeOct512:<span class="cov8" title="1">
                return cryptoutilAppsJoseJaDomain.KeyTypeOct</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

// mapToGenerateAlgorithm maps algorithm string to OpenAPI GenerateAlgorithm.
func mapToGenerateAlgorithm(algorithm string) *cryptoutilOpenapiModel.GenerateAlgorithm <span class="cov8" title="1">{
        var alg cryptoutilOpenapiModel.GenerateAlgorithm

        switch algorithm </span>{
        case cryptoutilSharedMagic.JoseAlgRS256, cryptoutilSharedMagic.JoseAlgRS384, cryptoutilSharedMagic.JoseAlgRS512, cryptoutilSharedMagic.JoseKeyTypeRSA2048:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.RSA2048</span>
        case cryptoutilSharedMagic.JoseAlgPS256, cryptoutilSharedMagic.JoseAlgPS384, cryptoutilSharedMagic.JoseAlgPS512, cryptoutilSharedMagic.JoseKeyTypeRSA3072:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.RSA3072</span>
        case cryptoutilSharedMagic.JoseKeyTypeRSA4096:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.RSA4096</span>
        case cryptoutilSharedMagic.JoseAlgES256, cryptoutilSharedMagic.JoseKeyTypeECP256:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.ECP256</span>
        case cryptoutilSharedMagic.JoseAlgES384, cryptoutilSharedMagic.JoseKeyTypeECP384:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.ECP384</span>
        case cryptoutilSharedMagic.JoseAlgES512, cryptoutilSharedMagic.JoseKeyTypeECP521:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.ECP521</span>
        case cryptoutilSharedMagic.JoseAlgEdDSA, cryptoutilSharedMagic.JoseKeyTypeOKPEd25519:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.OKPEd25519</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct128, cryptoutilSharedMagic.JoseEncA128GCM:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.Oct128</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct192, cryptoutilSharedMagic.JoseEncA192GCM:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.Oct192</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct256, cryptoutilSharedMagic.JoseEncA256GCM:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.Oct256</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct384, cryptoutilSharedMagic.JoseEncA128CBCHS256:<span class="cov0" title="0">
                alg = cryptoutilOpenapiModel.Oct384</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct512, cryptoutilSharedMagic.JoseEncA256CBCHS512:<span class="cov0" title="0">
                alg = cryptoutilOpenapiModel.Oct512</span>
        default:<span class="cov8" title="1">
                return nil</span>
        }

        <span class="cov8" title="1">return &amp;alg</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">// Copyright (c) 2025 Justin Cranford
//

// Package service provides business logic services for jose-ja.
package service

import (
        "context"
        "encoding/base64"
        "fmt"

        cryptoutilAppsJoseJaDomain "cryptoutil/internal/apps/jose/ja/domain"
        cryptoutilAppsJoseJaRepository "cryptoutil/internal/apps/jose/ja/repository"
        cryptoutilAppsTemplateServiceServerBarrier "cryptoutil/internal/apps/template/service/server/barrier"
        cryptoutilSharedMagic "cryptoutil/internal/shared/magic"

        jose "github.com/go-jose/go-jose/v4"
        googleUuid "github.com/google/uuid"
)

// JWEService provides JWE encryption and decryption operations.
type JWEService interface {
        // Encrypt encrypts plaintext using the active material key of an elastic JWK.
        Encrypt(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, plaintext []byte) (string, error)

        // Decrypt decrypts a JWE compact serialization.
        Decrypt(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, jweCompact string) ([]byte, error)

        // EncryptWithKID encrypts plaintext using a specific material key.
        EncryptWithKID(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, materialKID string, plaintext []byte) (string, error)
}

// jweServiceImpl implements JWEService.
type jweServiceImpl struct {
        elasticRepo  cryptoutilAppsJoseJaRepository.ElasticJWKRepository
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository
        barrierSvc   *cryptoutilAppsTemplateServiceServerBarrier.Service
}

// NewJWEService creates a new JWEService.
func NewJWEService(
        elasticRepo cryptoutilAppsJoseJaRepository.ElasticJWKRepository,
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository,
        barrierSvc *cryptoutilAppsTemplateServiceServerBarrier.Service,
) JWEService <span class="cov8" title="1">{
        return &amp;jweServiceImpl{
                elasticRepo:  elasticRepo,
                materialRepo: materialRepo,
                barrierSvc:   barrierSvc,
        }
}</span>

// Encrypt encrypts plaintext using the active material key.
func (s *jweServiceImpl) Encrypt(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, plaintext []byte) (string, error) <span class="cov8" title="1">{
        // Get elastic JWK.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        // Verify tenant ownership.
        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return "", fmt.Errorf("elastic JWK not found")
        }</span>

        // Verify key use is for encryption.
        <span class="cov8" title="1">if elasticJWK.Use != cryptoutilAppsJoseJaDomain.KeyUseEnc </span><span class="cov8" title="1">{
                return "", fmt.Errorf("elastic JWK is not configured for encryption (use=%s)", elasticJWK.Use)
        }</span>

        // Get active material.
        <span class="cov8" title="1">material, err := s.materialRepo.GetActiveMaterial(ctx, elasticJWKID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get active material: %w", err)
        }</span>

        // Decode base64 encoded JWE string.
        <span class="cov8" title="1">publicJWKEncrypted, err := base64.StdEncoding.DecodeString(material.PublicJWKJWE)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode public JWK JWE: %w", err)
        }</span>

        // Decrypt public JWK.
        <span class="cov8" title="1">publicJWKJSON, err := s.barrierSvc.DecryptContentWithContext(ctx, publicJWKEncrypted)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decrypt public JWK: %w", err)
        }</span>

        // Parse public JWK.
        <span class="cov8" title="1">var publicJWK jose.JSONWebKey
        if err := publicJWK.UnmarshalJSON(publicJWKJSON); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse public JWK: %w", err)
        }</span>

        // Determine key algorithm and content encryption.
        <span class="cov8" title="1">keyAlg, contentEnc := mapToJWEAlgorithms(elasticJWK.Algorithm)
        if keyAlg == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unsupported algorithm for JWE: %s", elasticJWK.Algorithm)
        }</span>

        // Create JWE encrypter.
        <span class="cov8" title="1">encrypter, err := jose.NewEncrypter(contentEnc, jose.Recipient{Algorithm: keyAlg, Key: publicJWK}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create encrypter: %w", err)
        }</span>

        // Encrypt plaintext.
        <span class="cov8" title="1">jweObject, err := encrypter.Encrypt(plaintext)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encrypt: %w", err)
        }</span>

        // Serialize to compact form.
        <span class="cov8" title="1">compact, err := jweObject.CompactSerialize()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to serialize JWE: %w", err)
        }</span>

        <span class="cov8" title="1">return compact, nil</span>
}

// Decrypt decrypts a JWE compact serialization.
func (s *jweServiceImpl) Decrypt(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, jweCompact string) ([]byte, error) <span class="cov8" title="1">{
        // Get elastic JWK.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        // Verify tenant ownership.
        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("elastic JWK not found")
        }</span>

        // Parse JWE.
        <span class="cov8" title="1">jweObject, err := jose.ParseEncrypted(jweCompact, []jose.KeyAlgorithm{jose.RSA_OAEP, jose.RSA_OAEP_256, jose.ECDH_ES, jose.ECDH_ES_A128KW, jose.ECDH_ES_A192KW, jose.ECDH_ES_A256KW, jose.A128KW, jose.A192KW, jose.A256KW, jose.A128GCMKW, jose.A192GCMKW, jose.A256GCMKW, jose.DIRECT}, []jose.ContentEncryption{jose.A128GCM, jose.A192GCM, jose.A256GCM, jose.A128CBC_HS256, jose.A192CBC_HS384, jose.A256CBC_HS512})
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse JWE: %w", err)
        }</span>

        // Try to decrypt with all available materials.
        <span class="cov8" title="1">materials, _, err := s.materialRepo.ListByElasticJWK(ctx, elasticJWKID, 0, cryptoutilSharedMagic.JoseJADefaultListLimit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list materials: %w", err)
        }</span>

        <span class="cov8" title="1">for _, material := range materials </span><span class="cov8" title="1">{
                plaintext, err := s.decryptWithMaterial(ctx, jweObject, material)
                if err == nil </span><span class="cov8" title="1">{
                        return plaintext, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("failed to decrypt JWE: no matching key found")</span>
}

// EncryptWithKID encrypts plaintext using a specific material key.
func (s *jweServiceImpl) EncryptWithKID(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, materialKID string, plaintext []byte) (string, error) <span class="cov8" title="1">{
        // Get elastic JWK.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        // Verify tenant ownership.
        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return "", fmt.Errorf("elastic JWK not found")
        }</span>

        // Verify key use is for encryption.
        <span class="cov8" title="1">if elasticJWK.Use != cryptoutilAppsJoseJaDomain.KeyUseEnc </span><span class="cov8" title="1">{
                return "", fmt.Errorf("elastic JWK is not configured for encryption (use=%s)", elasticJWK.Use)
        }</span>

        // Find material by KID.
        <span class="cov8" title="1">material, err := s.materialRepo.GetByMaterialKID(ctx, materialKID)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get material by KID: %w", err)
        }</span>

        // Verify material belongs to elastic JWK.
        <span class="cov8" title="1">if material.ElasticJWKID != elasticJWKID </span><span class="cov8" title="1">{
                return "", fmt.Errorf("material key does not belong to elastic JWK")
        }</span>

        // Decode base64 encoded JWE string.
        <span class="cov8" title="1">publicJWKEncrypted, err := base64.StdEncoding.DecodeString(material.PublicJWKJWE)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode public JWK JWE: %w", err)
        }</span>

        // Decrypt public JWK.
        <span class="cov8" title="1">publicJWKJSON, err := s.barrierSvc.DecryptContentWithContext(ctx, publicJWKEncrypted)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decrypt public JWK: %w", err)
        }</span>

        // Parse public JWK.
        <span class="cov8" title="1">var publicJWK jose.JSONWebKey
        if err := publicJWK.UnmarshalJSON(publicJWKJSON); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse public JWK: %w", err)
        }</span>

        // Determine key algorithm and content encryption.
        <span class="cov8" title="1">keyAlg, contentEnc := mapToJWEAlgorithms(elasticJWK.Algorithm)
        if keyAlg == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unsupported algorithm for JWE: %s", elasticJWK.Algorithm)
        }</span>

        // Create JWE encrypter.
        <span class="cov8" title="1">encrypter, err := jose.NewEncrypter(contentEnc, jose.Recipient{Algorithm: keyAlg, Key: publicJWK}, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create encrypter: %w", err)
        }</span>

        // Encrypt plaintext.
        <span class="cov8" title="1">jweObject, err := encrypter.Encrypt(plaintext)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encrypt: %w", err)
        }</span>

        // Serialize to compact form.
        <span class="cov8" title="1">compact, err := jweObject.CompactSerialize()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to serialize JWE: %w", err)
        }</span>

        <span class="cov8" title="1">return compact, nil</span>
}

// decryptWithMaterial attempts to decrypt a JWE with a specific material key.
func (s *jweServiceImpl) decryptWithMaterial(ctx context.Context, jweObject *jose.JSONWebEncryption, material *cryptoutilAppsJoseJaDomain.MaterialJWK) ([]byte, error) <span class="cov8" title="1">{
        // Decode base64 encoded JWE string.
        privateJWKEncrypted, err := base64.StdEncoding.DecodeString(material.PrivateJWKJWE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode private JWK JWE: %w", err)
        }</span>

        // Decrypt private JWK.
        <span class="cov8" title="1">privateJWKJSON, err := s.barrierSvc.DecryptContentWithContext(ctx, privateJWKEncrypted)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt private JWK: %w", err)
        }</span>

        // Parse private JWK.
        <span class="cov8" title="1">var privateJWK jose.JSONWebKey
        if err := privateJWK.UnmarshalJSON(privateJWKJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse private JWK: %w", err)
        }</span>

        // Attempt decryption.
        <span class="cov8" title="1">plaintext, err := jweObject.Decrypt(privateJWK)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err //nolint:wrapcheck // Expected to fail for non-matching keys.
        }</span>

        <span class="cov8" title="1">return plaintext, nil</span>
}

// mapToJWEAlgorithms maps algorithm string to JWE key algorithm and content encryption.
func mapToJWEAlgorithms(algorithm string) (jose.KeyAlgorithm, jose.ContentEncryption) <span class="cov8" title="1">{
        switch algorithm </span>{
        case cryptoutilSharedMagic.JoseKeyTypeRSA2048, cryptoutilSharedMagic.JoseKeyTypeRSA3072, cryptoutilSharedMagic.JoseKeyTypeRSA4096,
                cryptoutilSharedMagic.JoseAlgRSAOAEP, cryptoutilSharedMagic.JoseAlgRSAOAEP256:<span class="cov8" title="1">
                return jose.RSA_OAEP_256, jose.A256GCM</span>
        case cryptoutilSharedMagic.JoseKeyTypeECP256, cryptoutilSharedMagic.JoseKeyTypeECP384, cryptoutilSharedMagic.JoseKeyTypeECP521,
                cryptoutilSharedMagic.JoseAlgECDHES:<span class="cov8" title="1">
                return jose.ECDH_ES_A256KW, jose.A256GCM</span>
        case "A128KW":<span class="cov8" title="1">
                return jose.A128KW, jose.A128GCM</span>
        case "A192KW":<span class="cov8" title="1">
                return jose.A192KW, jose.A192GCM</span>
        case "A256KW":<span class="cov8" title="1">
                return jose.A256KW, jose.A256GCM</span>
        case "A128GCMKW":<span class="cov8" title="1">
                return jose.A128GCMKW, jose.A128GCM</span>
        case "A192GCMKW":<span class="cov8" title="1">
                return jose.A192GCMKW, jose.A192GCM</span>
        case "A256GCMKW":<span class="cov8" title="1">
                return jose.A256GCMKW, jose.A256GCM</span>
        case cryptoutilSharedMagic.JoseAlgDir, cryptoutilSharedMagic.JoseKeyTypeOct128:<span class="cov8" title="1">
                return jose.DIRECT, jose.A128GCM</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct192:<span class="cov8" title="1">
                return jose.DIRECT, jose.A192GCM</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct256:<span class="cov8" title="1">
                return jose.DIRECT, jose.A256GCM</span>
        default:<span class="cov8" title="1">
                return "", ""</span>
        }
}
</pre>

		<pre class="file" id="file3" style="display: none">// Copyright (c) 2025 Justin Cranford
//

// Package service provides business logic services for jose-ja.
package service

import (
        "context"
        "encoding/base64"
        "fmt"

        cryptoutilAppsJoseJaRepository "cryptoutil/internal/apps/jose/ja/repository"
        cryptoutilAppsTemplateServiceServerBarrier "cryptoutil/internal/apps/template/service/server/barrier"
        cryptoutilSharedMagic "cryptoutil/internal/shared/magic"

        jose "github.com/go-jose/go-jose/v4"
        googleUuid "github.com/google/uuid"
)

// JWKSService provides business logic for JWKS (JSON Web Key Set) operations.
type JWKSService interface {
        // GetJWKS returns the JWKS (public keys only) for a tenant.
        GetJWKS(ctx context.Context, tenantID googleUuid.UUID) (*jose.JSONWebKeySet, error)

        // GetJWKSForElasticKey returns the JWKS for a specific elastic JWK.
        GetJWKSForElasticKey(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID) (*jose.JSONWebKeySet, error)

        // GetPublicJWK returns a single public JWK by KID.
        GetPublicJWK(ctx context.Context, tenantID googleUuid.UUID, kid string) (*jose.JSONWebKey, error)
}

// jwksServiceImpl implements JWKSService.
type jwksServiceImpl struct {
        elasticRepo  cryptoutilAppsJoseJaRepository.ElasticJWKRepository
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository
        barrierSvc   *cryptoutilAppsTemplateServiceServerBarrier.Service
}

// NewJWKSService creates a new JWKSService.
func NewJWKSService(
        elasticRepo cryptoutilAppsJoseJaRepository.ElasticJWKRepository,
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository,
        barrierSvc *cryptoutilAppsTemplateServiceServerBarrier.Service,
) JWKSService <span class="cov8" title="1">{
        return &amp;jwksServiceImpl{
                elasticRepo:  elasticRepo,
                materialRepo: materialRepo,
                barrierSvc:   barrierSvc,
        }
}</span>

// GetJWKS returns the JWKS (public keys only) for a tenant.
func (s *jwksServiceImpl) GetJWKS(ctx context.Context, tenantID googleUuid.UUID) (*jose.JSONWebKeySet, error) <span class="cov8" title="1">{
        jwks := &amp;jose.JSONWebKeySet{
                Keys: []jose.JSONWebKey{},
        }

        // List all elastic JWKs for tenant.
        elasticJWKs, _, err := s.elasticRepo.List(ctx, tenantID, 0, cryptoutilSharedMagic.JoseJADefaultListLimit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to list elastic JWKs: %w", err)
        }</span>

        // For each elastic JWK, get active material's public key.
        <span class="cov8" title="1">for _, elasticJWK := range elasticJWKs </span><span class="cov8" title="1">{
                material, err := s.materialRepo.GetActiveMaterial(ctx, elasticJWK.ID)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip if no active material.
                        continue</span>
                }

                // Decode base64 encoded JWE string.
                <span class="cov8" title="1">publicJWKEncrypted, err := base64.StdEncoding.DecodeString(material.PublicJWKJWE)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip on decode failure.
                }

                // Decrypt public JWK using barrier service.
                <span class="cov8" title="1">publicJWKJSON, err := s.barrierSvc.DecryptContentWithContext(ctx, publicJWKEncrypted)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip on decryption failure.
                }

                // Parse public JWK.
                <span class="cov8" title="1">var publicJWK jose.JSONWebKey
                if err := publicJWK.UnmarshalJSON(publicJWKJSON); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip on parse failure.
                }

                // Ensure the public key is set correctly.
                <span class="cov8" title="1">publicJWK.KeyID = material.MaterialKID
                publicJWK.Use = elasticJWK.Use
                publicJWK.Algorithm = elasticJWK.Algorithm

                jwks.Keys = append(jwks.Keys, publicJWK)</span>
        }

        <span class="cov8" title="1">return jwks, nil</span>
}

// GetJWKSForElasticKey returns the JWKS for a specific elastic JWK.
func (s *jwksServiceImpl) GetJWKSForElasticKey(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID) (*jose.JSONWebKeySet, error) <span class="cov8" title="1">{
        // Verify tenant ownership.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("elastic JWK not found")
        }</span>

        <span class="cov8" title="1">jwks := &amp;jose.JSONWebKeySet{
                Keys: []jose.JSONWebKey{},
        }

        // List all materials for this elastic JWK.
        materials, _, err := s.materialRepo.ListByElasticJWK(ctx, elasticJWKID, 0, cryptoutilSharedMagic.JoseJADefaultListLimit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list materials: %w", err)
        }</span>

        // For each material, add public key to JWKS.
        <span class="cov8" title="1">for _, material := range materials </span><span class="cov8" title="1">{
                // Skip retired materials.
                if material.RetiredAt != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Decode base64 encoded JWE string.
                <span class="cov8" title="1">publicJWKEncrypted, err := base64.StdEncoding.DecodeString(material.PublicJWKJWE)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip on decode failure.
                }

                // Decrypt public JWK using barrier service.
                <span class="cov8" title="1">publicJWKJSON, err := s.barrierSvc.DecryptContentWithContext(ctx, publicJWKEncrypted)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip on decryption failure.
                }

                // Parse public JWK.
                <span class="cov8" title="1">var publicJWK jose.JSONWebKey
                if err := publicJWK.UnmarshalJSON(publicJWKJSON); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip on parse failure.
                }

                // Set metadata.
                <span class="cov8" title="1">publicJWK.KeyID = material.MaterialKID
                publicJWK.Use = elasticJWK.Use
                publicJWK.Algorithm = elasticJWK.Algorithm

                jwks.Keys = append(jwks.Keys, publicJWK)</span>
        }

        <span class="cov8" title="1">return jwks, nil</span>
}

// GetPublicJWK returns a single public JWK by KID.
func (s *jwksServiceImpl) GetPublicJWK(ctx context.Context, tenantID googleUuid.UUID, kid string) (*jose.JSONWebKey, error) <span class="cov8" title="1">{
        // Get material by KID directly.
        material, err := s.materialRepo.GetByMaterialKID(ctx, kid)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("JWK with KID %s not found: %w", kid, err)
        }</span>

        // Get the elastic JWK to verify tenant ownership.
        <span class="cov8" title="1">elasticJWK, err := s.elasticRepo.GetByID(ctx, material.ElasticJWKID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        // Verify tenant ownership.
        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("JWK with KID %s not found", kid)
        }</span>

        // Decode base64 encoded JWE string.
        <span class="cov8" title="1">publicJWKEncrypted, err := base64.StdEncoding.DecodeString(material.PublicJWKJWE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode public JWK JWE: %w", err)
        }</span>

        // Decrypt public JWK using barrier service.
        <span class="cov8" title="1">publicJWKJSON, err := s.barrierSvc.DecryptContentWithContext(ctx, publicJWKEncrypted)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt public JWK: %w", err)
        }</span>

        // Parse public JWK.
        <span class="cov8" title="1">var publicJWK jose.JSONWebKey
        if err := publicJWK.UnmarshalJSON(publicJWKJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse public JWK: %w", err)
        }</span>

        // Set metadata.
        <span class="cov8" title="1">publicJWK.KeyID = material.MaterialKID
        publicJWK.Use = elasticJWK.Use
        publicJWK.Algorithm = elasticJWK.Algorithm

        return &amp;publicJWK, nil</span>
}
</pre>

		<pre class="file" id="file4" style="display: none">// Copyright (c) 2025 Justin Cranford
//

// Package service provides business logic services for jose-ja.
package service

import (
        "context"
        "encoding/base64"
        "fmt"

        cryptoutilAppsJoseJaDomain "cryptoutil/internal/apps/jose/ja/domain"
        cryptoutilAppsJoseJaRepository "cryptoutil/internal/apps/jose/ja/repository"
        cryptoutilAppsTemplateServiceServerBarrier "cryptoutil/internal/apps/template/service/server/barrier"
        cryptoutilSharedMagic "cryptoutil/internal/shared/magic"

        jose "github.com/go-jose/go-jose/v4"
        googleUuid "github.com/google/uuid"
)

// JWSService provides JWS signing and verification operations.
type JWSService interface {
        // Sign signs payload using the active material key of an elastic JWK.
        Sign(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, payload []byte) (string, error)

        // Verify verifies a JWS compact serialization.
        Verify(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, jwsCompact string) ([]byte, error)

        // SignWithKID signs payload using a specific material key.
        SignWithKID(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, materialKID string, payload []byte) (string, error)
}

// jwsServiceImpl implements JWSService.
type jwsServiceImpl struct {
        elasticRepo  cryptoutilAppsJoseJaRepository.ElasticJWKRepository
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository
        barrierSvc   *cryptoutilAppsTemplateServiceServerBarrier.Service
}

// NewJWSService creates a new JWSService.
func NewJWSService(
        elasticRepo cryptoutilAppsJoseJaRepository.ElasticJWKRepository,
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository,
        barrierSvc *cryptoutilAppsTemplateServiceServerBarrier.Service,
) JWSService <span class="cov8" title="1">{
        return &amp;jwsServiceImpl{
                elasticRepo:  elasticRepo,
                materialRepo: materialRepo,
                barrierSvc:   barrierSvc,
        }
}</span>

// Sign signs payload using the active material key.
func (s *jwsServiceImpl) Sign(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, payload []byte) (string, error) <span class="cov8" title="1">{
        // Get elastic JWK.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        // Verify tenant ownership.
        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return "", fmt.Errorf("elastic JWK not found")
        }</span>

        // Verify key use is for signing.
        <span class="cov8" title="1">if elasticJWK.Use != cryptoutilAppsJoseJaDomain.KeyUseSig </span><span class="cov8" title="1">{
                return "", fmt.Errorf("elastic JWK is not configured for signing (use=%s)", elasticJWK.Use)
        }</span>

        // Get active material.
        <span class="cov8" title="1">material, err := s.materialRepo.GetActiveMaterial(ctx, elasticJWKID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get active material: %w", err)
        }</span>

        <span class="cov8" title="1">return s.signWithMaterial(ctx, elasticJWK, material, payload)</span>
}

// Verify verifies a JWS compact serialization.
func (s *jwsServiceImpl) Verify(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, jwsCompact string) ([]byte, error) <span class="cov8" title="1">{
        // Get elastic JWK.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        // Verify tenant ownership.
        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("elastic JWK not found")
        }</span>

        // Parse JWS to determine algorithm.
        <span class="cov8" title="1">algorithms := []jose.SignatureAlgorithm{
                jose.RS256, jose.RS384, jose.RS512,
                jose.PS256, jose.PS384, jose.PS512,
                jose.ES256, jose.ES384, jose.ES512,
                jose.EdDSA,
                jose.HS256, jose.HS384, jose.HS512,
        }

        jwsObject, err := jose.ParseSigned(jwsCompact, algorithms)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse JWS: %w", err)
        }</span>

        // Try to verify with all available materials.
        <span class="cov8" title="1">materials, _, err := s.materialRepo.ListByElasticJWK(ctx, elasticJWKID, 0, cryptoutilSharedMagic.JoseJADefaultListLimit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list materials: %w", err)
        }</span>

        <span class="cov8" title="1">for _, material := range materials </span><span class="cov8" title="1">{
                verifiedPayload, verifyErr := s.verifyWithMaterial(ctx, jwsObject, material)
                if verifyErr == nil </span><span class="cov8" title="1">{
                        return verifiedPayload, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("failed to verify JWS: no matching key found")</span>
}

// SignWithKID signs payload using a specific material key.
func (s *jwsServiceImpl) SignWithKID(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, materialKID string, payload []byte) (string, error) <span class="cov8" title="1">{
        // Get elastic JWK.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        // Verify tenant ownership.
        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return "", fmt.Errorf("elastic JWK not found")
        }</span>

        // Verify key use is for signing.
        <span class="cov8" title="1">if elasticJWK.Use != cryptoutilAppsJoseJaDomain.KeyUseSig </span><span class="cov8" title="1">{
                return "", fmt.Errorf("elastic JWK is not configured for signing (use=%s)", elasticJWK.Use)
        }</span>

        // Find material by KID.
        <span class="cov8" title="1">material, err := s.materialRepo.GetByMaterialKID(ctx, materialKID)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get material by KID: %w", err)
        }</span>

        // Verify material belongs to elastic JWK.
        <span class="cov8" title="1">if material.ElasticJWKID != elasticJWKID </span><span class="cov8" title="1">{
                return "", fmt.Errorf("material key does not belong to elastic JWK")
        }</span>

        <span class="cov8" title="1">return s.signWithMaterial(ctx, elasticJWK, material, payload)</span>
}

// signWithMaterial signs payload using a specific material key.
func (s *jwsServiceImpl) signWithMaterial(ctx context.Context, elasticJWK *cryptoutilAppsJoseJaDomain.ElasticJWK, material *cryptoutilAppsJoseJaDomain.MaterialJWK, payload []byte) (string, error) <span class="cov8" title="1">{
        // Decode base64 encoded JWE string.
        privateJWKEncrypted, err := base64.StdEncoding.DecodeString(material.PrivateJWKJWE)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode private JWK JWE: %w", err)
        }</span>

        // Decrypt private JWK.
        <span class="cov8" title="1">privateJWKJSON, err := s.barrierSvc.DecryptContentWithContext(ctx, privateJWKEncrypted)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decrypt private JWK: %w", err)
        }</span>

        // Parse private JWK.
        <span class="cov8" title="1">var privateJWK jose.JSONWebKey
        if err := privateJWK.UnmarshalJSON(privateJWKJSON); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse private JWK: %w", err)
        }</span>

        // Determine signing algorithm.
        <span class="cov8" title="1">sigAlg := mapToSignatureAlgorithm(elasticJWK.Algorithm)
        if sigAlg == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unsupported algorithm for JWS: %s", elasticJWK.Algorithm)
        }</span>

        // Create signer.
        <span class="cov8" title="1">signerOpts := &amp;jose.SignerOptions{}
        signerOpts.WithHeader(jose.HeaderKey("kid"), material.MaterialKID)

        signer, err := jose.NewSigner(jose.SigningKey{Algorithm: sigAlg, Key: privateJWK}, signerOpts)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create signer: %w", err)
        }</span>

        // Sign payload.
        <span class="cov8" title="1">jwsObject, err := signer.Sign(payload)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign: %w", err)
        }</span>

        // Serialize to compact form.
        <span class="cov8" title="1">compact, err := jwsObject.CompactSerialize()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to serialize JWS: %w", err)
        }</span>

        <span class="cov8" title="1">return compact, nil</span>
}

// verifyWithMaterial verifies a JWS with a specific material key.
func (s *jwsServiceImpl) verifyWithMaterial(ctx context.Context, jwsObject *jose.JSONWebSignature, material *cryptoutilAppsJoseJaDomain.MaterialJWK) ([]byte, error) <span class="cov8" title="1">{
        // Decode base64 encoded JWE string.
        publicJWKEncrypted, err := base64.StdEncoding.DecodeString(material.PublicJWKJWE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode public JWK JWE: %w", err)
        }</span>

        // Decrypt public JWK.
        <span class="cov8" title="1">publicJWKJSON, err := s.barrierSvc.DecryptContentWithContext(ctx, publicJWKEncrypted)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt public JWK: %w", err)
        }</span>

        // Parse public JWK.
        <span class="cov8" title="1">var publicJWK jose.JSONWebKey
        if err := publicJWK.UnmarshalJSON(publicJWKJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse public JWK: %w", err)
        }</span>

        // Attempt verification.
        <span class="cov8" title="1">verifiedPayload, err := jwsObject.Verify(publicJWK)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err //nolint:wrapcheck // Expected to fail for non-matching keys.
        }</span>

        <span class="cov8" title="1">return verifiedPayload, nil</span>
}

// mapToSignatureAlgorithm maps algorithm string to JWS signature algorithm.
func mapToSignatureAlgorithm(algorithm string) jose.SignatureAlgorithm <span class="cov8" title="1">{
        switch algorithm </span>{
        case "RS256", "RSA/2048":<span class="cov8" title="1">
                return jose.RS256</span>
        case "RS384", "RSA/3072":<span class="cov8" title="1">
                return jose.RS384</span>
        case "RS512", "RSA/4096":<span class="cov8" title="1">
                return jose.RS512</span>
        case "PS256":<span class="cov8" title="1">
                return jose.PS256</span>
        case "PS384":<span class="cov8" title="1">
                return jose.PS384</span>
        case "PS512":<span class="cov8" title="1">
                return jose.PS512</span>
        case "ES256", "EC/P256":<span class="cov8" title="1">
                return jose.ES256</span>
        case "ES384", "EC/P384":<span class="cov8" title="1">
                return jose.ES384</span>
        case "ES512", "EC/P521":<span class="cov8" title="1">
                return jose.ES512</span>
        case "EdDSA", "OKP/Ed25519":<span class="cov8" title="1">
                return jose.EdDSA</span>
        case "HS256", "oct/256":<span class="cov8" title="1">
                return jose.HS256</span>
        case "HS384", "oct/384":<span class="cov8" title="1">
                return jose.HS384</span>
        case "HS512", "oct/512":<span class="cov8" title="1">
                return jose.HS512</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}
</pre>

		<pre class="file" id="file5" style="display: none">// Copyright (c) 2025 Justin Cranford
//

// Package service provides business logic services for jose-ja.
package service

import (
        "context"
        "encoding/base64"
        json "encoding/json"
        "fmt"
        "time"

        cryptoutilAppsJoseJaDomain "cryptoutil/internal/apps/jose/ja/domain"
        cryptoutilAppsJoseJaRepository "cryptoutil/internal/apps/jose/ja/repository"
        cryptoutilAppsTemplateServiceServerBarrier "cryptoutil/internal/apps/template/service/server/barrier"

        jose "github.com/go-jose/go-jose/v4"
        "github.com/go-jose/go-jose/v4/jwt"
        googleUuid "github.com/google/uuid"
)

// JWTClaims represents standard JWT claims.
type JWTClaims struct {
        Issuer    string                 `json:"iss,omitempty"`
        Subject   string                 `json:"sub,omitempty"`
        Audience  []string               `json:"aud,omitempty"`
        ExpiresAt *time.Time             `json:"exp,omitempty"`
        NotBefore *time.Time             `json:"nbf,omitempty"`
        IssuedAt  *time.Time             `json:"iat,omitempty"`
        JTI       string                 `json:"jti,omitempty"`
        Custom    map[string]any `json:"-"` // Additional custom claims.
}

// JWTService provides business logic for JWT operations.
type JWTService interface {
        // CreateJWT creates a signed JWT with the given claims.
        CreateJWT(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, claims *JWTClaims) (string, error)

        // ValidateJWT validates a JWT and returns the claims.
        ValidateJWT(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, token string) (*JWTClaims, error)

        // CreateEncryptedJWT creates an encrypted JWT (JWE containing JWT).
        CreateEncryptedJWT(ctx context.Context, tenantID, signingKeyID, encryptionKeyID googleUuid.UUID, claims *JWTClaims) (string, error)
}

// jwtServiceImpl implements JWTService.
type jwtServiceImpl struct {
        elasticRepo  cryptoutilAppsJoseJaRepository.ElasticJWKRepository
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository
        barrierSvc   *cryptoutilAppsTemplateServiceServerBarrier.Service
}

// NewJWTService creates a new JWTService.
func NewJWTService(
        elasticRepo cryptoutilAppsJoseJaRepository.ElasticJWKRepository,
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository,
        barrierSvc *cryptoutilAppsTemplateServiceServerBarrier.Service,
) JWTService <span class="cov8" title="1">{
        return &amp;jwtServiceImpl{
                elasticRepo:  elasticRepo,
                materialRepo: materialRepo,
                barrierSvc:   barrierSvc,
        }
}</span>

// CreateJWT creates a signed JWT with the given claims.
func (s *jwtServiceImpl) CreateJWT(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, claims *JWTClaims) (string, error) <span class="cov8" title="1">{
        // Verify tenant ownership and get elastic JWK.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return "", fmt.Errorf("elastic JWK not found")
        }</span>

        // Validate key use for signing.
        <span class="cov8" title="1">if elasticJWK.Use != cryptoutilAppsJoseJaDomain.KeyUseSig </span><span class="cov8" title="1">{
                return "", fmt.Errorf("key is not configured for signing (use=%s)", elasticJWK.Use)
        }</span>

        // Get active material.
        <span class="cov8" title="1">material, err := s.materialRepo.GetActiveMaterial(ctx, elasticJWKID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get active material: %w", err)
        }</span>

        // Decode base64 encoded JWE string.
        <span class="cov8" title="1">privateJWKEncrypted, err := base64.StdEncoding.DecodeString(material.PrivateJWKJWE)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode private JWK JWE: %w", err)
        }</span>

        // Decrypt private JWK using barrier service.
        <span class="cov8" title="1">privateJWKJSON, err := s.barrierSvc.DecryptContentWithContext(ctx, privateJWKEncrypted)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decrypt private JWK: %w", err)
        }</span>

        // Parse private JWK.
        <span class="cov8" title="1">var privateJWK jose.JSONWebKey
        if err := privateJWK.UnmarshalJSON(privateJWKJSON); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse private JWK: %w", err)
        }</span>

        // Set KID on private JWK.
        <span class="cov8" title="1">privateJWK.KeyID = material.MaterialKID

        // Create JWT signer.
        sigAlg := jose.SignatureAlgorithm(elasticJWK.Algorithm)
        signerOpts := (&amp;jose.SignerOptions{}).WithHeader(jose.HeaderKey("kid"), material.MaterialKID)

        signer, err := jose.NewSigner(jose.SigningKey{Algorithm: sigAlg, Key: privateJWK}, signerOpts)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create signer: %w", err)
        }</span>

        // Build claims map.
        <span class="cov8" title="1">claimsMap := s.buildClaimsMap(claims)

        // Create and sign JWT.
        builder := jwt.Signed(signer).Claims(claimsMap)

        token, err := builder.Serialize()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create JWT: %w", err)
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

// ValidateJWT validates a JWT and returns the claims.
func (s *jwtServiceImpl) ValidateJWT(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, token string) (*JWTClaims, error) <span class="cov8" title="1">{
        // Verify tenant ownership and get elastic JWK.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("elastic JWK not found")
        }</span>

        // Parse JWT to extract KID.
        <span class="cov8" title="1">parsedJWT, err := jwt.ParseSigned(token, []jose.SignatureAlgorithm{jose.SignatureAlgorithm(elasticJWK.Algorithm)})
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse JWT: %w", err)
        }</span>

        // Get the KID from header.
        <span class="cov8" title="1">if len(parsedJWT.Headers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("JWT has no headers")
        }</span>

        <span class="cov8" title="1">kid := parsedJWT.Headers[0].KeyID

        // Get material by KID.
        var material *cryptoutilAppsJoseJaDomain.MaterialJWK

        if kid != "" </span><span class="cov8" title="1">{
                material, err = s.materialRepo.GetByMaterialKID(ctx, kid)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get material by KID: %w", err)
                }</span>

                // Verify the material belongs to the correct elastic JWK.
                <span class="cov8" title="1">if material.ElasticJWKID != elasticJWKID </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("material KID does not belong to this elastic JWK")
                }</span>
        } else<span class="cov0" title="0"> {
                // Fallback to active material.
                material, err = s.materialRepo.GetActiveMaterial(ctx, elasticJWKID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get active material: %w", err)
                }</span>
        }

        // Decode base64 encoded JWE string.
        <span class="cov8" title="1">publicJWKEncrypted, err := base64.StdEncoding.DecodeString(material.PublicJWKJWE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode public JWK JWE: %w", err)
        }</span>

        // Decrypt public JWK using barrier service.
        <span class="cov8" title="1">publicJWKJSON, err := s.barrierSvc.DecryptContentWithContext(ctx, publicJWKEncrypted)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt public JWK: %w", err)
        }</span>

        // Parse public JWK.
        <span class="cov8" title="1">var publicJWK jose.JSONWebKey
        if err := publicJWK.UnmarshalJSON(publicJWKJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse public JWK: %w", err)
        }</span>

        // Verify and extract claims.
        <span class="cov8" title="1">var claimsMap map[string]any
        if err := parsedJWT.Claims(publicJWK, &amp;claimsMap); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("JWT validation failed: %w", err)
        }</span>

        // Convert claims map to JWTClaims.
        <span class="cov8" title="1">claims := s.parseClaimsMap(claimsMap)

        // Validate expiration.
        now := time.Now()
        if claims.ExpiresAt != nil &amp;&amp; claims.ExpiresAt.Before(now) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("JWT has expired")
        }</span>

        // Validate not-before.
        <span class="cov8" title="1">if claims.NotBefore != nil &amp;&amp; claims.NotBefore.After(now) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("JWT is not yet valid")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

// CreateEncryptedJWT creates an encrypted JWT (JWE containing signed JWT).
func (s *jwtServiceImpl) CreateEncryptedJWT(ctx context.Context, tenantID, signingKeyID, encryptionKeyID googleUuid.UUID, claims *JWTClaims) (string, error) <span class="cov8" title="1">{
        // First, create a signed JWT.
        signedJWT, err := s.CreateJWT(ctx, tenantID, signingKeyID, claims)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to create signed JWT: %w", err)
        }</span>

        // Get encryption key.
        <span class="cov8" title="1">encryptionKey, err := s.elasticRepo.GetByID(ctx, encryptionKeyID)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get encryption key: %w", err)
        }</span>

        <span class="cov8" title="1">if encryptionKey.TenantID != tenantID </span><span class="cov8" title="1">{
                return "", fmt.Errorf("encryption key not found")
        }</span>

        // Validate key use for encryption.
        <span class="cov8" title="1">if encryptionKey.Use != cryptoutilAppsJoseJaDomain.KeyUseEnc </span><span class="cov8" title="1">{
                return "", fmt.Errorf("key is not configured for encryption (use=%s)", encryptionKey.Use)
        }</span>

        // Get active material for encryption.
        <span class="cov8" title="1">encMaterial, err := s.materialRepo.GetActiveMaterial(ctx, encryptionKeyID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get encryption material: %w", err)
        }</span>

        // Decode base64 encoded JWE string.
        <span class="cov8" title="1">publicJWKEncrypted, err := base64.StdEncoding.DecodeString(encMaterial.PublicJWKJWE)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode public JWK JWE: %w", err)
        }</span>

        // Decrypt public JWK for encryption using barrier service.
        <span class="cov8" title="1">publicJWKJSON, err := s.barrierSvc.DecryptContentWithContext(ctx, publicJWKEncrypted)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decrypt public JWK: %w", err)
        }</span>

        // Parse public JWK.
        <span class="cov8" title="1">var publicJWK jose.JSONWebKey
        if err := publicJWK.UnmarshalJSON(publicJWKJSON); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse public JWK: %w", err)
        }</span>

        // Determine encryption algorithms.
        <span class="cov8" title="1">keyAlg, contentEnc := mapToJWEAlgorithms(encryptionKey.Algorithm)
        if keyAlg == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unsupported algorithm for JWE: %s", encryptionKey.Algorithm)
        }</span>

        // Create encrypter with content type header.
        <span class="cov8" title="1">encrypterOpts := (&amp;jose.EncrypterOptions{}).WithContentType("JWT")

        encrypter, err := jose.NewEncrypter(contentEnc, jose.Recipient{Algorithm: keyAlg, Key: publicJWK}, encrypterOpts)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create encrypter: %w", err)
        }</span>

        // Encrypt the signed JWT.
        <span class="cov8" title="1">jweObject, err := encrypter.Encrypt([]byte(signedJWT))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encrypt JWT: %w", err)
        }</span>

        // Serialize to compact format.
        <span class="cov8" title="1">compact, err := jweObject.CompactSerialize()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to serialize encrypted JWT: %w", err)
        }</span>

        <span class="cov8" title="1">return compact, nil</span>
}

// buildClaimsMap converts JWTClaims to a map for JWT creation.
func (s *jwtServiceImpl) buildClaimsMap(claims *JWTClaims) map[string]any <span class="cov8" title="1">{
        claimsMap := make(map[string]any)

        if claims.Issuer != "" </span><span class="cov8" title="1">{
                claimsMap["iss"] = claims.Issuer
        }</span>

        <span class="cov8" title="1">if claims.Subject != "" </span><span class="cov8" title="1">{
                claimsMap["sub"] = claims.Subject
        }</span>

        <span class="cov8" title="1">if len(claims.Audience) &gt; 0 </span><span class="cov8" title="1">{
                if len(claims.Audience) == 1 </span><span class="cov8" title="1">{
                        claimsMap["aud"] = claims.Audience[0]
                }</span> else<span class="cov8" title="1"> {
                        claimsMap["aud"] = claims.Audience
                }</span>
        }

        <span class="cov8" title="1">if claims.ExpiresAt != nil </span><span class="cov8" title="1">{
                claimsMap["exp"] = claims.ExpiresAt.Unix()
        }</span>

        <span class="cov8" title="1">if claims.NotBefore != nil </span><span class="cov8" title="1">{
                claimsMap["nbf"] = claims.NotBefore.Unix()
        }</span>

        <span class="cov8" title="1">if claims.IssuedAt != nil </span><span class="cov8" title="1">{
                claimsMap["iat"] = claims.IssuedAt.Unix()
        }</span>

        <span class="cov8" title="1">if claims.JTI != "" </span><span class="cov8" title="1">{
                claimsMap["jti"] = claims.JTI
        }</span>

        // Add custom claims.
        <span class="cov8" title="1">for k, v := range claims.Custom </span><span class="cov8" title="1">{
                claimsMap[k] = v
        }</span>

        <span class="cov8" title="1">return claimsMap</span>
}

// parseClaimsMap converts a claims map back to JWTClaims.
func (s *jwtServiceImpl) parseClaimsMap(claimsMap map[string]any) *JWTClaims <span class="cov8" title="1">{
        claims := &amp;JWTClaims{
                Custom: make(map[string]any),
        }

        for k, v := range claimsMap </span><span class="cov8" title="1">{
                switch k </span>{
                case "iss":<span class="cov8" title="1">
                        if str, ok := v.(string); ok </span><span class="cov8" title="1">{
                                claims.Issuer = str
                        }</span>
                case "sub":<span class="cov8" title="1">
                        if str, ok := v.(string); ok </span><span class="cov8" title="1">{
                                claims.Subject = str
                        }</span>
                case "aud":<span class="cov8" title="1">
                        switch a := v.(type) </span>{
                        case string:<span class="cov8" title="1">
                                claims.Audience = []string{a}</span>
                        case []any:<span class="cov8" title="1">
                                for _, item := range a </span><span class="cov8" title="1">{
                                        if str, ok := item.(string); ok </span><span class="cov8" title="1">{
                                                claims.Audience = append(claims.Audience, str)
                                        }</span>
                                }
                        }
                case "exp":<span class="cov8" title="1">
                        if f, ok := v.(float64); ok </span><span class="cov8" title="1">{
                                t := time.Unix(int64(f), 0)
                                claims.ExpiresAt = &amp;t
                        }</span> else<span class="cov0" title="0"> if n, ok := v.(json.Number); ok </span><span class="cov0" title="0">{
                                i, _ := n.Int64()
                                t := time.Unix(i, 0)
                                claims.ExpiresAt = &amp;t
                        }</span>
                case "nbf":<span class="cov8" title="1">
                        if f, ok := v.(float64); ok </span><span class="cov8" title="1">{
                                t := time.Unix(int64(f), 0)
                                claims.NotBefore = &amp;t
                        }</span> else<span class="cov0" title="0"> if n, ok := v.(json.Number); ok </span><span class="cov0" title="0">{
                                i, _ := n.Int64()
                                t := time.Unix(i, 0)
                                claims.NotBefore = &amp;t
                        }</span>
                case "iat":<span class="cov8" title="1">
                        if f, ok := v.(float64); ok </span><span class="cov8" title="1">{
                                t := time.Unix(int64(f), 0)
                                claims.IssuedAt = &amp;t
                        }</span> else<span class="cov0" title="0"> if n, ok := v.(json.Number); ok </span><span class="cov0" title="0">{
                                i, _ := n.Int64()
                                t := time.Unix(i, 0)
                                claims.IssuedAt = &amp;t
                        }</span>
                case "jti":<span class="cov8" title="1">
                        if str, ok := v.(string); ok </span><span class="cov8" title="1">{
                                claims.JTI = str
                        }</span>
                default:<span class="cov8" title="1">
                        claims.Custom[k] = v</span>
                }
        }

        <span class="cov8" title="1">return claims</span>
}
</pre>

		<pre class="file" id="file6" style="display: none">// Copyright (c) 2025 Justin Cranford
//

// Package service provides business logic services for jose-ja.
package service

import (
        "context"
        "encoding/base64"
        "fmt"
        "time"

        cryptoutilOpenapiModel "cryptoutil/api/model"
        cryptoutilAppsJoseJaDomain "cryptoutil/internal/apps/jose/ja/domain"
        cryptoutilAppsJoseJaRepository "cryptoutil/internal/apps/jose/ja/repository"
        cryptoutilAppsTemplateServiceServerBarrier "cryptoutil/internal/apps/template/service/server/barrier"
        cryptoutilSharedCryptoJose "cryptoutil/internal/shared/crypto/jose"
        cryptoutilSharedMagic "cryptoutil/internal/shared/magic"

        googleUuid "github.com/google/uuid"
)

// MaterialRotationService provides business logic for material JWK rotation.
type MaterialRotationService interface {
        // RotateMaterial creates a new active material and marks previous as inactive.
        RotateMaterial(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID) (*cryptoutilAppsJoseJaDomain.MaterialJWK, error)

        // RetireMaterial marks a material JWK as retired (no longer usable for signing/encryption).
        RetireMaterial(ctx context.Context, tenantID, elasticJWKID, materialID googleUuid.UUID) error

        // ListMaterials lists all materials for an elastic JWK.
        ListMaterials(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID) ([]*cryptoutilAppsJoseJaDomain.MaterialJWK, error)

        // GetActiveMaterial gets the currently active material for an elastic JWK.
        GetActiveMaterial(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID) (*cryptoutilAppsJoseJaDomain.MaterialJWK, error)

        // GetMaterialByKID gets a material by its KID (for decryption/verification).
        GetMaterialByKID(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, kid string) (*cryptoutilAppsJoseJaDomain.MaterialJWK, error)
}

// materialRotationServiceImpl implements MaterialRotationService.
type materialRotationServiceImpl struct {
        elasticRepo  cryptoutilAppsJoseJaRepository.ElasticJWKRepository
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository
        jwkGenSvc    *cryptoutilSharedCryptoJose.JWKGenService
        barrierSvc   *cryptoutilAppsTemplateServiceServerBarrier.Service
}

// NewMaterialRotationService creates a new MaterialRotationService.
func NewMaterialRotationService(
        elasticRepo cryptoutilAppsJoseJaRepository.ElasticJWKRepository,
        materialRepo cryptoutilAppsJoseJaRepository.MaterialJWKRepository,
        jwkGenSvc *cryptoutilSharedCryptoJose.JWKGenService,
        barrierSvc *cryptoutilAppsTemplateServiceServerBarrier.Service,
) MaterialRotationService <span class="cov8" title="1">{
        return &amp;materialRotationServiceImpl{
                elasticRepo:  elasticRepo,
                materialRepo: materialRepo,
                jwkGenSvc:    jwkGenSvc,
                barrierSvc:   barrierSvc,
        }
}</span>

// RotateMaterial creates a new active material and marks previous as inactive.
func (s *materialRotationServiceImpl) RotateMaterial(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID) (*cryptoutilAppsJoseJaDomain.MaterialJWK, error) <span class="cov8" title="1">{
        // Verify tenant ownership and get elastic JWK.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("elastic JWK not found")
        }</span>

        // Check if max materials reached.
        <span class="cov8" title="1">count, err := s.materialRepo.CountMaterials(ctx, elasticJWKID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count materials: %w", err)
        }</span>

        <span class="cov8" title="1">if int(count) &gt;= elasticJWK.MaxMaterials </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("max materials reached (%d), cannot rotate", elasticJWK.MaxMaterials)
        }</span>

        // Create new material.
        <span class="cov8" title="1">newMaterial, err := s.createMaterialJWK(ctx, elasticJWK)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create new material: %w", err)
        }</span>

        // Rotate material in repository (marks current active as inactive, activates new one).
        <span class="cov8" title="1">if err := s.materialRepo.RotateMaterial(ctx, elasticJWKID, newMaterial); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to rotate material: %w", err)
        }</span>

        // Update elastic JWK material count.
        <span class="cov8" title="1">if err := s.elasticRepo.IncrementMaterialCount(ctx, elasticJWKID); err != nil </span><span class="cov0" title="0">{
                // Log but don't fail - material was rotated successfully.
                fmt.Printf("warning: failed to update elastic JWK material count: %v\n", err)
        }</span>

        <span class="cov8" title="1">return newMaterial, nil</span>
}

// RetireMaterial marks a material JWK as retired.
func (s *materialRotationServiceImpl) RetireMaterial(ctx context.Context, tenantID, elasticJWKID, materialID googleUuid.UUID) error <span class="cov8" title="1">{
        // Verify tenant ownership.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return fmt.Errorf("elastic JWK not found")
        }</span>

        // Verify material belongs to this elastic JWK.
        <span class="cov8" title="1">material, err := s.materialRepo.GetByID(ctx, materialID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get material: %w", err)
        }</span>

        <span class="cov8" title="1">if material.ElasticJWKID != elasticJWKID </span><span class="cov8" title="1">{
                return fmt.Errorf("material not found for this elastic JWK")
        }</span>

        // Retire material.
        <span class="cov8" title="1">if err := s.materialRepo.RetireMaterial(ctx, materialID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retire material: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ListMaterials lists all materials for an elastic JWK.
func (s *materialRotationServiceImpl) ListMaterials(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID) ([]*cryptoutilAppsJoseJaDomain.MaterialJWK, error) <span class="cov8" title="1">{
        // Verify tenant ownership.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("elastic JWK not found")
        }</span>

        // List materials.
        <span class="cov8" title="1">materials, _, err := s.materialRepo.ListByElasticJWK(ctx, elasticJWKID, 0, cryptoutilSharedMagic.JoseJADefaultListLimit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list materials: %w", err)
        }</span>

        <span class="cov8" title="1">return materials, nil</span>
}

// GetActiveMaterial gets the currently active material for an elastic JWK.
func (s *materialRotationServiceImpl) GetActiveMaterial(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID) (*cryptoutilAppsJoseJaDomain.MaterialJWK, error) <span class="cov8" title="1">{
        // Verify tenant ownership.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("elastic JWK not found")
        }</span>

        // Get active material.
        <span class="cov8" title="1">material, err := s.materialRepo.GetActiveMaterial(ctx, elasticJWKID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active material: %w", err)
        }</span>

        <span class="cov8" title="1">return material, nil</span>
}

// GetMaterialByKID gets a material by its KID.
func (s *materialRotationServiceImpl) GetMaterialByKID(ctx context.Context, tenantID, elasticJWKID googleUuid.UUID, kid string) (*cryptoutilAppsJoseJaDomain.MaterialJWK, error) <span class="cov8" title="1">{
        // Verify tenant ownership.
        elasticJWK, err := s.elasticRepo.GetByID(ctx, elasticJWKID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get elastic JWK: %w", err)
        }</span>

        <span class="cov8" title="1">if elasticJWK.TenantID != tenantID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("elastic JWK not found")
        }</span>

        // Get material by KID.
        <span class="cov8" title="1">material, err := s.materialRepo.GetByMaterialKID(ctx, kid)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get material by KID: %w", err)
        }</span>

        // Verify material belongs to this elastic JWK.
        <span class="cov8" title="1">if material.ElasticJWKID != elasticJWKID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("material not found for this elastic JWK")
        }</span>

        <span class="cov8" title="1">return material, nil</span>
}

// createMaterialJWK generates a new material JWK.
func (s *materialRotationServiceImpl) createMaterialJWK(ctx context.Context, elasticJWK *cryptoutilAppsJoseJaDomain.ElasticJWK) (*cryptoutilAppsJoseJaDomain.MaterialJWK, error) <span class="cov8" title="1">{
        // Generate material ID.
        materialID := googleUuid.New()
        materialKID := materialID.String()

        // Convert algorithm to GenerateAlgorithm.
        genAlg := mapToGenerateAlgorithmForRotation(elasticJWK.Algorithm)
        if genAlg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported algorithm for key generation: %s", elasticJWK.Algorithm)
        }</span>

        // Generate JWK using JWKGenService.
        <span class="cov8" title="1">kid, privateJWK, publicJWK, privateJWKBytes, publicJWKBytes, err := s.jwkGenSvc.GenerateJWK(genAlg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate JWK: %w", err)
        }</span>

        // Use generated KID if not already set.
        <span class="cov8" title="1">if kid != nil </span><span class="cov8" title="1">{
                materialKID = kid.String()
        }</span>

        // Set KID on JWKs.
        // Note: For symmetric keys (oct), publicJWK is nil - symmetric keys have no separate public key.
        <span class="cov8" title="1">if err := privateJWK.Set("kid", materialKID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to set private JWK kid: %w", err)
        }</span>

        // For asymmetric keys, set KID on public JWK as well.
        <span class="cov8" title="1">if publicJWK != nil </span><span class="cov8" title="1">{
                if err := publicJWK.Set("kid", materialKID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to set public JWK kid: %w", err)
                }</span>
        }

        // Encrypt private and public JWKs with barrier.
        // For symmetric keys (oct), use private JWK for both since there's no separate public key.
        <span class="cov8" title="1">privateJWEBytes, err := s.barrierSvc.EncryptContentWithContext(ctx, privateJWKBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt private JWK: %w", err)
        }</span>

        // For symmetric keys, publicJWKBytes is nil - use privateJWKBytes for both fields.
        <span class="cov8" title="1">publicBytesToEncrypt := publicJWKBytes
        if publicBytesToEncrypt == nil </span><span class="cov8" title="1">{
                publicBytesToEncrypt = privateJWKBytes
        }</span>

        <span class="cov8" title="1">publicJWEBytes, err := s.barrierSvc.EncryptContentWithContext(ctx, publicBytesToEncrypt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt public JWK: %w", err)
        }</span>

        // Base64 encode for storage as strings.
        <span class="cov8" title="1">privateJWE := base64.StdEncoding.EncodeToString(privateJWEBytes)
        publicJWE := base64.StdEncoding.EncodeToString(publicJWEBytes)

        // Create material JWK record.
        materialJWK := &amp;cryptoutilAppsJoseJaDomain.MaterialJWK{
                ID:             materialID,
                ElasticJWKID:   elasticJWK.ID,
                MaterialKID:    materialKID,
                PrivateJWKJWE:  privateJWE,
                PublicJWKJWE:   publicJWE,
                BarrierVersion: 1,
                Active:         true,
                CreatedAt:      time.Now(),
        }

        return materialJWK, nil</span>
}

// mapToGenerateAlgorithmForRotation maps algorithm string to OpenAPI GenerateAlgorithm.
// This is duplicated from elastic_jwk_service.go - consider extracting to shared utility.
func mapToGenerateAlgorithmForRotation(algorithm string) *cryptoutilOpenapiModel.GenerateAlgorithm <span class="cov8" title="1">{
        var alg cryptoutilOpenapiModel.GenerateAlgorithm

        switch algorithm </span>{
        case cryptoutilSharedMagic.JoseAlgRS256, cryptoutilSharedMagic.JoseAlgRS384, cryptoutilSharedMagic.JoseAlgRS512, cryptoutilSharedMagic.JoseKeyTypeRSA2048:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.RSA2048</span>
        case cryptoutilSharedMagic.JoseAlgPS256, cryptoutilSharedMagic.JoseAlgPS384, cryptoutilSharedMagic.JoseAlgPS512, cryptoutilSharedMagic.JoseKeyTypeRSA3072:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.RSA3072</span>
        case cryptoutilSharedMagic.JoseKeyTypeRSA4096:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.RSA4096</span>
        case cryptoutilSharedMagic.JoseAlgES256, cryptoutilSharedMagic.JoseKeyTypeECP256:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.ECP256</span>
        case cryptoutilSharedMagic.JoseAlgES384, cryptoutilSharedMagic.JoseKeyTypeECP384:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.ECP384</span>
        case cryptoutilSharedMagic.JoseAlgES512, cryptoutilSharedMagic.JoseKeyTypeECP521:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.ECP521</span>
        case cryptoutilSharedMagic.JoseAlgEdDSA, cryptoutilSharedMagic.JoseKeyTypeOKPEd25519:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.OKPEd25519</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct128, cryptoutilSharedMagic.JoseEncA128GCM:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.Oct128</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct192, cryptoutilSharedMagic.JoseEncA192GCM:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.Oct192</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct256, cryptoutilSharedMagic.JoseEncA256GCM:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.Oct256</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct384, cryptoutilSharedMagic.JoseEncA128CBCHS256:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.Oct384</span>
        case cryptoutilSharedMagic.JoseKeyTypeOct512, cryptoutilSharedMagic.JoseEncA256CBCHS512:<span class="cov8" title="1">
                alg = cryptoutilOpenapiModel.Oct512</span>
        default:<span class="cov8" title="1">
                return nil</span>
        }

        <span class="cov8" title="1">return &amp;alg</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
