
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>lint_workflow: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">cryptoutil/internal/cmd/cicd/lint_workflow/lint_workflow.go (100.0%)</option>
				
				<option value="file1">cryptoutil/internal/cmd/cicd/lint_workflow/workflow.go (82.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2025 Justin Cranford

// Package lint_workflow provides linting utilities for GitHub workflow files.
package lint_workflow

import (
        "fmt"

        cryptoutilCmdCicdCommon "cryptoutil/internal/cmd/cicd/common"
)

// LinterFunc is a function type for individual workflow linters.
// Each linter receives a logger and a list of workflow files, returning an error if issues are found.
type LinterFunc func(logger *cryptoutilCmdCicdCommon.Logger, workflowFiles []string) error

// registeredLinters holds all linters to run as part of lint-workflow.
var registeredLinters = []struct {
        name   string
        linter LinterFunc
}{
        {"github-actions", lintGitHubWorkflows},
}

// Lint runs all registered workflow linters.
// It filters the provided files to only include workflow files.
// Returns an error if any linter finds issues.
func Lint(logger *cryptoutilCmdCicdCommon.Logger, filesByExtension map[string][]string) error <span class="cov3" title="5">{
        logger.Log("Running workflow linters...")

        // Filter to workflow files only from yml and yaml extensions.
        workflowFiles := filterWorkflowFiles(filesByExtension)

        if len(workflowFiles) == 0 </span><span class="cov2" title="2">{
                logger.Log("lint-workflow completed (no workflow files)")

                return nil
        }</span>

        <span class="cov2" title="3">logger.Log(fmt.Sprintf("Found %d workflow files to lint", len(workflowFiles)))

        var errors []error

        for _, l := range registeredLinters </span><span class="cov2" title="3">{
                logger.Log(fmt.Sprintf("Running linter: %s", l.name))

                if err := l.linter(logger, workflowFiles); err != nil </span><span class="cov2" title="2">{
                        errors = append(errors, fmt.Errorf("%s: %w", l.name, err))
                }</span>
        }

        <span class="cov2" title="3">if len(errors) &gt; 0 </span><span class="cov2" title="2">{
                logger.Log(fmt.Sprintf("lint-workflow completed with %d errors", len(errors)))

                return fmt.Errorf("lint-workflow failed with %d errors", len(errors))
        }</span>

        <span class="cov1" title="1">logger.Log("lint-workflow completed successfully")

        return nil</span>
}

// filterWorkflowFiles returns only GitHub workflow files from the yml/yaml files in the map.
func filterWorkflowFiles(filesByExtension map[string][]string) []string <span class="cov5" title="13">{
        var workflowFiles []string

        // Check yml files.
        for _, f := range filesByExtension["yml"] </span><span class="cov5" title="12">{
                if isWorkflowFile(f) </span><span class="cov5" title="10">{
                        workflowFiles = append(workflowFiles, f)
                }</span>
        }

        // Check yaml files.
        <span class="cov5" title="13">for _, f := range filesByExtension["yaml"] </span><span class="cov4" title="6">{
                if isWorkflowFile(f) </span><span class="cov2" title="2">{
                        workflowFiles = append(workflowFiles, f)
                }</span>
        }

        <span class="cov5" title="13">return workflowFiles</span>
}

// isWorkflowFile checks if a file path is a GitHub workflow file.
func isWorkflowFile(path string) bool <span class="cov7" title="39">{
        // Check for .github/workflows/ in the path.
        // Support both forward and backward slashes for cross-platform compatibility.
        return (len(path) &gt; 4 &amp;&amp; (path[len(path)-4:] == ".yml" || path[len(path)-5:] == ".yaml")) &amp;&amp;
                (contains(path, ".github/workflows/") || contains(path, ".github\\workflows\\"))
}</span>

// contains checks if s contains substr.
func contains(s, substr string) bool <span class="cov7" title="52">{
        return len(s) &gt;= len(substr) &amp;&amp; findSubstring(s, substr) &gt;= 0
}</span>

// findSubstring returns the index of substr in s, or -1 if not found.
func findSubstring(s, substr string) int <span class="cov7" title="43">{
        if len(substr) == 0 </span><span class="cov4" title="6">{
                return 0
        }</span>

        <span class="cov7" title="37">if len(substr) &gt; len(s) </span><span class="cov2" title="2">{
                return -1
        }</span>

        <span class="cov7" title="35">for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov10" title="165">{
                if s[i:i+len(substr)] == substr </span><span class="cov6" title="27">{
                        return i
                }</span>
        }

        <span class="cov4" title="8">return -1</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2025 Justin Cranford

package lint_workflow

import (
        json "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        cryptoutilCmdCicdCommon "cryptoutil/internal/cmd/cicd/common"
        cryptoutilSharedMagic "cryptoutil/internal/shared/magic"
)

// WorkflowActionDetails contains information about a GitHub Action used in workflows.
type WorkflowActionDetails struct {
        Name           string
        CurrentVersion string
        LatestVersion  string
        WorkflowFiles  []string
}

// WorkflowActionException represents an exception for outdated action versions.
type WorkflowActionException struct {
        Version string `json:"version"`
        Reason  string `json:"reason"`
}

// WorkflowActionExceptions contains all action exceptions.
type WorkflowActionExceptions struct {
        Exceptions map[string]WorkflowActionException `json:"exceptions"`
}

// lintGitHubWorkflows validates GitHub workflow files for outdated actions and other issues.
// It returns an error if validation fails or outdated actions are found.
func lintGitHubWorkflows(logger *cryptoutilCmdCicdCommon.Logger, workflowFiles []string) error <span class="cov7" title="9">{
        workflowActionExceptions, err := loadWorkflowActionExceptions()
        if err != nil </span><span class="cov5" title="5">{
                logger.Log(fmt.Sprintf("Warning: Failed to load action exceptions: %v", err))

                workflowActionExceptions = &amp;WorkflowActionExceptions{Exceptions: make(map[string]WorkflowActionException)}
        }</span>

        <span class="cov7" title="9">workflowsActionDetails, err := validateAndGetWorkflowActionsDetails(logger, workflowFiles)
        if err != nil </span><span class="cov4" title="4">{
                return fmt.Errorf("workflow validation failed: %w", err)
        }</span>

        // If no actions found, nothing to check.
        <span class="cov5" title="5">if len(workflowsActionDetails) == 0 </span><span class="cov4" title="3">{
                return nil
        }</span>

        // Check versions concurrently for better performance.
        <span class="cov2" title="2">logger.Log(fmt.Sprintf("Checking %d unique actions for updates", len(workflowsActionDetails)))

        versionCheckStart := time.Now().UTC()
        outdated, exempted, errors := checkActionVersionsConcurrently(logger, workflowsActionDetails, workflowActionExceptions)
        versionCheckEnd := time.Now().UTC()

        logger.Log(fmt.Sprintf("Version checks completed in %.2fs", versionCheckEnd.Sub(versionCheckStart).Seconds()))

        // Report results.
        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Warnings:")

                for _, err := range errors </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "  %s\n", err)
                }</span>

                <span class="cov0" title="0">fmt.Fprintln(os.Stderr, "")</span>
        }

        <span class="cov2" title="2">if len(exempted) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Exempted actions (allowed older versions):")

                for _, action := range exempted </span><span class="cov0" title="0">{
                        if exception, exists := workflowActionExceptions.Exceptions[action.Name]; exists </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "  %s@%s (in %s) - %s\n",
                                        action.Name, action.CurrentVersion, strings.Join(action.WorkflowFiles, ", "), exception.Reason)
                        }</span>
                }

                <span class="cov0" title="0">fmt.Fprintln(os.Stderr, "")</span>
        }

        <span class="cov2" title="2">if len(outdated) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Found outdated GitHub Actions:")

                for _, action := range outdated </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "  %s@%s -&gt; %s (in %s)\n",
                                action.Name, action.CurrentVersion, action.LatestVersion, strings.Join(action.WorkflowFiles, ", "))
                }</span>

                <span class="cov0" title="0">fmt.Fprintln(os.Stderr, "\nPlease update to the latest versions manually.")

                return fmt.Errorf("found %d outdated GitHub Actions", len(outdated))</span>
        }

        <span class="cov2" title="2">fmt.Fprintln(os.Stderr, "All GitHub Actions are up to date.")

        logger.Log("lint-workflow completed")

        return nil</span>
}

func validateAndGetWorkflowActionsDetails(logger *cryptoutilCmdCicdCommon.Logger, workflowFiles []string) (map[string]WorkflowActionDetails, error) <span class="cov8" title="14">{
        workflowsActionDetails := make(map[string]WorkflowActionDetails)

        var allValidationErrors []string

        for _, workflowFile := range workflowFiles </span><span class="cov9" title="17">{
                workflowActionDetails, workflowValidationErrors, vErr := validateAndParseWorkflowFile(workflowFile)
                if vErr != nil </span><span class="cov6" title="8">{
                        allValidationErrors = append(allValidationErrors, fmt.Sprintf("Failed to validate %s: %v", workflowFile, vErr))
                }</span>

                <span class="cov9" title="17">for _, issue := range workflowValidationErrors </span><span class="cov0" title="0">{
                        allValidationErrors = append(allValidationErrors, fmt.Sprintf("%s: %s", filepath.Base(workflowFile), issue))
                }</span>

                // Merge workflow action details, combining workflow files for duplicate actions.
                <span class="cov9" title="17">for key, newWorkflowActionDetails := range workflowActionDetails </span><span class="cov7" title="10">{
                        if existingWorkflowActionDetails, exists := workflowsActionDetails[key]; exists </span><span class="cov2" title="2">{
                                // Merge workflow files lists.
                                existingWorkflowActionDetails.WorkflowFiles = append(existingWorkflowActionDetails.WorkflowFiles, newWorkflowActionDetails.WorkflowFiles...)
                                workflowsActionDetails[key] = existingWorkflowActionDetails
                        }</span> else<span class="cov6" title="8"> {
                                workflowsActionDetails[key] = newWorkflowActionDetails
                        }</span>
                }
        }

        <span class="cov8" title="14">if len(allValidationErrors) &gt; 0 </span><span class="cov6" title="6">{
                fmt.Fprintln(os.Stderr, "Workflow validation errors:")

                for _, validationError := range allValidationErrors </span><span class="cov6" title="8">{
                        fmt.Fprintf(os.Stderr, "  - %s\n", validationError)
                }</span>

                <span class="cov6" title="6">fmt.Fprintln(os.Stderr, "\nPlease fix the workflow files to match naming and logging conventions.")

                return nil, fmt.Errorf("found %d workflow validation errors", len(allValidationErrors))</span>
        }

        // If no actions were found, return empty map (not an error).
        <span class="cov6" title="8">if len(workflowsActionDetails) == 0 </span><span class="cov4" title="4">{
                fmt.Fprintln(os.Stderr, "No actions found in workflow files")

                logger.Log("lint-workflow completed (no actions)")

                return workflowsActionDetails, nil
        }</span>

        <span class="cov4" title="4">return workflowsActionDetails, nil</span>
}

func loadWorkflowActionExceptions() (*WorkflowActionExceptions, error) <span class="cov8" title="12">{
        exceptionsFile := ".github/workflow-action-exceptions.json"

        content, err := os.ReadFile(exceptionsFile)
        if err != nil </span><span class="cov5" title="5">{
                if os.IsNotExist(err) </span><span class="cov5" title="5">{
                        return &amp;WorkflowActionExceptions{Exceptions: make(map[string]WorkflowActionException)}, nil
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read exceptions file: %w", err)</span>
        }

        <span class="cov6" title="7">var exceptions WorkflowActionExceptions
        if err := json.Unmarshal(content, &amp;exceptions); err != nil </span><span class="cov6" title="6">{
                return nil, fmt.Errorf("failed to parse exceptions file: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;exceptions, nil</span>
}

func validateAndParseWorkflowFile(workflowFile string) (map[string]WorkflowActionDetails, []string, error) <span class="cov10" title="24">{
        content, err := os.ReadFile(workflowFile)
        if err != nil </span><span class="cov7" title="9">{
                return nil, nil, fmt.Errorf("failed to read workflow file: %w", err)
        }</span>

        <span class="cov8" title="15">var validationErrors []string

        actionDetails := make(map[string]WorkflowActionDetails)

        // Parse actions from workflow file using regex.
        // Pattern: uses: owner/repo@version.
        usesPattern := regexp.MustCompile(`uses:\s*([a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+)@(v?[a-zA-Z0-9._-]+)`)
        matches := usesPattern.FindAllStringSubmatch(string(content), -1)

        for _, match := range matches </span><span class="cov9" title="18">{
                if len(match) &gt;= cryptoutilSharedMagic.MinActionMatchGroups </span><span class="cov9" title="18">{
                        actionName := match[1]
                        version := match[2]

                        key := actionName + "@" + version
                        actionDetails[key] = WorkflowActionDetails{
                                Name:           actionName,
                                CurrentVersion: version,
                                WorkflowFiles:  []string{filepath.Base(workflowFile)},
                        }
                }</span>
        }

        <span class="cov8" title="15">return actionDetails, validationErrors, nil</span>
}

func checkActionVersionsConcurrently(_ *cryptoutilCmdCicdCommon.Logger, actionDetails map[string]WorkflowActionDetails, exceptions *WorkflowActionExceptions) (outdated, exempted []WorkflowActionDetails, errors []string) <span class="cov6" title="7">{
        // For simplicity, this implementation checks versions synchronously.
        // A full implementation would use goroutines and GitHub API calls.
        for _, action := range actionDetails </span><span class="cov7" title="9">{
                // Check if action is exempted.
                if exception, exists := exceptions.Exceptions[action.Name]; exists </span><span class="cov4" title="4">{
                        if action.CurrentVersion == exception.Version </span><span class="cov4" title="3">{
                                exempted = append(exempted, action)

                                continue</span>
                        }
                }

                // In a full implementation, we would check the latest version from GitHub.
                // For now, we just pass through without marking as outdated.
                <span class="cov6" title="6">_ = action</span>
        }

        <span class="cov6" title="7">return outdated, exempted, errors</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
