# Docker Compose Strategy - Refined Based on Grooming Sessions

## Executive Summary

Based on comprehensive grooming sessions analyzing Docker Compose strategy for cryptoutil products (KMS, Identity), the following refined strategy has been established. The approach prioritizes **developer experience** above all else, with immediate replacement of existing structures and zero migration effort.

## Core Principles

### Primary Success Criterion
**Developer Experience (DX) is paramount.** The strategy must enable:
- `docker compose up -d` works immediately without errors
- Intuitive discovery of UIs and APIs
- Zero documentation required for basic usage
- Self-evident configurations

### Key Decisions from Grooming

1. **Profile Strategy**: Both separate component profiles AND combination profiles
2. **Naming Convention**: `product-service-instance` (e.g., `kms-sqlite-1`, `identity-authz-1`)
3. **Federation**: Hard dependencies OR configuration-based (context-dependent)
4. **Data Seeding**: SQL migration files executed by first container instance
5. **Credentials**: Well-known test values + generated UUIDs for copy-paste convenience
6. **SPA Integration**: Separate `Dockerfile.spa` for SPA RP service
7. **Secrets Management**: Centralized secrets with `secrets/{product}/{service}/` + `secrets/{product}/shared/` hierarchy
8. **Telemetry**: Separate `demo-telemetry` profile combination
9. **Port Assignment**: Fixed ranges per product (KMS: 8080-8099, Identity: 8100-8199)
10. **Migration Pattern**: Health check dependencies - first instance applies migrations, others wait
11. **Health Checks**: Full health checks with dependencies for demo profiles
12. **Configuration**: Service-specific configs with optional profile extensions
13. **Architecture**: Single architecture (amd64) for now, buildx if requested
14. **Service Discovery**: Docker Compose service names as hostnames
15. **Build Optimization**: Multi-stage Dockerfiles with shared base layers
16. **Validation**: Go e2e tests orchestrating `docker compose` commands
17. **Credential Detection**: Separate validation service scanning configurations
18. **Demo Recovery**: Database volume snapshots on startup
19. **Host Environment**: Container-only dependencies (NO host volumes, NO ENVs)
20. **Future Products**: Fixed structure that ALL products must follow
21. **Transition**: IMMEDIATE REPLACEMENT - no migration, fix all references

## Implementation Phases

### Phase 1: Foundation (Immediate)
- Create standardized naming across all compose files
- Implement fixed port ranges per product with comments
- Establish centralized secrets structure: `secrets/{product}/{service}/` + `secrets/{product}/shared/`
- Create `Dockerfile.spa` for SPA RP
- Implement migration pattern with health check dependencies
- Set up Go e2e test framework for compose validation

### Phase 2: Profile System
- Implement both separate and combination profiles
- Create `demo-telemetry` profile combination
- Add profile validation via Go e2e tests
- Ensure all profiles work with `docker compose up -d`

### Phase 3: Developer Experience
- Implement well-known test credentials + UUID generation
- Add separate validation service for credential detection
- Ensure zero documentation needed for basic usage
- Implement database volume snapshots for demo environments
- Validate with Go e2e tests as success metric

### Phase 4: Federation & Scaling
- Implement hard dependencies OR config-based federation
- Use Docker Compose service names as hostnames for discovery
- Ensure fixed structure scales to future products
- Implement multi-stage Dockerfiles with shared base layers
- Add comprehensive security validation (permissions, isolation, scanning)

## Risk Mitigation

### Critical Risks Identified
1. **Profile Dependencies**: Avoid circular references through careful design
2. **Configuration Drift**: Use shared base configs with overrides + Go e2e validation
3. **Intuitive Config Risks**: Separate validation service detects default credential usage
4. **Breaking Changes**: Immediate replacement minimizes transition pain
5. **Version Compatibility**: Strict version pinning (all services same version)
6. **Host Environment Differences**: Container-only approach eliminates host dependencies

### Efficiency Opportunities
1. **Shared Containers**: Reuse containers between profiles where possible
2. **Build Optimization**: Multi-stage Dockerfiles with shared base layers + monorepo caching
3. **Standardized Naming**: Enables scripting, reduces cognitive load
4. **Centralized Secrets**: Easier maintenance, no duplication
5. **Service Discovery**: Docker service names eliminate hardcoded URLs

## Success Metrics

- ✅ `docker compose up -d` works for all profiles (validated by Go e2e tests)
- ✅ UIs and APIs discoverable without documentation
- ✅ No errors or warnings blocking usage
- ✅ Go e2e tests validate all profile combinations
- ✅ New developer onboarding time minimized
- ✅ Container-only approach works across Windows/Mac/Linux
- ✅ Scales to dozens of products with same pattern

## Technical Implementation Details

### Validation Framework
- **Go E2E Tests**: Orchestrate `docker compose` commands, validate service availability
- **Credential Detection**: Separate validation service scans configurations at startup
- **Security Validation**: File permissions, network isolation, image vulnerability scanning
- **Performance Benchmarks**: Startup times, resource usage, network latency

### Service Discovery
- **Docker Service Names**: Use compose service names as hostnames (e.g., `kms-postgres-1:5432`)
- **No Hardcoded URLs**: Eliminates configuration maintenance burden
- **Federation**: Service names enable cross-product communication

### Build Optimization
- **Multi-stage Dockerfiles**: Shared base layers reduce build times
- **BuildKit**: Parallel builds and caching for efficiency
- **Monorepo Approach**: Single build context for all products

### Operational Excellence
- **Database Snapshots**: Volume snapshots enable demo environment resets
- **Health Dependencies**: Migration coordination via compose health checks
- **Monitoring**: Container health, resource usage, startup times, error rates

## Open Questions for Next Grooming Sessions

1. How to implement shared containers between profiles technically?
2. What specific implementation details for the validation service?
3. How to structure the Go e2e test framework for compose validation?
4. What exact security validations are needed in CI/CD?
5. How to implement database volume snapshots efficiently?

## Next Steps

Proceeding to GROOMING-SESSION-05.md and GROOMING-SESSION-06.md for detailed implementation planning and CI/CD integration.
