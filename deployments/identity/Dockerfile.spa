#############################################################################################
# Identity SPA RP Dockerfile
# Use BuildKit syntax to enable cache mounts (fast rebuilds)
# To build with cache mounts set DOCKER_BUILDKIT=1
# Example: DOCKER_BUILDKIT=1 docker build -t cryptoutil-identity-spa-rp -f deployments/identity/Dockerfile.spa .
#
#############################################################################################
ARG APP_VERSION=UNSET
ARG VCS_REF=UNSET
ARG BUILD_DATE=UNSET
#############################################################################################
ARG GO_VERSION=1.25.4
ARG ALPINE_VERSION=3.19
ARG CGO_ENABLED=0
ARG GOOS=linux
ARG GOARCH=amd64
# Build flags for production container: static linking with debug symbols retained.
ARG LDFLAGS="-s -extldflags '-static'"
#############################################################################################

# Validate required build arguments
#############################################################################################
FROM alpine:${ALPINE_VERSION} AS validation
ARG APP_VERSION=UNSET
ARG VCS_REF=UNSET
ARG BUILD_DATE=UNSET

# Check all mandatory parameters and collect errors.
RUN set -e; \
    errors=""; \
    if [ "$APP_VERSION" = "UNSET" ]; then \
        errors="${errors}ERROR: APP_VERSION build argument is required\n"; \
    fi; \
    if [ "$VCS_REF" = "UNSET" ]; then \
        errors="${errors}ERROR: VCS_REF build argument is required\n"; \
    fi; \
    if [ "$BUILD_DATE" = "UNSET" ]; then \
        errors="${errors}ERROR: BUILD_DATE build argument is required\n"; \
    fi; \
    if [ -n "$errors" ]; then \
        printf "%b" "$errors" >&2; \
        echo "Usage: DOCKER_BUILDKIT=1 docker build --build-arg APP_VERSION=<version> --build-arg VCS_REF=\$(git rev-parse HEAD) --build-arg BUILD_DATE=\$(date -u +\"%Y-%m-%dT%H:%M:%SZ\") -t cryptoutil-identity-spa-rp -f deployments/identity/Dockerfile.spa ." >&2; \
        exit 1; \
    fi

# Write build parameters to file for runtime inspection.
RUN mkdir -p /app && \
    echo "APP_VERSION=${APP_VERSION}" > /app/.build-params && \
    echo "VCS_REF=${VCS_REF}" >> /app/.build-params && \
    echo "BUILD_DATE=${BUILD_DATE}" >> /app/.build-params && \
    cat /app/.build-params

#############################################################################################
FROM golang:${GO_VERSION} AS builder
WORKDIR /src

# Redeclare build args for use in this stage.
ARG APP_VERSION
ARG VCS_REF
ARG BUILD_DATE
ARG GO_VERSION
ARG CGO_ENABLED
ARG GOOS
ARG GOARCH
ARG LDFLAGS

# Copy dependency manifests first to leverage layer caching.
COPY go.mod go.sum ./

# Download modules using BuildKit cache mounts when available.
RUN --mount=type=cache,target=/go/pkg/mod \
    --mount=type=cache,target=/root/.cache/go-build \
    go mod download

# Copy the remainder of the source.
COPY . .

# Build the static, trimmed binary. Uses BuildKit cache mounts for faster incremental builds.
RUN --mount=type=cache,target=/go/pkg/mod \
    --mount=type=cache,target=/root/.cache/go-build \
    CGO_ENABLED=${CGO_ENABLED} GOOS=${GOOS} GOARCH=${GOARCH} \
    go build -a -tags netgo -trimpath -ldflags="${LDFLAGS}" -o /app/spa-rp ./internal/identity/cmd/main/spa-rp

# Validate that the binary is statically linked.
SHELL ["/bin/bash", "-c"]
RUN if ldd /app/spa-rp 2>/dev/null; then \
        echo "✗ Binary is dynamically linked - failing build"; \
        ldd /app/spa-rp; \
        exit 1; \
    else \
        echo "✓ Binary is statically linked"; \
    fi

# Create /app directory with proper ownership for the application user.
RUN mkdir -p /app && chmod 555 /app && chown -R 65532:65532 /app

# Create runtime directory for application data (certificates, etc.) with proper ownership.
RUN mkdir -p /app/run && chmod 775 /app/run && chown -R 65532:65532 /app/run

# Create cache directory for any caching needs with proper ownership.
RUN mkdir -p /app/cache && chmod 775 /app/cache && chown -R 65532:65532 /app/cache

#############################################################################################
FROM alpine:${ALPINE_VERSION} AS runtime
ARG APP_VERSION
ARG VCS_REF
ARG BUILD_DATE

# Install CA certificates for HTTPS requests.
RUN apk add --no-cache ca-certificates && \
    update-ca-certificates

# Create application user with UID 65532 (non-root).
RUN addgroup -g 65532 -S appgroup && \
    adduser -u 65532 -S appuser -G appgroup -h /app -s /sbin/nologin

# Copy build parameters for runtime inspection.
COPY --from=validation /app/.build-params /app/.build-params

# Copy the compiled binary from the builder stage.
COPY --from=builder /app/spa-rp /app/spa-rp

# Ensure binary has execute permissions and correct ownership.
RUN chmod 555 /app/spa-rp && \
    chown 65532:65532 /app/spa-rp

# Switch to non-root user.
USER 65532:65532

# Set working directory.
WORKDIR /app

# Expose ports (8083 for SPA, 9090 for admin/health).
EXPOSE 8083 9090

# Health check for the SPA RP service.
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD wget --no-check-certificate -q -O /dev/null http://127.0.0.1:8083/ || exit 1

# Set default command to run the SPA RP application.
CMD ["/app/spa-rp"]

#############################################################################################
# Labels for container metadata.
#############################################################################################
LABEL org.opencontainers.image.title="cryptoutil-identity-spa-rp" \
      org.opencontainers.image.description="SPA Relying Party for cryptoutil Identity services" \
      org.opencontainers.image.version="${APP_VERSION}" \
      org.opencontainers.image.created="${BUILD_DATE}" \
      org.opencontainers.image.source="https://github.com/justincranford/cryptoutil" \
      org.opencontainers.image.revision="${VCS_REF}" \
      org.opencontainers.image.licenses="MIT"
