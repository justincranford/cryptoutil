---
description: "Instructions for security implementation patterns"
applyTo: "**"
---
# Security

# Security Implementation Patterns - Tactical Guidance

## Quick Reference Checklist

- ✅ Monitor Go vulnerabilities: <https://pkg.go.dev/vuln/list>
- ✅ Multi-layer key barrier: unseal → root → intermediate → content
- ✅ IP allowlist + per-IP rate limiting + CORS + CSRF + CSP headers
- ✅ Docker secrets (NEVER environment variables)
- ✅ crypto/rand ALWAYS (NEVER math/rand)
- ✅ TLS 1.3+ with full cert chain validation
- ✅ Audit log security events (90-day retention minimum)
- ✅ Elastic key rotation (active key + historical keys)

## CRITICAL: Windows Firewall Exception Prevention

**MANDATORY: ALWAYS bind to 127.0.0.1 (NEVER 0.0.0.0) in tests and local development**

```go
// ✅ CORRECT: Bind to loopback only (no firewall prompt)
addr := fmt.Sprintf("%s:%d", cryptoutilMagic.IPv4Loopback, port)  // "127.0.0.1"
listener, err := net.Listen("tcp", addr)

// ❌ WRONG: Bind to all interfaces (triggers firewall prompt)
listener, err := net.Listen("tcp", fmt.Sprintf("0.0.0.0:%d", port))
```

**Impact**: Each `0.0.0.0` binding = 1 Windows Firewall popup, blocks CI/CD

## Localhost vs 127.0.0.1 Decision Matrix

| Environment | Preferred | Rationale |
|-------------|-----------|-----------|
| Local Windows Dev | `127.0.0.1` | Avoid firewall prompts |
| GitHub Workflows | `127.0.0.1` | Explicit IPv4, no DNS resolution |
| Docker Containers (internal) | `127.0.0.1` | Alpine resolves localhost to ::1 (IPv6) |
| Docker Compose (host→container) | `localhost` | Docker DNS handles resolution |
| Go Code (bind addresses) | `127.0.0.1` | Explicit IPv4, no ambiguity |
| Go Code (database DSN) | `localhost` | PostgreSQL driver handles resolution |

## Secret Management

✅ Docker/K8s secrets (NEVER env vars), file permissions 440 (r--r-----)
✅ Command: `--database-url=file:///run/secrets/database_url`

## Vulnerability Monitoring

Check weekly: `govulncheck ./...`. Sources: <https://pkg.go.dev/vuln/list>, <https://github.com/advisories>, <https://www.cvedetails.com/>. Update incrementally with testing.

---

## Multi-Layer Key Hierarchy

**Pattern: Unseal → Root → Intermediate → Content Keys**

- **Unseal Key**: Never stored in app, Docker secrets at runtime
- **Root Key**: Encrypted at rest with unseal key, rotated annually
- **Intermediate Keys**: Encrypted with root key, rotated quarterly
- **Content Keys**: Encrypted with intermediate keys, rotated per-operation or hourly

**See**: `02-07.cryptography.instructions.md` for HKDF-based key derivation

---

## Network Security

**IP Allowlisting**: IP addresses + CIDR ranges (127.0.0.1, ::1, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)

**Per-IP Rate Limiting**: Token bucket algorithm

- Public APIs: 100 req/min per IP (burst: 20)
- Admin APIs: 10 req/min per IP (burst: 5)
- Login endpoints: 5 req/min per IP (burst: 2)

---

## Web Security Headers

**CORS**: Restrict origins, methods, headers; allow credentials; 1h preflight cache

**CSRF**: Double-submit cookie or synchronizer token; exempt `/service/**` (headless clients)

**CSP**: `default-src: 'self'`, `script-src: 'self' 'unsafe-inline'`, `style-src: 'self' 'unsafe-inline'`, `img-src: 'self' data: https:`, `connect-src: 'self' wss:`, `object-src: 'none'`

---

## Secret Management

**MANDATORY: ALL credentials MUST use Docker/Kubernetes secrets, NEVER inline environment variables**

### Priority Order (MANDATORY)

**Highest to Lowest Priority**:

1. **Docker/Kubernetes Secrets** (HIGHEST - ALWAYS use for production)
   - Docker Compose: Mount via `/run/secrets/` (Docker Swarm + Compose v2)
   - Kubernetes: Mount via `secretKeyRef` or volume mounts
2. **YAML Configuration Files** (MEDIUM - acceptable for non-sensitive config)
   - Static application settings (ports, timeouts, feature flags)
   - Development/demo credentials in separate config files (NOT inline in compose)
3. **CLI Arguments** (LOW - acceptable for local development overrides)
   - Development-only overrides
   - Testing with dynamic values
4. **Inline Environment Variables** (NEVER - FORBIDDEN for all credentials)
   - ❌ SECURITY VIOLATION
   - ❌ Visible in `docker inspect`, process listings, logs
   - ❌ Accidentally committed to version control

### Docker Secrets Pattern

**Configuration**:

```yaml
services:
  cryptoutil:
    secrets: [database_url, unseal_key, tls_cert, tls_key]
    command: [
      "--database-url=file:///run/secrets/database_url",
      "--unseal-key=file:///run/secrets/unseal_key"
    ]

secrets:
  database_url:
    file: ./secrets/database_url.secret
  unseal_key:
    file: ./secrets/unseal_key.secret
  tls_cert:
    file: ./secrets/tls_cert.secret
  tls_key:
    file: ./secrets/tls_key.secret
```

**Application Code**:

```go
func loadSecret(path string) ([]byte, error) {
    if strings.HasPrefix(path, "file://") {
        return os.ReadFile(strings.TrimPrefix(path, "file://"))
    }
    return []byte(path), nil  // Fallback for dev
}
```

**File Permissions**: MANDATORY 440 (r--r----)

### Kubernetes Secrets Pattern

**Using secretKeyRef** (environment variable from secret):

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: cryptoutil
spec:
  containers:
  - name: app
    image: cryptoutil:latest
    env:
    - name: DATABASE_URL
      valueFrom:
        secretKeyRef:
          name: cryptoutil-secrets
          key: database-url
    - name: UNSEAL_KEY
      valueFrom:
        secretKeyRef:
          name: cryptoutil-secrets
          key: unseal-key
```

**Using volume mounts** (files at `/run/secrets/`):

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: cryptoutil
spec:
  containers:
  - name: app
    image: cryptoutil:latest
    volumeMounts:
    - name: secrets
      mountPath: "/run/secrets"
      readOnly: true
  volumes:
  - name: secrets
    secret:
      secretName: cryptoutil-secrets
```

### Validation Commands

**Detect Inline Credentials in Docker Compose**:

```bash
grep -E "PASSWORD|SECRET|TOKEN|PASSPHRASE|PRIVATE_KEY" compose.yml \
  | grep -v "# " \
  | grep -v "secrets:" \
  | grep -v "_FILE:" \
  | grep -v "run/secrets"
```

Expected result: Empty output (no inline credentials)

**Detect Inline Credentials in Kubernetes Manifests**:

```bash
grep -E "password:|secret:|token:|passphrase:|privateKey:" *.yaml \
  | grep -v "secretKeyRef:" \
  | grep -v "secretName:" \
  | grep -v "# "
```

Expected result: Empty output (no inline credentials)

**Validate Docker Compose Syntax**:

```bash
docker compose -f compose.yml config > /dev/null
```

Expected result: `✅ Valid` (no errors)

---

## Windows Firewall Exception Prevention

### CRITICAL: Bind to 127.0.0.1 in Tests

**Problem**: Binding to `0.0.0.0` triggers Windows Firewall prompts, blocking automation

**Violation Impact**:

- ❌ Each `0.0.0.0` binding = 1 Windows Firewall popup
- ❌ Blocks CI/CD automation (requires manual approval)
- ❌ Security risk (accidentally exposing test services to network)

**Correct Patterns**:

```go
// ✅ CORRECT: Bind to loopback only (no firewall prompt)
import cryptoutilMagic "cryptoutil/internal/shared/magic"

addr := fmt.Sprintf("%s:%d", cryptoutilMagic.IPv4Loopback, port)  // "127.0.0.1:port"
listener, err := net.Listen("tcp", addr)

// ❌ WRONG: Bind to all interfaces (triggers firewall prompt)
listener, err := net.Listen("tcp", fmt.Sprintf("0.0.0.0:%d", port))
```

**Configuration Files**:

```yaml
# ✅ CORRECT: Test configs use loopback
server:
  bind_address: 127.0.0.1
  bind_port: 0  # Dynamic allocation

# ❌ WRONG: Production pattern in test configs
server:
  bind_address: 0.0.0.0  # Only for Docker containers, NEVER for local tests
```

**Environment-Specific Binding**:

| Environment | Bind Address | Rationale |
|-------------|--------------|-----------|
| Local tests | 127.0.0.1 | Avoid firewall prompts |
| Docker containers | 0.0.0.0 | Container network isolation |
| Kubernetes pods | 0.0.0.0 | Pod network isolation |
| GitHub Actions | 127.0.0.1 | CI/CD environment |

### Localhost vs 127.0.0.1 Decision Matrix

| Environment | localhost | 127.0.0.1 | Preferred | Rationale |
|-------------|-----------|-----------|-----------|-----------|
| **Local Windows Dev** | ✅ | ✅ | `127.0.0.1` | Avoid firewall prompts |
| **GitHub Workflows** | ✅ | ✅ | `127.0.0.1` | Explicit IPv4, no DNS resolution |
| **Act Containers** | ✅ | ✅ | `127.0.0.1` | Consistent with GitHub |
| **Docker Containers (internal)** | ❌ | ✅ | `127.0.0.1` | Alpine resolves localhost to ::1 (IPv6) |
| **Docker Compose (host→container)** | ✅ | ✅ | `localhost` | Docker DNS handles resolution |
| **Go Code (bind addresses)** | ❌ | ✅ | `127.0.0.1` | Explicit IPv4, no ambiguity |
| **Go Code (database DSN)** | ✅ | ✅ | `localhost` | PostgreSQL driver handles resolution |

**Quick Reference for Go Server Binding**:

```go
// ALWAYS use magic constant
bindAddress := cryptoutilMagic.IPv4Loopback  // "127.0.0.1"
```

---

## Cryptographic Best Practices

**Random Number Generation**: MANDATORY `crypto/rand` ALWAYS, NEVER `math/rand`

**Certificate Validation**: MANDATORY TLS 1.3+, full cert chain, NEVER `InsecureSkipVerify: true`

**See**: `02-07.cryptography.instructions.md`, `02-09.pki.instructions.md`

---

## Audit Logging

**Pattern**: Structured logs with security-relevant fields

**Security Events to Log**: Authentication attempts (success+failures), authorization denials, key generation/rotation, certificate issuance/revocation, admin API access, rate limit violations, IP allowlist violations

**Retention**: Minimum 90 days (security events), 1 year (compliance)

---

## Secure Failure Modes

**Key Versioning & Rotation** (Elastic Key Ring):

- Encrypt: ALWAYS use active key
- Decrypt: Use key ID from ciphertext to find correct historical key
- Rotation: Generate new key → set as active, keep old in historical keys, re-encrypt on next write (lazy migration)

**Multiple Unseal Modes**: Auto-unseal (Docker secrets), manual-unseal (admin API), multi-party-unseal (Shamir 3 of 5 shares)

**See**: `02-07.cryptography.instructions.md` for HKDF patterns

---

## Key Takeaways

1. **Windows Firewall Prevention**: ALWAYS bind to 127.0.0.1 in tests (NEVER 0.0.0.0)
2. **Secret Management**: Docker secrets or Kubernetes secrets (NEVER environment variables)
3. **Cryptographic Security**: crypto/rand ALWAYS (NEVER math/rand), TLS 1.3+ with full cert validation
4. **Multi-Layer Keys**: Unseal → Root → Intermediate → Content (hierarchical encryption)
5. **Network Security**: IP allowlisting + per-IP rate limiting + CORS + CSRF + CSP headers
6. **Audit Logging**: Log all security events with structured fields, 90-day retention minimum
7. **Elastic Key Rotation**: Active key for encryption, historical keys for decryption (key ID embedded)
