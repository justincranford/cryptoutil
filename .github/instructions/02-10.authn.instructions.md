---
description: "Authentication and authorization architecture, factor lists, storage realms, session patterns"
applyTo: "**"
---
# Authentication and Authorization - CRITICAL

**Reference**: See `.specify/memory/authn-authz-factors.md` for authoritative authentication/authorization factor list (single source of truth)

This file provides tactical implementation guidance. For complete specifications, see reference document.

## Single Factor Authentication Methods - MANDATORY

**CRITICAL: All services MUST support configured authentication factors with specified storage realms**

**Quick Reference** (Complete details in `.specify/memory/authn-authz-factors.md`):

### Headless-Based Clients (10 Methods)

**Request Path**: `/service/**` paths only

**Non-Federated Methods** (3):

| Method | Storage Realm | Priority | Description |
|--------|---------------|----------|-------------|
| **Basic (Client ID/Secret)** | YAML + SQL | Config > DB | HTTP Basic authentication with client credentials |
| **Bearer (API Token)** | YAML + SQL | Config > DB | Bearer token authentication (API keys) |
| **HTTPS Client Certificate** | YAML + SQL | Config > DB | mTLS client certificate authentication |

**Federated Methods** (7):

| Method | Storage Realm | Priority | Description |
|--------|---------------|----------|-------------|
| **Basic (Client ID/Secret)** | YAML + SQL | Config > DB | HTTP Basic with OAuth 2.1 client credentials |
| **Bearer (API Token)** | YAML + SQL | Config > DB | Bearer token from external OAuth 2.1 provider |
| **HTTPS Client Certificate** | YAML + SQL | Config > DB | mTLS with OAuth 2.1 service-to-service |
| **JWE Access Token** | YAML + SQL | Config > DB | JSON Web Encryption access tokens |
| **JWS Access Token** | YAML + SQL | Config > DB | JSON Web Signature access tokens |
| **Opaque Access Token** | YAML + SQL | Config > DB | Non-JWT access tokens |
| **Opaque Refresh Token** | YAML + SQL | Config > DB | Non-JWT refresh tokens |

### Browser-Based Clients (28 Methods)

**Request Path**: `/browser/**` paths only

**Non-Federated Methods** (6):

| Method | Storage Realm | Priority | Description |
|--------|---------------|----------|-------------|
| **JWE Session Cookie** | YAML + SQL | Config > DB | Encrypted session cookie (JSON Web Encryption) |
| **JWS Session Cookie** | YAML + SQL | Config > DB | Signed session cookie (JSON Web Signature) |
| **Opaque Session Cookie** | YAML + SQL | Config > DB | Non-JWT session cookie |
| **Basic (Username/Password)** | YAML + SQL | Config > DB | HTTP Basic authentication with user credentials |
| **Bearer (API Token)** | YAML + SQL | Config > DB | Bearer token authentication |
| **HTTPS Client Certificate** | YAML + SQL | Config > DB | mTLS client certificate authentication |

**Federated Methods** (22):

All non-federated methods (6) PLUS:

| Method | Storage Realm | Priority | Description |
|--------|---------------|----------|-------------|
| **TOTP (Authenticator App)** | SQL ONLY | DB-only | Time-based One-Time Password (Google Authenticator, Authy) |
| **HOTP (Hardware Token)** | SQL ONLY | DB-only | HMAC-based One-Time Password (YubiKey, RSA SecurID) |
| **Recovery Codes** | SQL ONLY | DB-only | Backup single-use recovery codes |
| **WebAuthn with Passkeys** | SQL ONLY | DB-only | FIDO2 WebAuthn with platform authenticators (Face ID, Touch ID, Windows Hello) |
| **WebAuthn without Passkeys** | SQL ONLY | DB-only | FIDO2 WebAuthn with security keys (YubiKey, Titan Key) |
| **Push Notification** | SQL ONLY | DB-only | Mobile app push-based authentication |
| **Email/Password** | YAML + SQL | Config > DB | Email address + password authentication |
| **Magic Link (Email)** | SQL ONLY | DB-only | Passwordless email-based authentication |
| **Magic Link (SMS)** | SQL ONLY | DB-only | Passwordless SMS-based authentication |
| **Random OTP (Email)** | SQL ONLY | DB-only | One-time password sent via email |
| **Random OTP (SMS)** | SQL ONLY | DB-only | One-time password sent via SMS |
| **Random OTP (Phone)** | SQL ONLY | DB-only | One-time password sent via voice call |
| **Social Login (Google)** | YAML + SQL | Config > DB | OAuth 2.0 with Google Identity Platform |
| **Social Login (Microsoft)** | YAML + SQL | Config > DB | OAuth 2.0 with Microsoft Identity Platform |
| **Social Login (GitHub)** | YAML + SQL | Config > DB | OAuth 2.0 with GitHub |
| **Social Login (Facebook)** | YAML + SQL | Config > DB | OAuth 2.0 with Facebook |
| **Social Login (Apple)** | YAML + SQL | Config > DB | OAuth 2.0 with Sign in with Apple |
| **Social Login (LinkedIn)** | YAML + SQL | Config > DB | OAuth 2.0 with LinkedIn |
| **Social Login (Twitter/X)** | YAML + SQL | Config > DB | OAuth 2.0 with Twitter/X |
| **Social Login (Amazon)** | YAML + SQL | Config > DB | OAuth 2.0 with Amazon Login |
| **Social Login (Okta)** | YAML + SQL | Config > DB | OAuth 2.0 with Okta Identity Cloud |
| **SAML 2.0** | YAML + SQL | Config > DB | SAML 2.0 federated authentication |

---

## Tactical Implementation Guidance

**CRITICAL: This file provides tactical patterns ONLY. For complete specifications, see `.specify/memory/authn-authz-factors.md`**

### Middleware Stack Pattern

**Service-to-Service APIs** (`/service/**` prefix):

```go
serviceRouter.Use(
    ipAllowlistMiddleware,      // IP/CIDR allowlist
    rateLimitMiddleware,        // Per-IP rate limiting
    tokenValidationMiddleware,  // Validate Bearer/mTLS
    scopeAuthzMiddleware,       // Scope-based authorization
    requestLoggingMiddleware,   // Audit log
)
```

**Browser-to-Service APIs** (`/browser/**` prefix):

```go
browserRouter.Use(
    ipAllowlistMiddleware,      // IP/CIDR allowlist
    corsMiddleware,             // CORS policies
    csrfMiddleware,             // CSRF protection
    cspMiddleware,              // Content Security Policy headers
    rateLimitMiddleware,        // Per-IP rate limiting
    sessionValidationMiddleware,// Validate session cookie
    resourceAuthzMiddleware,    // Resource-level authorization
    requestLoggingMiddleware,   // Audit log
)
```

### Zero Trust Authorization Pattern

**MANDATORY: NO caching of authorization decisions**

```go
func AuthzMiddleware(ctx context.Context, req *http.Request) error {
    // Always fetch latest permissions from database (NO caching)
    perms, err := db.GetUserPermissions(ctx, userID)
    if err != nil {
        return fmt.Errorf("failed to fetch permissions: %w", err)
    }
    
    // Evaluate authorization on EVERY request
    if !perms.HasScope(requiredScope) {
        return ErrUnauthorized
    }
    
    // Track consent at (scope, resource) granularity
    if err := db.RecordConsent(ctx, userID, requiredScope, resourceID); err != nil {
        return fmt.Errorf("failed to record consent: %w", err)
    }
    
    return nil
}
```

### Realm Failover Pattern

**Priority List Pattern**:

```yaml
authentication:
  realm_failover:
    - realm: file
      type: yaml
      path: /etc/cryptoutil/credentials.yaml
    - realm: database
      type: postgresql
      dsn: postgres://user:pass@host/db
    - realm: database
      type: sqlite
      path: /var/lib/cryptoutil/credentials.db
```

**Failover Logic**:

```go
func AuthenticateWithFailover(ctx context.Context, creds Credentials) (*User, error) {
    for _, realm := range config.RealmFailover {
        user, err := realm.Authenticate(ctx, creds)
        if err == nil {
            return user, nil  // First success wins
        }
        log.Warn("realm %s failed, trying next", realm.Name)
    }
    return nil, ErrAuthenticationFailed
}
```

### MFA Step-Up Pattern

**30-Minute Re-Authentication**:

```go
func RequireStepUp(ctx context.Context, session *Session) error {
    // Check if step-up required for sensitive resource
    if time.Since(session.LastMFATime) > 30*time.Minute {
        return ErrMFAStepUpRequired  // Force re-authentication
    }
    return nil
}
```

### Testing Pattern

**Comprehensive Factor Testing**:

```go
func TestAllAuthenticationMethods(t *testing.T) {
    t.Parallel()
    
    // Test all 10 headless + 28 browser methods
    methods := []string{
        "basic_client_credentials", "bearer_api_token", "https_client_cert",
        // ... all 38 methods
    }
    
    for _, method := range methods {
        t.Run(method, func(t *testing.T) {
            t.Parallel()
            // Test authentication with this method
            user, err := AuthenticateWithMethod(ctx, method, testCreds)
            require.NoError(t, err)
            require.NotNil(t, user)
        })
    }
}
```

---

## Common Pitfalls - CRITICAL

### ❌ NEVER DO

- Cache authorization decisions (violates Zero Trust)
- Use Redis/Memcached for session storage (volatile, no ACID)
- Skip MFA step-up for "low-risk" operations (timing-based, NOT risk-based)
- Pre-configure user-specific data in YAML (SQL ONLY realm required)
- Assume realm availability (always implement failover)

### ✅ ALWAYS DO

- Re-evaluate authorization on EVERY request
- Use PostgreSQL/SQLite for session storage (ACID guarantees)
- Enforce MFA step-up every 30 minutes (time-based for consistency)
- Use YAML + SQL for static credentials, SQL ONLY for user-specific data
- Implement realm failover with priority list

---

## Key Takeaways

1. **Quick Reference**: See `.specify/memory/authn-authz-factors.md` for complete 10+28 method specifications
2. **Middleware Stacks**: Different chains for `/service/**` vs `/browser/**` paths
3. **Zero Trust**: NO caching of authorization decisions, always re-evaluate
4. **Realm Failover**: YAML → PostgreSQL → SQLite priority list
5. **MFA Step-Up**: 30-minute re-authentication for sensitive resources (time-based, NOT risk-based)
6. **Testing**: Test ALL 38 authentication methods for comprehensive coverage
