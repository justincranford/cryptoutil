---
description: "Authentication and authorization tactical implementation patterns"
applyTo: "**"
---
# Authentication and Authorization - Tactical Guidance

**Reference**: See `.specify/memory/authn-authz-factors.md` for complete specifications (10 headless + 28 browser authentication methods, storage realms, MFA combinations, authorization methods)

**This file contains ONLY tactical implementation patterns**

### Middleware Stack Pattern

**Service-to-Service APIs** (`/service/**` prefix):

```go
serviceRouter.Use(
    ipAllowlistMiddleware,      // IP/CIDR allowlist
    rateLimitMiddleware,        // Per-IP rate limiting
    tokenValidationMiddleware,  // Validate Bearer/mTLS
    scopeAuthzMiddleware,       // Scope-based authorization
    requestLoggingMiddleware,   // Audit log
)
```

**Browser-to-Service APIs** (`/browser/**` prefix):

```go
browserRouter.Use(
    ipAllowlistMiddleware,      // IP/CIDR allowlist
    corsMiddleware,             // CORS policies
    csrfMiddleware,             // CSRF protection
    cspMiddleware,              // Content Security Policy headers
    rateLimitMiddleware,        // Per-IP rate limiting
    sessionValidationMiddleware,// Validate session cookie
    resourceAuthzMiddleware,    // Resource-level authorization
    requestLoggingMiddleware,   // Audit log
)
```

### Zero Trust Authorization Pattern

**MANDATORY: NO caching of authorization decisions**

```go
func AuthzMiddleware(ctx context.Context, req *http.Request) error {
    // Always fetch latest permissions from database (NO caching)
    perms, err := db.GetUserPermissions(ctx, userID)
    if err != nil {
        return fmt.Errorf("failed to fetch permissions: %w", err)
    }

    // Evaluate authorization on EVERY request
    if !perms.HasScope(requiredScope) {
        return ErrUnauthorized
    }

    // Track consent at (scope, resource) granularity
    if err := db.RecordConsent(ctx, userID, requiredScope, resourceID); err != nil {
        return fmt.Errorf("failed to record consent: %w", err)
    }

    return nil
}
```

### Realm Failover Pattern

**Priority List Pattern**:

```yaml
authentication:
  realm_failover:
    - realm: file
      type: yaml
      path: /etc/cryptoutil/credentials.yaml
    - realm: database
      type: postgresql
      dsn: postgres://user:pass@host/db
    - realm: database
      type: sqlite
      path: /var/lib/cryptoutil/credentials.db
```

**Failover Logic**:

```go
func AuthenticateWithFailover(ctx context.Context, creds Credentials) (*User, error) {
    for _, realm := range config.RealmFailover {
        user, err := realm.Authenticate(ctx, creds)
        if err == nil {
            return user, nil  // First success wins
        }
        log.Warn("realm %s failed, trying next", realm.Name)
    }
    return nil, ErrAuthenticationFailed
}
```

### MFA Step-Up Pattern

**30-Minute Re-Authentication**:

```go
func RequireStepUp(ctx context.Context, session *Session) error {
    // Check if step-up required for sensitive resource
    if time.Since(session.LastMFATime) > 30*time.Minute {
        return ErrMFAStepUpRequired  // Force re-authentication
    }
    return nil
}
```

### Testing Pattern

**Comprehensive Factor Testing**:

```go
func TestAllAuthenticationMethods(t *testing.T) {
    t.Parallel()

    // Test all 10 headless + 28 browser methods
    methods := []string{
        "basic_client_credentials", "bearer_api_token", "https_client_cert",
        // ... all 38 methods
    }

    for _, method := range methods {
        t.Run(method, func(t *testing.T) {
            t.Parallel()
            // Test authentication with this method
            user, err := AuthenticateWithMethod(ctx, method, testCreds)
            require.NoError(t, err)
            require.NotNil(t, user)
        })
    }
}
```

---

## Common Pitfalls - CRITICAL

### ❌ NEVER DO

- Cache authorization decisions (violates Zero Trust)
- Use Redis/Memcached for session storage (volatile, no ACID)
- Skip MFA step-up for "low-risk" operations (timing-based, NOT risk-based)
- Pre-configure user-specific data in YAML (SQL ONLY realm required)
- Assume realm availability (always implement failover)

### ✅ ALWAYS DO

- Re-evaluate authorization on EVERY request
- Use PostgreSQL/SQLite for session storage (ACID guarantees)
- Enforce MFA step-up every 30 minutes (time-based for consistency)
- Use YAML + SQL for static credentials, SQL ONLY for user-specific data
- Implement realm failover with priority list

---

## Key Takeaways

1. **Quick Reference**: See `.specify/memory/authn-authz-factors.md` for complete 10+28 method specifications
2. **Middleware Stacks**: Different chains for `/service/**` vs `/browser/**` paths
3. **Zero Trust**: NO caching of authorization decisions, always re-evaluate
4. **Realm Failover**: YAML → PostgreSQL → SQLite priority list
5. **MFA Step-Up**: 30-minute re-authentication for sensitive resources (time-based, NOT risk-based)
6. **Testing**: Test ALL 38 authentication methods for comprehensive coverage
