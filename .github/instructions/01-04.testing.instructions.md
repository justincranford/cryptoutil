---
description: "Instructions for testing"
applyTo: "**"
---
# Testing Instructions

## CRITICAL: Test Concurrency - NEVER VIOLATE

ALWAYS use test concurrency

 - NEVER use `-p=1` for testing
 - ALWAYS use concurrent test execution
 - ALWAYS use `-shuffle` option for go test

**Why Concurrent Testing is Mandatory**:

1. **Fastest test execution**: Parallel tests = faster feedback loop
2. **Reveals production bugs**: Race conditions, deadlocks, data conflicts exposed
3. **Production validation**: If tests can't run concurrently, production code can't either
4. **Quality assurance**: Concurrent tests = higher confidence in code correctness and robustness

**Test Execution Commands**:

```bash
# CORRECT - Concurrent with shuffle
go test ./... -cover -shuffle=on

# CORRECT - Default concurrent execution
go test ./...

# WRONG - Sequential package execution (hides concurrency bugs!)
go test ./... -p=1  # ❌ NEVER DO THIS

# WRONG - Sequential test execution
go test ./... -parallel=1  # ❌ NEVER DO THIS
```

## Core Rules

- Target coverage: 95%+ production, 100%+ infrastructure (cicd), 100% utility code
- ALWAYS use table-driven tests with `t.Parallel()` - clear, compact, orthogonal data, reveals real concurrency bugs
- ALWAYS use testify `require` for assertions for fast fail
- NEVER os.Exit() in test code - return errors; only main() calls os.Exit()
- ALWAYS check and close response bodies: `defer require.NoError(t, resp.Body.Close())`
- ALWAYS check errors from helper functions
- Mutation testing: ≥80% gremlins score per package (mandatory)
- NEVER create temporary test files requiring deletion - create permanent tests only
- NEVER hardcode test values - use runtime-generated UUIDv7 or magic package constants

**Test Data Isolation Requirements**:

- ALWAYS use unique values: UUIDv7 for all test data (thread-safe, process-safe)
- ALWAYS use dynamic ports: port 0 pattern for all test servers for all products
- ALWAYS use TestMain for dependencies: Start once per package (PostgreSQL containers, service dependencies)
- ALWAYS use real dependencies: Test containers (PostgreSQL, Otel Collector Contrib, Grafana LGTM)
- ONLY use mocks only for: Hard-to-reach corner cases, external dependencies that can't be run as local containers (Cloud-only services)

**Test Values**:

**Option A**: Generate once, reuse: `id := googleUuid.NewV7()` then use `id` in test cases
**Option B**: Magic values from `internal/identity/magic` package
**NEVER**: Inline hardcoded UUIDs, strings, or calling `NewV7()` twice expecting same result

## Test File Organization

| Type | Suffix | Example |
|------|--------|---------|
| Unit | `_test.go` | `calc_test.go` |
| Bench | `_bench_test.go` | `calc_bench_test.go` |
| Fuzz | `_fuzz_test.go` | `calc_fuzz_test.go` |
| Property | `_property_test.go` | `calc_property_test.go` |
| Integration | `_integration_test.go` | `api_integration_test.go` |

## CRITICAL: Race Condition Prevention

- NEVER write to parent scope variables in parallel sub-tests
- NEVER use t.Parallel() with global state manipulation (os.Stdout, env vars)
- ALWAYS use inline assertions: `require.NoError(t, resp.Body.Close())`
- ALWAYS create fresh test data per test case (new sessions, UUIDs)
- ALWAYS protect shared maps/slices with sync.Mutex or sync.Map
- Detection: `go test -race -count=2` (requires CGO_ENABLED=1)
- NEVER compare database timestamps against `time.Now()` in tests with concurrent execution, async operations, or race condition testing

## Mutation Testing (Mandatory)

- Use [gremlins](https://github.com/go-gremlins/gremlins) for mutation testing
- Target: ≥80% mutation score per package
- Run: `gremlins unleash --tags=!integration` (excludes integration tests)
- Focus on business logic, parsers, validators, crypto operations
- Create baseline report and track improvements in docs/GREMLINS-TRACKING.md
- Always use Package-level parallelization: Run gremlins on packages concurrently using workflow matrix

**Recommended Configuration** (`.gremlins.yaml`):

```yaml
threshold:
  efficacy: 80  # Target: ≥80% test efficacy
  mutant-coverage: 70  # Target: ≥70% mutant coverage

workers: 4  # Parallel mutant execution
test-cpu: 2  # CPU per test run
timeout-coefficient: 2  # Timeout multiplier
```

## Benchmarking (Mandatory for Crypto)

- **ALWAYS create benchmarks for cryptographic operations** (happy and sad paths)
- File suffix: `_bench_test.go`
- Run: `go test -bench=. -benchmem ./pkg/crypto`
- Track performance regressions in CI/CD
- Examples: key generation, encryption/decryption, signing/verification, hashing

```go
func BenchmarkAESEncrypt(b *testing.B) {
    key := make([]byte, 32)
    plaintext := make([]byte, 1024)
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, _ = encrypt(key, plaintext)
    }
}
```

## Fuzz Testing (Mandatory)

- **ALWAYS create fuzz tests for parsers, validators, and input handlers**
- **CRITICAL: Fuzz tests MUST ONLY contain fuzz functions (Fuzz*), NOT unit/property/integration tests**
- Use `//go:build !fuzz` tag to exclude property tests from fuzz test runs
- Fuzz test names MUST be unique, NOT substrings of others (e.g., `FuzzHKDFAllVariants` not `FuzzHKDF`)
- ALWAYS run from project root: `go test -fuzz=FuzzXXX -fuzztime=15s ./path`
- Minimum fuzz time: 15 seconds per test
- Use unquoted names, PowerShell `;` for chaining

**File Organization**:

- `*_fuzz_test.go`: ONLY fuzz functions (FuzzX), no unit tests
- `*_test.go`: Unit, integration, table-driven tests

## Property-Based Testing (Mandatory)

- Use [gopter](https://github.com/leanovate/gopter) for property-based testing
- Focus on invariants and mathematical properties
- File suffix: `_property_test.go`
- Examples: encryption(decryption(x)) == x, sign(verify(x)) == x

```go
func TestEncryptionRoundTrip(t *testing.T) {
    properties := gopter.NewProperties(nil)
    properties.Property("encrypt then decrypt returns original", prop.ForAll(
        func(plaintext []byte) bool {
            ciphertext, _ := Encrypt(key, plaintext)
            result, _ := Decrypt(key, ciphertext)
            return bytes.Equal(plaintext, result)
        },
        gen.SliceOf(gen.UInt8()),
    ))
    properties.TestingRun(t)
}
```

## Test Execution

Place test results and coverage files in `./test-output/`: `go test ./pkg -coverprofile=test-output/coverage_pkg.out`

| Directory | Purpose | Examples |
|-----------|---------|----------|
| `./test-output/` | Test result outputs | Coverage files, test logs, Report outputs | Autoapprove logs, CI reports |
| `./testdata/` or `pkg/testdata/` | Test input fixtures | YAML configs, test files |

## Dynamic Port Allocation Pattern (Mandatory for Server Tests)

**ALWAYS use port 0 and extract actual assigned port** for server tests to enable concurrent test execution:

**Why**: Hard-coded ports cause port conflicts when tests run in parallel. Dynamic allocation ensures each test gets a unique port.

## cicd Utility Testing

- Commands organized as `internal/cmd/cicd/<snake_case>/` subdirectories
- EVERY command MUST exclude its own subdirectory (self-exclusion pattern)
- Define exclusion in `internal/common/magic/magic_cicd.go`
- Add self-exclusion test to verify pattern works
- Target 95%+ coverage per command subdirectory
