---
description: "Hash registry pepper/salt requirements, password hashing patterns, and hash service architecture"
applyTo: "**"
---
# Hash Registry and Password Hashing Instructions - MANDATORY

## Password Hashing Pattern - MANDATORY

```go
// ✅ CORRECT: PBKDF2-HMAC-SHA256 (FIPS-approved)
func HashPassword(password string) (string, error) {
    salt := make([]byte, 32)
    if _, err := io.ReadFull(rand.Reader, salt); err != nil {
        return "", err
    }

    iterations := 600000 // OWASP 2023 recommendation
    keyLen := 32
    hash := pbkdf2.Key([]byte(password), salt, iterations, keyLen, sha256.New)

    // Format: {version}:{algorithm}:{iterations}:base64(salt):base64(hash)
    return fmt.Sprintf("{1}:PBKDF2-HMAC-SHA256:%d:%s:%s",
        iterations,
        base64.StdEncoding.EncodeToString(salt),
        base64.StdEncoding.EncodeToString(hash)), nil
}

// ❌ WRONG: bcrypt (NOT FIPS-approved)
func HashPassword(password string) (string, error) {
    return bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
}
```

---

## Hash Service Architecture - MANDATORY

### Version-Based Policy Framework

**Version = Date-Based Policy Revision**: Each version represents a specific security policy snapshot based on standards from that year.

**Supported Versions**:

- **v1**: 2020 NIST guidelines
- **v2**: 2023 NIST guidelines
- **v3**: 2025 OWASP recommendations

**4 Registries × 3 Versions = 12 Configurations**:

- Password Registry: v1, v2, v3
- API Key Registry: v1, v2, v3
- Data Digest Registry: v1, v2, v3
- Signature Registry: v1, v2, v3

### Hash Output Format - MANDATORY

```
{version}:{algorithm}:{params}:base64_hash
```

**Examples**:

```
{1}:PBKDF2-HMAC-SHA256:rounds=600000:abcd1234...
{2}:PBKDF2-HMAC-SHA384:rounds=600000:efgh5678...
{3}:HKDF-SHA512:info=api-key,salt=xyz:ijkl9012...
```

### Version Update Pattern

**Trigger**: Manual operator decision (update config, restart service)

```yaml
# config.yaml
hash_service:
  password_registry:
    current_version: 2  # New passwords use v2
    # Old v1 passwords still verified correctly
```

**Migration Strategy**:

- Old hashes stay on original version (v1, v2, etc.)
- New hashes use current_version
- Gradual migration (no forced re-hash)
- Version prefix enables correct verification

### Backward Compatibility - MANDATORY

**Reject Unprefixed Hashes**: Force re-hash on next authentication

```go
// ✅ CORRECT: Verify with version prefix
func VerifyHash(input, storedHash string) (bool, error) {
    parts := strings.Split(storedHash, ":")
    if len(parts) < 4 {
        return false, ErrUnprefixedHash // Force re-hash
    }

    version := parts[0] // {1}, {2}, {3}
    algorithm := parts[1] // PBKDF2-HMAC-SHA256, etc.
    params := parts[2] // rounds=600000, etc.
    expectedHash := parts[3]

    // Use version-specific verification
    return verifyWithVersion(version, algorithm, params, input, expectedHash)
}

// ❌ WRONG: Accept unprefixed hashes
func VerifyHash(input, storedHash string) (bool, error) {
    // Ambiguous - which algorithm? which parameters?
    return bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(input))
}
```

---

## Hash Registry Pepper and Salt Requirements

## Pepper Requirements (ALL 4 Registries)

**MANDATORY: All 4 hash registries MUST use pepper for additional security layer**

**Pepper Storage** (NEVER store pepper in DB or source code):

- VALID OPTIONS IN ORDER OF PREFERENCE: 1. Docker Secret, 2. Configuration file, 3. Environment variable
- MUST be mutually exclusive from hashed values storage (pepper in secrets/config, hashes in DB)
- MUST be associated with hash version (different pepper per version)

**Pepper Rotation**:

- Pepper CANNOT be rotated silently (requires re-hash all records)
- Changing pepper REQUIRES version bump, even if no other hash parameters changed
- Example: v1 pepper compromised → bump to v2 with new pepper, re-hash all v1 records

**Additional Protections for LowEntropyDeterministicHashRegistry** (deterministic PII hashing):

- MANDATORY (prevents deterministic hashing oracle attacks):
  - Query rate limits (prevent brute-force enumeration)
  - Abuse detection (detect suspicious query patterns)
  - Audit logs (track all hash queries for forensics)
  - Strict access control (limit who can query hashes)
- RECOMMENDED: Apply same protections to all 4 registries for consistency

## Hash Registry Implementations

**LowEntropyDeterministicHashRegistry** (PII Lookup):

```go
hash = PBKDF2(input || pepper, fixedSalt, HIGH_iterations, 256)
// Format: {version}:base64(hash)
// Rationale: Deterministic for PII lookup, pepper prevents rainbow tables, high iteration cost mitigates brute force
```

**HighEntropyDeterministicHashRegistry** (Config Blob Hash):

```go
PRK = HKDF-Extract(fixedSalt, input || pepper)
hash = HKDF-Expand(PRK, "config-blob-hash", 256)
// Format: {version}:base64(hash)
// Rationale: High-entropy inputs, HKDF faster than PBKDF2, pepper provides domain separation
```

**LowEntropyRandomHashRegistry** (Password Hashing):

```go
hash = PBKDF2(password || pepper, randomSalt, OWASP_MIN_iterations, 256)
// Format: {version}:{algorithm}:{iterations}:base64(randomSalt):base64(hash)
// Rationale: Random salt prevents rainbow tables, pepper adds secret key layer, OWASP iterations
```

**HighEntropyRandomHashRegistry** (API Key Hashing):

```go
PRK = HKDF-Extract(randomSalt, apiKey || pepper)
hash = HKDF-Expand(PRK, "api-key-hash", 256)
// Format: {version}:{algorithm}:base64(randomSalt):base64(hash)
// Rationale: High-entropy inputs, HKDF faster than PBKDF2, random salt + pepper for defense in depth
```

## Cross-References

- FIPS compliance: See `02-08.cryptography.instructions.md`
- Algorithm agility: See `02-08.cryptography.instructions.md`
- Cryptographic libraries: See `02-08.cryptography.instructions.md`
