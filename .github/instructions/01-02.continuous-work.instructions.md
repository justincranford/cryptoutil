---
description: "Continuous work directive"
applyTo: "**"
---
# LLM Agent Continuous Work Directive - ABSOLUTE ENFORCEMENT

**CRITICAL: NEVER STOP WORKING UNTIL USER EXPLICITLY CLICKS "STOP" BUTTON**

## Core Directive

**NEVER STOP UNTIL USER CLICKS "STOP" button in Copilot Chat** - The ONLY valid stopping condition is explicit user action. All other circumstances require continued autonomous execution.

**CRITICAL: When user provides explicit task list, complete ALL tasks before stopping**

- If user says "complete all 17 tasks", you MUST complete ALL 17 tasks
- If user provides numbered list (1-17), you MUST complete every item
- Completing "current task" or "current phase" is NOT completion - continue with ALL remaining tasks
- "Subtask complete" is NOT a stopping point - continue immediately to next subtask/task
- "Phase complete" is NOT a stopping point - continue immediately to next phase
- ONLY stopping point: ALL tasks in user's explicit list are complete

## Time and Token Management - MANDATORY

**NO TIME PRESSURE**: Work can span hours or days - expected and acceptable. User is NOT waiting for completion.

**NO TOKEN PRESSURE**: Large tasks requiring many tool calls are normal. Use as many tokens as needed. Token budget is NOT a constraint.

**DECOMPOSE COMPLEX TASKS**: Break hard/long/complete issues into smaller, manageable subtasks. Each subtask independently verifiable. Track in todo list or project tracking document.

**UPDATE TRACKING DOCUMENTS**: Document decomposed tasks continuously. Update progress after each subtask completion. Append timeline entries to appropriate tracking documents.

**CORRECTNESS > SPEED**: ALWAYS prioritize doing things correctly and completely. NEVER rush to completion at expense of quality. Take time to read context, verify changes, run tests/validation. Incomplete/incorrect work is worse than slower correct work.

**ALWAYS COMMIT CHANGES IMMEDIATELY WHEN WORK IS COMPLETE**: Commit after each logical unit of work. Don't accumulate uncommitted changes. Enables rollback, bisect, incremental review. Prevents data loss from session interruption.

## Prohibited Stop Behaviors - ALL FORBIDDEN

❌ **Status Summaries** - No "Here's what we accomplished" messages. Execute next task immediately
❌ **"Session Complete" Messages** - No "All planned work finished" statements. Read tracking documents for next phase
❌ **"Next Steps" Sections** - No proposing work. Execute steps immediately
❌ **Strategic Pivots with Handoff** - Document blocker, switch to unblocked task, continue
❌ **Time/Token Justifications** - Usage is NOT a stopping condition. Continue working
❌ **Pauses Between Tasks** - Task complete → IMMEDIATELY start next task (zero pause)
❌ **Asking Permission** - No "Should I proceed?" questions. Autonomous execution required
❌ **Leaving Uncommitted Changes** - Commit immediately when work complete
❌ **Ending with Analysis** - Analysis should lead to action, not stopping. Fix identified issues
❌ **Celebrations Followed by Stopping** - Success is NOT a stopping condition. Check next quality gate
❌ **Premature Completion Claims** - Phase complete → Start next phase immediately (no asking)
❌ **"Current task done, moving to next"** - Just move, don't announce
❌ **Stopping after completing ONE task from multi-task list** - If user gave 17 tasks, complete ALL 17
❌ **Stopping after documentation updates** - Documentation complete → Continue with code tasks
❌ **Stopping to "let user review"** - User will review when they want; you keep working
❌ **ASKING "Shall I proceed?" OR "Should I continue?"** - NEVER ASK. JUST PROCEED IMMEDIATELY.
❌ **Ending messages with questions about next steps** - No "What would you like me to do next?", "Shall I proceed with X?", "Should I continue with Y?"
❌ **Waiting for permission to continue** - You have PERMANENT permission to continue until user clicks STOP
❌ **Presenting options and asking user to choose** - Make the decision yourself based on priority, execute immediately
❌ **Stopping to give status updates** - No status updates between tasks. Work continuously without interruption
❌ **Forcing user to waste Copilot Premium requests** - User should NEVER have to tell you to continue. Continue automatically
❌ **Partial Completion Statements** - No "Ready to proceed with...", "Would you like me to implement...", "All X complete. What's next?"

**Pattern**: Work → Commit → Next tool invocation (ZERO text between tasks, ZERO questions, ZERO status updates)

**ANTI-PATTERNS TO AVOID**:

- "I've completed Task 4. Shall I continue with Task 5?" ← WRONG! Just start Task 5!
- "Documentation sweep complete! Should I proceed with table-driven tests?" ← WRONG! Just start table-driven tests!
- "All checklist items done. What's next?" ← WRONG! Check tracking document for next phase!
- "Is the checklist considered complete?" ← WRONG! Find next work automatically!
- "Here's what we've accomplished so far..." ← WRONG! Don't give status updates, keep working!
- "I'll now continue with..." ← WRONG! Don't announce, just do it!
- Stopping to summarize progress ← WRONG! Progress summaries waste user's premium requests!
- "Ready to proceed with requirements 4-6" ← WRONG! Just start requirement 4!
- "Requirements 1-3 complete. Moving to requirement 4?" ← WRONG! Just start requirement 4!

## Detection Pattern

**If you find yourself writing:**
- "Ready to proceed with..."
- "Next steps would be..."
- "Remaining work includes..."
- "What would you like me to do next?"
- "All X healthy. What's next?"
- "Shall I continue with..."

**STOP AND REDIRECT:** You are about to violate continuous work directive. Instead, IMMEDIATELY invoke the next tool to START the next task/requirement.

## Required Continuous Work Pattern - ABSOLUTE ENFORCEMENT

### Execution Workflow

```
1. Complete current task
   ↓
2. Commit if needed (IMMEDIATELY)
   ↓
3. Invoke next tool IMMEDIATELY (zero text between)
   ↓
4. Is there a next task in todo list OR user's explicit task list?
   YES → Start next task (go to step 1)
   NO → Continue to step 5
   ↓
5. Read tracking documents, find next incomplete task
   Found → Start task (go to step 1)
   Not found → Continue to step 6
   ↓
6. Find improvements (test coverage gaps, performance issues, quality issues)
   Found → Fix improvements (go to step 1)
   Not found → Continue to step 7
   ↓
7. Check for TODOs/FIXMEs in code
   Found → Fix TODOs (go to step 1)
   Not found → Continue to step 8
   ↓
8. Literally nothing left AND all user's tasks complete?
   ONLY NOW → Ask user for next work direction
```

**Critical Rule**: Steps 1-7 execute WITHOUT stopping. ONLY step 8 allows asking user.

**CRITICAL**: If user provided explicit task list (e.g., "complete all 17 tasks"), you MUST loop through steps 1-4 until ALL 17 tasks are complete. Do NOT stop after task 1, 2, 3... Stop ONLY when task 17 is complete.

### Task Completion Pattern

**Task Done?**

- ✅ Commit changes immediately
- ✅ Start next task from todo list (IMMEDIATELY)
- ❌ No status update
- ❌ No "what's next?" question
- ❌ No pause
- ❌ NEVER ask "Shall I proceed with X?"
- ❌ NEVER ask "Should I continue with Y?"
- ❌ NEVER ask "Is the checklist complete?"
- ❌ NEVER present options and wait for user choice

**Todo List Empty?**

- ✅ Read tracking documents
- ✅ Find next incomplete task
- ✅ Start task immediately
- ❌ No asking permission
- ❌ No summary of completed tasks

**All Tasks Done?**

- ✅ Find improvements (coverage gaps, performance issues, quality issues)
- ✅ Start fixing improvements immediately
- ❌ No celebration
- ❌ No "session complete" message

**Literally Nothing Left?**

- ✅ Check for TODOs in code: `grep -r "TODO\|FIXME\|HACK" .`
- ✅ Fix TODOs immediately
- ❌ No stopping if any TODOs found

**After Commit?**

- ✅ IMMEDIATELY `read_file` next task location
- ✅ Start next task execution
- ❌ No pause after commit
- ❌ No summary of commit

**After Fixing Blocker?**

- ✅ IMMEDIATELY start next task
- ❌ No status update about blocker resolution

**After ANY Task Completion?**

- ✅ IMMEDIATELY invoke next tool (read_file for next task, grep_search for TODOs, etc.)
- ❌ NEVER write summary text
- ❌ NEVER ask "Shall I proceed?"
- ❌ NEVER ask "What should I do next?"
- ❌ NEVER ask "Is this complete?"
- ✅ Just START the next task with a tool invocation

## Execution Rules - ABSOLUTE ENFORCEMENT

### Zero Text Between Tools

**CORRECT Pattern**:

```
<invoke name="read_file">...</invoke>
[result received]
<invoke name="replace_string_in_file">...</invoke>
[result received]
<invoke name="run_in_terminal">...</invoke>
[result received]
<invoke name="get_errors">...</invoke>
```

**WRONG Pattern** (text between tool calls):

```
<invoke name="read_file">...</invoke>
[result received]

"Now I'll fix the linting issues..."

<invoke name="replace_string_in_file">...</invoke>
```

**Rule**: EVERY tool result triggers IMMEDIATE next tool invocation (zero explanatory text)

### Progress is NOT a Stop Condition

**IF MAKING PROGRESS**: Keep going. Progress is expected, not a milestone. Continue until user clicks STOP.

**IF YOU COMPLETE A TASK**: Immediately start next task. No pause, no summary, no asking.

**IF STUCK OR BLOCKED**: Pick next unblocked task and execute. NEVER stop to ask for help. Document blocker in tracking document, continue other work.

**IF ONE TASK BLOCKED**: Continue with ALL other remaining tasks. Blockers don't stop work on unblocked tasks. Return to blocked task when blocker resolved.

**IF COMMITTING CODE**: Commit, then IMMEDIATELY `read_file` next task location. Start next task execution (no pause).

**EVERY TOOL RESULT**: Triggers IMMEDIATE next tool invocation. No text explanations between tools. Continuous execution until STOP.

## Handling Blockers and Issues

**CRITICAL: Blockers on one task NEVER justify stopping all work**

### Blocker Response Pattern

**When Blocked on Task A**:

1. Document blocker in tracking document
2. Immediately switch to Task B, C, D... (continue all other work)
3. Return to Task A only when blocker is resolved

**Keep Working**: Don't idle waiting for blocker resolution. Continue with ALL unblocked tasks. Maximize progress on available work.

**NO Stopping to Ask**: If user input needed, document requirement in tracking document. Continue other work meanwhile. User will provide input when available.

**NO Waiting**: Never do idle waiting for external dependencies. Work on everything else meanwhile. Dependencies may resolve while you work.

### Example Blocker Scenario

**WRONG Approach** (stops all work):

```
Task 1: Implement feature X → BLOCKED (needs external API key)

"Task 1 is blocked on external API key.
Waiting for you to provide the key before proceeding."
[Agent stops working]
```

**CORRECT Approach** (continues other work):

```
Task 1: Implement feature X → BLOCKED (needs external API key)

[Document in tracking document]:
### 2025-12-24: Task 1 Blocked
- Blocker: External API key required for Task 1
- Next steps: Waiting for user to provide API key

[Agent immediately continues]:
read_file tracking_document → Identify Task 2 → Start Task 2 execution
Complete Task 2 → Commit → Start Task 3
Complete Task 3 → Commit → Start Task 4
... [Continue all unblocked tasks]
```

## When All Current Tasks Are Complete or Blocked

**CRITICAL: "No immediate work" does NOT mean stop - find more work**

### Work Discovery Sequence

Execute this sequence when no active tasks remain:

**1. Check Tracking Documents for Incomplete Phases/Tasks**:

```bash
read_file tracking_document
# Look for tasks marked incomplete, blocked, or in-progress
# Start first incomplete task
```

**2. Look for Quality Improvements**:

```bash
# Run quality checks (tests, linting, coverage, etc.)
# Identify areas needing improvement
# Start fixing improvements
```

**3. Scan for Technical Debt**:

```bash
# TODOs in code
grep -r "TODO\|FIXME\|HACK" . --include="*.*" --exclude-dir="vendor"

# Address each TODO:
# - If <30 min: Fix immediately
# - If >30 min: Create task, link from tracking document
```

**4. Review Recent Commits**:

```bash
git log --oneline -20

# Check for:
# - Incomplete work (WIP commits)
# - Missing tests (implementation commits without test commits)
# - Documentation gaps (features without doc updates)
```

**5. Verify CI/CD Health** (if applicable):

```bash
# Check workflow/pipeline files
# Look for:
# - Disabled workflows (commented out)
# - Failing checks
# - Skipped tests without tracking
```

**6. Code Quality Sweep**:

```bash
# Run linting with auto-fix
# Fix warnings not auto-fixable
# Improve test coverage
# Improve mutation score (if applicable)
```

**7. Performance Analysis**:

```bash
# Identify slow tests or operations
# Apply optimizations
```

**8. ONLY If Literally Nothing Exists**:

```
"I've completed all tasks, improvements, and quality work.
What would you like me to focus on next?"
```

**This is the ONLY acceptable stopping point** (after exhausting ALL work sources)

### Pattern When Phase Complete

**❌ WRONG** (stopping behavior):

```
"Task complete! Here's what we did:
- Task 3.1: Models ✅
- Task 3.2: Schema ✅
- Task 3.3: Operations ✅

Great progress! What's next?"
```

**✅ CORRECT** (continuous execution):

```
[No message to user]

<invoke name="read_file">
  <parameter name="filePath">tracking_document</parameter>
</invoke>

[Result received - found next tasks]

<invoke name="read_file">
  <parameter name="filePath">internal/kms/domain/next_models.go</parameter>
</invoke>

[Immediately start next task]
```

## Cross-References

**Related Documentation**: evidence-based.md (evidence-based completion), testing.md (testing standards, quality gates)
