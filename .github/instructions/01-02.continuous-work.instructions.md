# LLM Agent Continuous Work Directive - ABSOLUTE ENFORCEMENT

**This file contains ONLY tactical implementation patterns**

**CRITICAL: NEVER STOP WORKING UNTIL USER EXPLICITLY CLICKS "STOP" button in Copilot Chat**

## Time and Token Management

- **NO TIME PRESSURE**: Work can span hours or days - this is expected and acceptable
- **NO TOKEN PRESSURE**: Large tasks requiring many tool calls are normal - use as many tokens as needed
- **DECOMPOSE COMPLEX TASKS**: Break hard/long/complete issues into smaller, manageable subtasks
- **DOCUMENT TASKS AND PROGRESS**: Document decomposed tasks and progress continuously
- **CORRECTNESS > SPEED**: Always prioritize doing things correctly and completely over rushing
- **ALWAYS COMMIT CHANGES IMMEDIATELY WHEN WORK IS COMPLETE**

## Prohibited Stop Behaviors (ALL FORBIDDEN)

- ❌ Status summaries, "session complete" messages, task lists at end
- ❌ "Next steps" sections, strategic pivots, time/token justifications
- ❌ Pauses between tasks, asking permission, waiting for confirmation
- ❌ Leaving uncommitted changes, ending with analysis/documentation
- ❌ Celebrations followed by stopping, premature completion claims

## Required Continuous Work Pattern

1. Complete current task → Immediately invoke next tool
2. Task done? → Start next task from todo list
3. Todo list empty? → Read task documentation, find next incomplete task, start it
4. All tasks done? → Find improvements (coverage gaps, test speed, linting, gremlins)
5. Literally nothing left? → Check for TODOs in code, fix them
6. After commit? → IMMEDIATELY start next task
7. After fixing blocker? → IMMEDIATELY start next task

**The ONLY valid stopping condition: User types "STOP" or "PAUSE"**

## Execution Rules - ABSOLUTE ENFORCEMENT

- Execute tool → Execute next tool → Repeat (ZERO text between tools)
- NO skipping tasks, NO deferring tasks, NO status updates mid-session
- **IF MAKING PROGRESS**: Keep going - progress is not a stop condition
- **IF YOU COMPLETE A TASK**: Immediately start next task
- **IF STUCK OR BLOCKED**: Pick next unblocked task and execute - NEVER stop to ask
- **IF ONE TASK BLOCKED**: Continue with all other remaining tasks - blockers don't stop work
- **IF COMMITTING CODE**: Commit then IMMEDIATELY read_file next task location
- **EVERY TOOL RESULT**: Triggers IMMEDIATE next tool invocation

## Handling Blockers and Issues

**CRITICAL: Blockers on one task NEVER justify stopping all work**

- **When blocked on Task A**: Immediately switch to Task B, C, D... (continue all other work)
- **Keep working**: Return to blocked task only when blocker is resolved
- **NO stopping to ask**: If user input needed, document requirement and continue other work
- **NO waiting**: Never do idle waiting for external dependencies - work on everything else meanwhile

## When All Current Tasks Are Complete or Blocked

**CRITICAL: "No immediate work" does NOT mean stop - find more work**

1. Check latest plan for incomplete phases
2. Check latest tasks for incomplete tasks
3. Look for quality improvements (coverage gaps, test speed, linting issues, TODOs in code)
4. Scan for technical debt (grep for TODO/FIXME/HACK comments, address them)
5. Review recent commits (check for incomplete work, missing tests, documentation gaps)
6. Verify CI/CD health (check workflow files, fix any disabled/failing checks)
7. Code quality sweep (run golangci-lint, fix warnings, improve test coverage & gremlins)
8. Performance analysis (identify slow tests >15s, apply probabilistic execution)
9. Mutation testing (run gremlins on packages below 98% mutation score)
10. ONLY if literally nothing exists: Ask user for next work direction

**Pattern when phase complete**:

- ❌ WRONG: "Phase 3 complete! Here's what we did..." (STOPPING)
- ✅ CORRECT: `read_file task_documentation` → find Phase 4/5/6 tasks → immediately start first task
