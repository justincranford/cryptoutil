---
description: "Instructions for Go project structure, architecture, and coding standards"
applyTo: "**"
---
# Go Project Structure, Architecture & Standards

## Go Project Structure

Follow the [Standard Go Project Layout](https://github.com/golang-standards/project-layout) patterns:

**Go Directories:**
- `/cmd` - Main applications for this project. Keep `main` functions minimal, importing from `/internal` and `/pkg`
- `/internal` - Private application and library code enforced by Go compiler. Use `/internal/app` for application code, `/internal/pkg` for shared internal code
- `/pkg` - Library code safe for external use. Optional pattern for explicitly public APIs
- `/vendor` - Application dependencies (use `go mod vendor` when needed)

**Service Application Directories:**
- `/api` - OpenAPI/Swagger specs, JSON schema files, protocol definitions

**Common Application Directories:**
- `/configs` - Configuration file templates or default configs
- `/scripts` - Build, install, analysis, and other automation scripts
- `/deployments` - IaaS, PaaS, container orchestration configs (docker-compose, kubernetes/helm, terraform)
- `/test` - Additional external test apps and test data

**Other Directories:**
- `/docs` - Design and user documents (in addition to godoc)
- `/tools` - Supporting tools for this project

**Avoid:**
- `/src` - Don't use project-level `/src` directory (Java pattern, not Go)
- Deep nesting - Keep structure simple and flat when possible

**Key Principles:**
- This is NOT an official Go standard, but a community pattern
- Use what you need, delete what you don't
- Small projects can start simple (single `main.go`)
- Scale structure as project grows
- See [Organizing a Go module](https://go.dev/doc/modules/layout) for official guidance

## Application Architecture

- Use layered arch: main → app → business logic → repositories
- Config: YAML files & CLI only (no env vars for configuration; use Docker/Kubernetes secrets for sensitive data)
- Dependency injection with context propagation
- Structured config with validation/defaults
- Lifecycle: graceful startup/shutdown, resource cleanup
- Service layer: clear separation of concerns
- Error propagation through layers
- Factory pattern for service init with error handling
- Support local/dev, Docker, prod configs
- Atomic ops for critical state
- Timeout/retry for external deps
- Validate config before startup
- Hot-reload config if needed

## Import Alias Conventions

### CRITICAL: Synchronization Requirement
**The import aliases listed below MUST be kept in sync with the `importas` section in `.golangci.yml`.**
- When adding/removing/changing aliases in `.golangci.yml`, update this instructions section
- When updating this section, verify changes are reflected in `.golangci.yml`
- The linter enforces these aliases; mismatches will cause build failures

### cryptoutil/** Packages (REQUIRED)
**ALL cryptoutil imports MUST use camelCase aliases starting with "cryptoutil" prefix.**

**API Packages (OpenAPI generated code):**
- `cryptoutilOpenapiClient "cryptoutil/api/client"`
- `cryptoutilOpenapiModel "cryptoutil/api/model"`
- `cryptoutilOpenapiServer "cryptoutil/api/server"`

**Client and Command Packages:**
- `cryptoutilClient "cryptoutil/internal/client"`
- `cryptoutilCmd "cryptoutil/internal/cmd"`
- `cryptoutilCmdCryptoutil "cryptoutil/internal/cmd/cryptoutil"`
- `cryptoutilWorkflow "cryptoutil/internal/cmd/workflow"`

**Test Utilities:**
- `cryptoutilE2E "cryptoutil/internal/test/e2e"`

**Common Utilities:**
- `cryptoutilAppErr "cryptoutil/internal/common/apperr"`
- `cryptoutilConfig "cryptoutil/internal/common/config"`
- `cryptoutilContainer "cryptoutil/internal/common/container"`
- `cryptoutilMagic "cryptoutil/internal/common/magic"`
- `cryptoutilPool "cryptoutil/internal/common/pool"`
- `cryptoutilTelemetry "cryptoutil/internal/common/telemetry"`
- `cryptoutilUtil "cryptoutil/internal/common/util"`
- `cryptoutilCombinations "cryptoutil/internal/common/util/combinations"`
- `cryptoutilDateTime "cryptoutil/internal/common/util/datetime"`
- `cryptoutilNetwork "cryptoutil/internal/common/util/network"`
- `cryptoutilSysinfo "cryptoutil/internal/common/util/sysinfo"`

**Crypto Operations:**
- `cryptoutilAsn1 "cryptoutil/internal/common/crypto/asn1"`
- `cryptoutilCertificate "cryptoutil/internal/common/crypto/certificate"`
- `cryptoutilDigests "cryptoutil/internal/common/crypto/digests"`
- `cryptoutilJose "cryptoutil/internal/common/crypto/jose"`
- `cryptoutilKeyGen "cryptoutil/internal/common/crypto/keygen"`

**Server Application:**
- `cryptoutilServerApplication "cryptoutil/internal/server/application"`
- `cryptoutilBusinessLogic "cryptoutil/internal/server/businesslogic"`
- `cryptoutilOpenapiHandler "cryptoutil/internal/server/handler"`

**Server Barrier Services:**
- `cryptoutilBarrierService "cryptoutil/internal/server/barrier"`
- `cryptoutilContentKeysService "cryptoutil/internal/server/barrier/contentkeysservice"`
- `cryptoutilIntermediateKeysService "cryptoutil/internal/server/barrier/intermediatekeysservice"`
- `cryptoutilRootKeysService "cryptoutil/internal/server/barrier/rootkeysservice"`
- `cryptoutilUnsealKeysService "cryptoutil/internal/server/barrier/unsealkeysservice"`

**Server Repository:**
- `cryptoutilOrmRepository "cryptoutil/internal/server/repository/orm"`
- `cryptoutilSQLRepository "cryptoutil/internal/server/repository/sqlrepository"`

### Third-Party Packages

**JOSE (JSON Web Encryption/Signatures):**
- `joseJwa "github.com/lestrrat-go/jwx/v3/jwa"`
- `joseJwe "github.com/lestrrat-go/jwx/v3/jwe"`
- `joseJwk "github.com/lestrrat-go/jwx/v3/jwk"`
- `joseJws "github.com/lestrrat-go/jwx/v3/jws"`

**Other Libraries:**
- `googleUuid "github.com/google/uuid"` - ALWAYS use `uuid.NewV7()` for time-ordered UUIDs
- `fiber "github.com/gofiber/fiber/v2"`
- `testify "github.com/stretchr/testify"`

**Standard Library:**
- `json "encoding/json"`
- `xml "encoding/xml"`
- `http "net/http"`

**Crypto Standard Library:**
- `aes "crypto/aes"`
- `ecdsa "crypto/ecdsa"`
- `hmac "crypto/hmac"`
- `rsa "crypto/rsa"`
- `sha256 "crypto/sha256"`
- `sha512 "crypto/sha512"`
- `crand "crypto/rand"` - Use for cryptographic randomness (NOT math/rand)

### Crypto Acronym Exceptions
**Use ALL CAPS for these terms anywhere in identifiers:**
- RSA, EC, ECDSA, ECDH, HMAC, AES, JWA, JWK, JWS, JWE, ED25519, ED448, PKCS8, PKIX, CSR, PEM, DER

**Examples:** `PEMTypeRSAPrivateKey`, `GenerateECDSAKeyPair`, `ValidateJWKHeaders`

## Dependency Management

### Updates
- Check updates: `go list -u -m all | grep '\[.*\]$'`
- Update incrementally: `go get <package>@<version>`
- Clean up: `go mod tidy`
- Test after each: `go test ./... --count=1 -timeout=20m`

### Version Synchronization
- **Synchronize ecosystem packages**: Update related packages to latest compatible version
- **Example**: OpenTelemetry packages (`go.opentelemetry.io/*`), GORM ecosystem
- **Ignore unrelated transients**: Let Go's MVS handle unrelated dependencies
- Use `go mod why <package>` to understand indirect dependencies

### Best Practices
- Update direct dependencies first, then ecosystem-related indirect ones
- Keep related packages at consistent versions
- Review changelog/release notes for breaking changes
- Prefer stable releases; avoid pre-releases
- Update in small batches to isolate issues

## Formatting Standards

- **Encoding**: UTF-8 without BOM, single newline at EOF, no trailing whitespace
- **Indentation**: 4 spaces (Go), 2 spaces (YAML, JSON, Markdown, Dockerfile)
- **Types**: Use `any` not `interface{}`
- **Tool**: gofumpt (strict superset of gofmt)
- **Auto-formatting**: Use `golangci-lint run --fix` (runs gofumpt automatically)

## Conditional Statement Chaining

### Pattern: Chain Mutually Exclusive Conditions

**Prefer chained if/else if/else:**
```go
if ctx == nil {
    return nil, fmt.Errorf("context cannot be nil")
} else if logger == nil {
    return nil, fmt.Errorf("logger cannot be nil")
} else if description == "" {
    return nil, fmt.Errorf("description cannot be empty")
}
```

**Avoid separate if statements:**
```go
if ctx == nil {
    return nil, fmt.Errorf("context cannot be nil")
}

if logger == nil {
    return nil, fmt.Errorf("logger cannot be nil")
}
```

### When NOT to Chain
- Independent conditions (not mutually exclusive)
- Error accumulation patterns
- Cases with early returns
