---
description: "Hash registry pepper/salt requirements, password hashing patterns, and hash service architecture"
applyTo: "**"
---
# Hash Registry and Password Hashing Instructions - MANDATORY

Use PBKDF2 for low-entropy inputs like PII (e.g. username, email, IP address) and secrets (e.g. passwords).

Use HKDF for high-entropy inputs like blobs (e.g. secret configuration) and secrets (e.g. API keys).

Low-entropy is anything below 128-bits entropy. High-entropy is anything with 128-bits entropy or higher.

In practical terms, 128-bits entropy means the input MUST have a 256-bit (or higher) search space to brute force it; entropy bit count is half the search space.

## Pepper

All inputs must be peppered before input into hash functions. See `https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#peppering` for details.

## Hash Service Architecture - MANDATORY

### Version-Based Policy Framework

**Versions are tuple of 5 things: Four Registries based on NIST || OWASP Policy Revisions, and a Unique Pepper**: Each version represents a specific security policy snapshot.

**Supported Versions**:

- **v1**: 2020 NIST guidelines
- **v2**: 2023 NIST guidelines
- **v3**: 2025 OWASP recommendations

**Supports Registries**:

- LowEntropyDeterministicHashRegistry
- LowEntropyRandomHashRegistry
- HighEntropyDeterministicHashRegistry
- HighEntropyRandomHashRegistry

**New Version Requirements**:

If a new policy is published by NIST || OWASP, the version must be incremented to differentiate it from previous versions.

If a new pepper is needed (e.g. 1 year rotation policy, old pepper compromised), the version must be incremented to differentiate it from previous pepper, even if NIST || OWASP policy remains unchanged.

### Hash Output Format - MANDATORY

```
{version}:{algorithm}:{iterations}:base64(randomSalt):base64(hash)
```

**Examples**:

```
{1}:PBKDF2-HMAC-SHA256:rounds=600000:abcd1234...
{2}:PBKDF2-HMAC-SHA384:rounds=600000:efgh5678...
{3}:HKDF-SHA512:info=api-key,salt=xyz:ijkl9012...
```

### Version Update Pattern

**Trigger**: Manual operator decision (update config, restart service)

```yaml
# config.yaml
hash_service:
  password_registry:
    current_version: 4  # New passwords use v4
    # Old v3, v2, v1 passwords still verified correctly; rehashed with v4 and updated in DB
```

**Migration Strategy**:

- Old hashes stay on original version (v1, v2, etc.)
- New hashes use current_version
- Gradual migration (no forced re-hash); rehash next time the cleartext value is presented (e.g. username/password authentication)
- Version prefix enables correct verification

### Backward Compatibility - MANDATORY

**Reject Unprefixed Hashes**: Force re-hash on next authentication

## Salt Requirements (ALL 4 Registries)

OWASP recommends to always assume salt is public. Encoding deterministic salt in hash parameters is OK, because a secret pepper protects the input from brute force attack vectors.

## Pepper Requirements (ALL 4 Registries)

**MANDATORY: All 4 hash registries MUST use pepper for additional security layer**

**Pepper Storage** (NEVER store pepper in DB or source code):

- VALID OPTIONS IN ORDER OF PREFERENCE: 1. Docker/Kubernetes Secret, 2. Configuration file, 3. Environment variable
- MUST be mutually exclusive from hashed values storage (pepper in secrets/config, hashes in DB)
- MUST be associated with hash version (different pepper per version, even if NIST || OWASP policy remains unchanged)

**Pepper Rotation**:

- Pepper CANNOT be rotated silently (requires re-hash all records)
- Changing pepper REQUIRES version bump, even if no other hash parameters changed
- Example: v3 pepper compromised â†’ bump to v4 with new pepper, re-hash all v3 records

**Additional Protections for LowEntropyDeterministicHashRegistry** (deterministic PII hashing):

- MANDATORY (prevents oracle attacks on deterministic hashing):
  - Query rate limits (prevent brute-force enumeration)
  - Abuse detection (detect suspicious query patterns)
  - Audit logs (track all hash queries for forensics)
  - Strict access control (limit who can query hashes)
- RECOMMENDED: Apply same protections to all 4 registries for consistency

## Hash Registry Implementations

**LowEntropyDeterministicHashRegistry** (PII Lookup):

```go
hash = PBKDF2(input || pepper, fixedSalt, HIGH_iterations, 256)
```

**HighEntropyDeterministicHashRegistry** (Config Blob Hash):

```go
PRK = HKDF-Extract(fixedSalt, input || pepper)
hash = HKDF-Expand(PRK, "config-blob-hash", 256)
```

**LowEntropyRandomHashRegistry** (Password Hashing):

```go
hash = PBKDF2(password || pepper, randomSalt, OWASP_MIN_iterations, 256)
```

**HighEntropyRandomHashRegistry** (API Key Hashing):

```go
PRK = HKDF-Extract(randomSalt, apiKey || pepper)
hash = HKDF-Expand(PRK, "api-key-hash", 256)
```
