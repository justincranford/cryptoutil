---
description: "Instructions for database operations and ORM patterns"
applyTo: "**"
---
# Database and ORM Patterns - Tactical Guidance

**Reference**: See `.specify/memory/database.md` for complete specifications (GORM patterns, cross-DB compatibility, error mapping, migrations)

**This file contains ONLY tactical implementation patterns**

## Quick Reference: Cross-DB Compatibility

| Feature | PostgreSQL | SQLite | Solution |
|---------|-----------|---------|----------|
| UUID Type | uuid, text | text only | Use `type:text` |
| Nullable UUIDs | *UUID, NullableUUID | NullableUUID only | Use NullableUUID |
| JSON Arrays | json, text | text only | Use `serializer:json` |
| Read-Only Tx | Supported | NOT supported | Use standard tx |

## Core Patterns

**UUID Fields** (cross-DB compatible):
```go
ID googleUuid.UUID `gorm:"type:text;primaryKey"`  // ✅ Works everywhere
```

**Nullable UUIDs** (avoid pointer UUIDs):
```go
ClientProfileID NullableUUID `gorm:"type:text;index"`  // ✅ Custom type
```

**JSON Arrays/Objects** (cross-DB compatible):
```go
AllowedScopes []string `gorm:"serializer:json"`  // ✅ Works everywhere
```

**Database DSN**:
```go
dsn := "postgres://user:pass@localhost:5432/dbname?sslmode=disable"
```

## Cross-Database Compatibility - CRITICAL

### UUID Type Handling

**SQLite does not support native UUID type - ALWAYS use TEXT:**

```go
// CORRECT for cross-DB compatibility (PostgreSQL and SQLite)
ID googleUuid.UUID `gorm:"type:text;primaryKey"`

// WRONG - breaks SQLite
ID googleUuid.UUID `gorm:"type:uuid;primaryKey"`
```

**Why:** SQLite lacks native UUID type. PostgreSQL supports both UUID and TEXT for UUIDs, so TEXT works everywhere.

### Nullable UUID Foreign Keys

**Use NullableUUID type for optional UUID foreign keys:**

```go
// Domain model (internal/identity/domain/nullable_uuid.go)
type NullableUUID struct {
    UUID  googleUuid.UUID
    Valid bool
}

// Implements sql.Scanner and driver.Valuer for proper NULL handling

// Usage in domain models
ClientProfileID NullableUUID `gorm:"type:text;index"`

// WRONG - pointer UUIDs cause "row value misused" errors in SQLite
ClientProfileID *googleUuid.UUID `gorm:"type:text;index"`
```

**Why:** Pointer UUIDs (`*googleUuid.UUID`) don't serialize correctly to TEXT columns in SQLite with GORM, causing "SQL logic error: row value misused" errors.

### JSON Array/Object Fields

**ALWAYS use `serializer:json` instead of `type:json` for cross-DB compatibility:**

```go
// CORRECT for cross-DB compatibility
AllowedScopes []string `gorm:"serializer:json" json:"allowed_scopes"`
MFAChain      []string `gorm:"serializer:json" json:"mfa_chain"`

// WRONG - breaks SQLite (no native JSON type)
AllowedScopes []string `gorm:"type:json" json:"allowed_scopes"`
```

**Why:**

- SQLite lacks native JSON type (stores as TEXT)
- PostgreSQL has native JSON/JSONB types
- `serializer:json` tells GORM to handle JSON encoding/decoding for TEXT columns
- `type:json` tells GORM to use native JSON type (fails on SQLite with "row value misused")

### SQL Migration Schema Consistency

**Ensure GORM annotations match SQL migration column types:**

```sql
-- SQLite migration (0001_init.up.sql)
CREATE TABLE clients (
    id TEXT PRIMARY KEY,
    allowed_scopes TEXT DEFAULT '[]',  -- JSON array as TEXT
    client_profile_id TEXT              -- Nullable UUID as TEXT
);
```

```go
// Domain model MUST match migration types
type Client struct {
    ID              googleUuid.UUID `gorm:"type:text;primaryKey"`
    AllowedScopes   []string        `gorm:"serializer:json"`
    ClientProfileID NullableUUID    `gorm:"type:text;index"`
}
```

**Why:** Type mismatches between GORM annotations and SQL schema cause runtime errors.

## SQLite Concurrent Write Operations - CRITICAL

**ALWAYS configure these SQLite settings to handle concurrent writes and parallel testing:**

### Required PRAGMA Settings

```go
// Enable WAL mode for better concurrency (allows multiple readers + 1 writer)
if _, err := sqlDB.Exec("PRAGMA journal_mode=WAL;"); err != nil {
    return fmt.Errorf("failed to enable WAL mode: %w", err)
}

// Set busy timeout for handling concurrent write operations (30 seconds)
if _, err := sqlDB.Exec("PRAGMA busy_timeout = 30000;"); err != nil {
    return fmt.Errorf("failed to set busy timeout: %w", err)
}
```

### Connection Pool Configuration

```go
// For SQLite, limit connection pool to prevent write contention
// SQLite only supports 1 concurrent writer (even in WAL mode)
sqlDB.SetMaxOpenConns(1)  // Use magic constant: cryptoutilMagic.SQLiteMaxOpenConnections
sqlDB.SetMaxIdleConns(1)
```

### Why This Matters

- **WAL mode** (Write-Ahead Logging) allows multiple concurrent readers and one writer
- **busy_timeout** makes SQLite retry when database is locked instead of immediately failing
- **MaxOpenConns=1** prevents connection pool from trying concurrent writes (which would fail)
- **Without these settings**, parallel Go tests using `t.Parallel()` will fail with database locking errors

### Reference Implementation

See `internal/server/repository/sqlrepository/sql_provider.go` lines 201-213 for the canonical SQLite configuration pattern used in the KMS server code.

### Magic Constants

Use these constants from `internal/common/magic/magic_database.go`:

- `cryptoutilMagic.DBSQLiteBusyTimeout` = 30 seconds
- `cryptoutilMagic.SQLiteMaxOpenConnections` = 1

## SQLite Read-Only Transactions - CRITICAL

**SQLite does NOT support read-only transactions - NEVER use them:**

```go
// WRONG - fails on SQLite with "cannot start a transaction within a transaction" or similar errors
tx := db.Begin(&sql.TxOptions{ReadOnly: true})

// CORRECT for SQLite - use default transaction or avoid transactions for read-only operations
tx := db.Begin()  // Standard read-write transaction
// OR
result := db.Find(&models)  // Direct query without explicit transaction
```

**Why:**

- SQLite does not support the `READ ONLY` transaction isolation level
- PostgreSQL supports `SET TRANSACTION READ ONLY` but SQLite ignores/errors on this
- Tests using read-only transactions will fail on SQLite: "SQLite doesn't support read-only transactions"
- **Solution**: Use standard transactions or direct queries for read operations

**Cross-DB Pattern for Read-Heavy Operations:**

```go
// Use this pattern for cross-database compatibility
func (r *Repository) GetMany(ctx context.Context) ([]Model, error) {
    var results []Model
    // Don't use Begin() for simple reads - direct query is sufficient
    if err := r.db.WithContext(ctx).Find(&results).Error; err != nil {
        return nil, fmt.Errorf("failed to query: %w", err)
    }
    return results, nil
}
```

## Database DSN Usage

**Database DSN (Use localhost):**

```go
dsn := "postgres://user:pass@localhost:5432/dbname?sslmode=disable"
```
