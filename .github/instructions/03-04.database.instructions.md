---
description: "Database operations and ORM patterns"
applyTo: "**"
---
# Database

# Database and ORM Patterns - Tactical Guidance

**This file contains ONLY tactical implementation patterns**

## Quick Reference: Cross-DB Compatibility

| Feature | PostgreSQL | SQLite | Solution |
|---------|-----------|---------|----------|
| UUID Type | uuid, text | text only | Use `type:text` |
| Nullable UUIDs | *UUID, NullableUUID | NullableUUID only | Use NullableUUID |
| JSON Arrays | json, text | text only | Use `serializer:json` |
| Read-Only Tx | Supported | NOT supported | Use standard tx |

## Core Patterns

**UUID Fields** (cross-DB compatible):

```go
ID googleUuid.UUID `gorm:"type:text;primaryKey"`  // ✅ Works everywhere
```

**Nullable UUIDs** (avoid pointer UUIDs):

```go
ClientProfileID NullableUUID `gorm:"type:text;index"`  // ✅ Custom type
```

**JSON Arrays/Objects** (cross-DB compatible):

```go
AllowedScopes []string `gorm:"serializer:json"`  // ✅ Works everywhere
```

**Database DSN**:

```go
dsn := "postgres://user:pass@localhost:5432/dbname?sslmode=disable"
```

## Cross-Database Compatibility - CRITICAL

### UUID Type Handling

✅ `gorm:"type:text"` (works on PostgreSQL + SQLite)
❌ `gorm:"type:uuid"` (breaks SQLite - no native UUID type)

### Nullable UUID Foreign Keys

✅ `NullableUUID` type (implements sql.Scanner + driver.Valuer)
❌ `*googleUuid.UUID` (causes "row value misused" in SQLite)

### JSON Array/Object Fields

✅ `gorm:"serializer:json"` (works on PostgreSQL + SQLite)
❌ `gorm:"type:json"` (breaks SQLite - no native JSON type)

## SQLite Concurrent Write Operations - CRITICAL

**ALWAYS configure these SQLite settings to handle concurrent writes and parallel testing:**

### Required PRAGMA Settings

```go
// Enable WAL mode for better concurrency (allows multiple readers + 1 writer)
if _, err := sqlDB.Exec("PRAGMA journal_mode=WAL;"); err != nil {
    return fmt.Errorf("failed to enable WAL mode: %w", err)
}

// Set busy timeout for handling concurrent write operations (30 seconds)
if _, err := sqlDB.Exec("PRAGMA busy_timeout = 30000;"); err != nil {
    return fmt.Errorf("failed to set busy timeout: %w", err)
}
```

### Connection Pool Configuration

```go
// For SQLite, limit connection pool to prevent write contention
// SQLite only supports 1 concurrent writer (even in WAL mode)
sqlDB.SetMaxOpenConns(1)  // Use magic constant: cryptoutilMagic.SQLiteMaxOpenConnections
sqlDB.SetMaxIdleConns(1)
```

### Why This Matters

- **WAL mode** (Write-Ahead Logging) allows multiple concurrent readers and one writer
- **busy_timeout** makes SQLite retry when database is locked instead of immediately failing
- **MaxOpenConns=1** prevents connection pool from trying concurrent writes (which would fail)
- **Without these settings**, parallel Go tests using `t.Parallel()` will fail with database locking errors

### Reference Implementation

See `internal/server/repository/sqlrepository/sql_provider.go` lines 201-213 for the canonical SQLite configuration pattern used in the KMS server code.

### Magic Constants

Use these constants from `internal/common/magic/magic_database.go`:

- `cryptoutilMagic.DBSQLiteBusyTimeout` = 30 seconds
- `cryptoutilMagic.SQLiteMaxOpenConnections` = 1

## SQLite Read-Only Transactions - CRITICAL

**SQLite does NOT support read-only transactions - NEVER use them:**

```go
// WRONG - fails on SQLite with "cannot start a transaction within a transaction" or similar errors
tx := db.Begin(&sql.TxOptions{ReadOnly: true})

// CORRECT for SQLite - use default transaction or avoid transactions for read-only operations
tx := db.Begin()  // Standard read-write transaction
// OR
result := db.Find(&models)  // Direct query without explicit transaction
```

**Why:**

- SQLite does not support the `READ ONLY` transaction isolation level
- PostgreSQL supports `SET TRANSACTION READ ONLY` but SQLite ignores/errors on this
- Tests using read-only transactions will fail on SQLite: "SQLite doesn't support read-only transactions"
- **Solution**: Use standard transactions or direct queries for read operations

**Cross-DB Pattern for Read-Heavy Operations:**

```go
// Use this pattern for cross-database compatibility
func (r *Repository) GetMany(ctx context.Context) ([]Model, error) {
    var results []Model
    // Don't use Begin() for simple reads - direct query is sufficient
    if err := r.db.WithContext(ctx).Find(&results).Error; err != nil {
        return nil, fmt.Errorf("failed to query: %w", err)
    }
    return results, nil
}
```

## Multi-Tenancy - MANDATORY

**Schema-Level Isolation ONLY**:

- Each tenant gets separate schema: `tenant_<uuid>.users`, `tenant_<uuid>.sessions`
- NEVER use row-level multi-tenancy (single schema, tenant_id column)
- Reason: Data isolation, compliance, performance (per-tenant indexes)
- Pattern: Set `search_path` on connection: `SET search_path TO tenant_abc123`

## Read Replicas - NOT SUPPORTED

**Read replicas are NOT supported in cryptoutil**:

- All traffic goes to primary database (write + read)
- Reason: Session consistency, ACID guarantees, operational simplicity
- Future: May add read replicas in Phase 4 (multi-region scale)

## Connection Pool Configuration - MANDATORY

**Hot-Reload Pattern**:

- Connection pool settings MUST be reconfigurable without restart
- Pattern: Watch config file, call `sqlDB.SetMaxOpenConns()` on change
- Settings: `max_open_conns`, `max_idle_conns`, `conn_max_lifetime`
- Validation: MUST validate settings before applying (prevent invalid configs)

## Database DSN Usage

**Database DSN (Use localhost):**

```go
dsn := "postgres://user:pass@localhost:5432/dbname?sslmode=disable"
```

## Core Database Requirements

**ORM**: GORM (MANDATORY, never raw database/sql)
**Rationale**: Consistent API across PostgreSQL/SQLite, migrations, type-safe queries, error handling, transactions

## Cross-Database Compatibility - CRITICAL

### UUID Handling

**ALWAYS use TEXT for UUIDs** (SQLite has no native UUID type)

**Pattern**: `gorm:"type:text;primaryKey"` works on both PostgreSQL and SQLite

### Nullable UUID Foreign Keys

**Use NullableUUID type** (pointer UUIDs cause "row value misused" errors in SQLite)

**Implementation**: Custom type with sql.Scanner/driver.Valuer, handles NULL properly for TEXT columns

### JSON Array/Object Fields

**ALWAYS use `serializer:json`** (NOT `type:json`, SQLite has no native JSON type)

**Pattern**: `AllowedScopes []string` with `gorm:"serializer:json"` works on both PostgreSQL and SQLite

---

## SQLite Concurrent Operations - CRITICAL

**Required PRAGMA**: WAL mode + busy timeout (30s) for concurrent operations
**Connection Pool**: MaxOpenConns=5 for GORM transactions (see sqlite-gorm.md)
**Read-Only Transactions**: NOT supported - use standard transactions or direct queries

**Magic Constants**: `cryptoutilMagic.DBSQLiteBusyTimeout` (30s), `cryptoutilMagic.SQLiteMaxOpenConnections` (5)

## Database DSN Patterns

**Note**: "postgres://" is the DSN scheme per libpq standard; "PostgreSQL" is the product name

**PostgreSQL**: `postgres://user:pass@localhost:5432/dbname?sslmode=disable` (dev) or `sslmode=require` (prod)
**SQLite File**: `file:/var/lib/cryptoutil/data.db?cache=shared&mode=rwc`
**SQLite Memory**: `file::memory:?cache=shared`

## Error Mapping

**Pattern**: toAppErr method maps GORM errors to HTTP errors (ErrRecordNotFound → 404, ErrDuplicatedKey → 409)

## Migrations

**Use golang-migrate with embedded files** (`//go:embed migrations/*.sql`), run on startup before starting servers

**Naming**: `0001_init.up.sql`, `0001_init.down.sql`, `0002_add_users.up.sql`, `0002_add_users.down.sql`

## Connection Pooling

**PostgreSQL**: MaxOpenConns=25, MaxIdleConns=10, ConnMaxLifetime=1h
**SQLite**: MaxOpenConns=5, MaxIdleConns=5, ConnMaxLifetime=0 (in-memory)

## Pagination and Filtering

**Pagination**: Offset/limit pattern with total count
**Filtering**: Dynamic WHERE clauses based on filter struct

## Debug Logging

**Enable**: `db.Logger = logger.Default.LogMode(logger.Info)` (development only)

---

## Key Takeaways

1. **GORM Always**: Never use raw database/sql (use GORM for consistency)
2. **UUID as TEXT**: ALWAYS `type:text` for UUIDs (cross-DB compatibility)
3. **NullableUUID**: Use custom type for optional UUID foreign keys (not pointer UUIDs)
4. **serializer:json**: Use for JSON arrays/objects (not `type:json`)
5. **WAL Mode + Busy Timeout**: Required for SQLite concurrent operations
6. **No Read-Only Transactions**: SQLite limitation (use standard transactions or direct queries)
7. **Migrations on Startup**: ALWAYS apply migrations before starting servers
8. **Error Mapping**: toAppErr method maps GORM errors to application HTTP errors
