---
description: "Instructions for products and services architecture"
applyTo: "**"
---
# Products & Services Architecture - CRITICAL

**cryptoutil** is a production-ready suite of four cryptographic-based products, designed with enterprise-grade security, **FIPS 140-3** standards compliance, Zero-Trust principles, and security-on-by-default.

## Product Suite Architecture - CRITICAL

Each product can be used independently, or together as a comprehensive security solution. The four services are:

| Service Alias | Product | Service | Public Ports | Admin Port | Description |
|---------------|-----------|-------------|------------|-------------|
| **sm-kms** | Secrets Manager | Key Management Service (KMS) | 8080-8089 | 127.0.0.1:9090 | REST APIs for per-tenant Elastic Keys |
| **pki-ca** | Public Key Infrastructure | Certificate Authority (CA) | 8443-8449 | 127.0.0.1:9090 | X.509 certificate lifecycle, EST, SCEP, OCSP, CRLDP, CMPv2, CMC, time-stamping |
| **jose-ja** | JOSE | JWK Authority (JA) | 9443-9449 | 127.0.0.1:9090 | JWK, JWKS, JWE, JWS, JWT operations |
| **identity-authz** | Identity | Authorization Server (authz) | 18000-18009 | 127.0.0.1:9090 | OAuth 2.1 authorization server, OIDC Discovery |
| **identity-idp** | Identity | Identity Provider (IdP) | 18100-18109 | 127.0.0.1:9090 | OIDC 1.0 authentication, login/consent UI, MFA enrollment |
| **identity-rs** | Identity | Resource Server (RS) | 18200-18209 | 127.0.0.1:9090 | Protected API with token validation (reference implementation) |
| **identity-rp** | Identity | Relying Party (RP) | 18300-18309 | 127.0.0.1:9090 | Backend-for-Frontend pattern (reference implementation) |
| **identity-spa** | Identity  Single Page Application (SPA) | 18400-18409 | 127.0.0.1:9090 | Static hosting for SPA clients (reference implementation) |

| Service Alias | Product | Service | Public Port | Admin Port | Description |
|---------------|-----------|-------------|------------|-------------|
| **learn-ps** | Learn | Pet Store | 8888-8889 | 127.0.0.1:9090 | Educational service demonstrating service template usage |

## Service Template Requirement - MANDATORY

**CRITICAL: NEVER duplicate service infrastructure code - ALWAYS use extracted template**

### Service Template Pattern (Phase 6)

**Template Components** (extract from KMS reference implementation):

- **Dual HTTPS Servers**: Public API (<configurable_address>:<configurable_port>) + Admin API (127.0.0.1:9090)
- **Dual API Paths**: `/browser/api/v1/*` (session-based) vs `/service/api/v1/*` (token-based)
- **Middleware Pipeline**: CORS/CSRF/CSP (browser), rate limiting, IP allowlist, auth
- **Database Abstraction**: PostgreSQL + SQLite dual support with GORM
- **OpenTelemetry Integration**: OTLP traces, metrics, logs
- **Health Check Endpoints**: `/admin/v1/livez`, `/admin/v1/readyz`, `/admin/v1/healthz`
- **Graceful Shutdown**: `/admin/v1/shutdown` endpoint with context cancellation
- **Config Management**: YAML files + CLI flags, Docker secrets support
- **TLS Configuration**: Separate public/admin TLS, client cert authentication

**Template Parameterization**:

- Constructor injection for handlers, middleware, configuration
- Service-specific OpenAPI specs passed to template
- Business logic separated from infrastructure concerns

**Mandatory Usage**:

- Phase 6 MUST extract reusable template before implementing new services
- Phase 7 Learn-PS MUST use template to validate reusability
- ALL new services MUST use template (consistency, reduced duplication)
- Template success criteria: Service implementation <500 lines

**NEVER DO**:

- ❌ Copy-paste service infrastructure code between services
- ❌ Duplicate dual-server pattern, health checks, shutdown logic
- ❌ Reimplement middleware pipeline, telemetry integration

**ALWAYS DO**:

- ✅ Extract template from proven KMS implementation
- ✅ Parameterize template for service-specific customization
- ✅ Validate template reusability via Learn-PS demonstration

---

## Microservices Architecture - CRITICAL

**MANDATORY: All Services in All Products MUST support run as containers; this is preferred for production and end-to-end testing**

**MANDATORY: All Services in All Products MUST support Two HTTPS Endpoints**

Separate HTTPS endpoints for public operations vs private administration MUST be supported. TLS server certificate authentication MUST be enforced for both endpoints; TLS client certificate authentication may be enabled per endpoint, and set to either preferred or required, via configuration; HTTP is NEVER allowed.

### Deployment Environments

**Production Deployments**:

- Public endpoints MUST use 0.0.0.0 IPv4 bind address inside containers (enables external access)
- Public endpoints MAY use configurable IPv4 or IPv6 bind address outside containers (defaults to 127.0.0.1)
- Private endpoints MUST use 127.0.0.1:9090 inside containers (not mapped outside)
- No IPv6 inside containers: All endpoints must use IPv4 inside containers, due to dual-stack limitations in container runtimes (e.g. Docker Desktop for Windows)

**Development/Test Environments**:

For address binding:

- Public and private endpoints MUST use 127.0.0.1 IPv4 bind address (prevents Windows Firewall prompts)
- Rationale: 0.0.0.0 binding triggers Windows Firewall exception prompts, blocking automated execution of tests

For port binding:

- Public and private endpoints MUST use port 0 (dynamic allocation) to avoid port collisions
- Rationale: static ports cause port collisions during parallel test automation

### CA Architecture Pattern

**See 01-10.pki.instructions.md for comprehensive CA architecture patterns and TLS Issuing CA configurations**

### Two Endpoint HTTPS Architecture Pattern

#### TLS Certificate Configuration

All services in all products MUST support separate configuration for two HTTPS endpoints, including separate configuration for TLS Server and TLS client of each endpoint.

These main options MUST be supported via configuration from the point of view (POV) of the HTTPS Issuing CA certificate chain:

1. All Externally; useful for production, where HTTPS Issuing CA certificate chain is provided without private key, and the HTTPS Server certificate chain is provided with private key
2. Mixed External and Auto-Generated; where Issuing CA chain is provided with private key, and HTTPS Server certificate and private key are generated and signed by the Issuing CA; useful for per-product development and testing
3. All Auto-Generated; where HTTPS Server certificate chain and private key are all generated by the service instance; useful for standalone service development and testing, not production

HTTPS Issuing CA certificate chains for TLS Server MAY BE per-suite, per-product, or per-service type.

HTTPS Issuing CA certificate chains for TLS Client MUST BE per-service type (preferred).

**Static TLS Certificates** (Externally Provided):

These main options MUST be supported via configuration from the point of view (POV) of the HTTPS Server certificate chain and private key:

- Private keys stored in Docker Secrets (production and development)
- Certificate chains provided via file paths or PEM-encoded data in configuration files
- Trusted CA certificates configurable for client verification
- Required for production deployments with organizational PKI

HTTPS Issuing CA for TLS Server Certs SHOULD BE shared across all products (preferred), all services of a product, per-service instance type, or per-service instance.

HTTPS Issuing CA for TLS Client Certs MUST BE shared per per-service instance type.

#### 2. Private HTTPS Endpoint

**Purpose**: Administration, health checks, graceful shutdown

**Configuration**:

- Production port: 127.0.0.1:9090 (static binding)
- Test port: 0 (dynamic allocation)
- Bind address: ALWAYS 127.0.0.1 (IPv4 loopback only)
- TLS: HTTPS is MANDATORY (never HTTP)
- External access: NEVER (127.0.0.1-only)

**Endpoints**:

- `/admin/v1/livez` - Liveness probe (service running)
- `/admin/v1/readyz` - Readiness probe (service ready to accept traffic)
- `/admin/v1/healthz` - Health check (service healthy)
- `/admin/v1/shutdown` - Graceful shutdown trigger

**Consumers**: Docker health checks, Kubernetes probes, monitoring systems, orchestration tools

#### 3. Public HTTPS Endpoint (Public Server)

**Purpose**: Business APIs, browser UIs, external client access

**Configuration**:

- Production ports: Service-specific ranges (8080-8089 for KMS, 8180-8189 for Identity, etc.)
- Bind address: 127.0.0.1 (production containers can set 0.0.0.0 via configuration), 127.0.0.1 (tests/development)
- TLS: HTTPS MANDATORY (never HTTP)
- External access: YES (exposed to clients)

**Request Path Prefixes and Middlewares**:

For public HTTPS endpoint, all services implement TWO security middleware stacks, which reuse an OpenAPI specification per service but enforce different authentication, authorization, and access control policies based on request path prefixes:

**Service-to-Service APIs** (`/service/**` prefix):

- Access: Service clients ONLY (browsers blocked by middleware)
- Middleware: IP allowlist, rate limiting, request logging

**Browser-to-Service APIs/UI** (`/browser/**` prefix):

- Access: Browser clients ONLY (service clients blocked by middleware)
- Middleware: CSRF protection, CORS policies, CSP headers, IP allowlist, rate limiting
- Additional content: HTML pages, JavaScript, CSS, images, fonts, etc.

**API Consistency**:

- SAME OpenAPI specification served at both `/service/**` and `/browser/**` paths
- Middleware enforces mutual exclusivity (service tokens can't access browser paths, vice versa)
- Prevents unauthorized cross-client access patterns

---

## Service Federation - CRITICAL

**MANDATORY: Services MUST support configurable federation for cross-service communication**

### Federation Configuration Pattern

Services discover and communicate with other cryptoutil services via configuration (NEVER hardcoded URLs):

```yaml
# Example KMS config with federation
federation:
  # Identity service for OAuth 2.1 authentication
  identity_url: "https://identity-authz:8180"
  identity_enabled: true
  identity_timeout: 10s

  # JOSE service for external JWE/JWS operations
  jose_url: "https://jose-server:8280"
  jose_enabled: true
  jose_timeout: 10s

  # CA service for TLS certificate operations
  ca_url: "https://ca-server:8380"
  ca_enabled: false  # Optional - KMS can use internal TLS certs
  ca_timeout: 10s

# Graceful degradation settings
federation_fallback:
  # When identity service unavailable
  identity_fallback_mode: "local_validation"  # or "reject_all", "allow_all" (dev only)

  # When JOSE service unavailable
  jose_fallback_mode: "internal_crypto"  # Use internal JWE/JWS implementation

  # When CA service unavailable
  ca_fallback_mode: "self_signed"  # Generate self-signed TLS certs
```

### Service Discovery Mechanisms

**1. Configuration File (Preferred for Static Deployments)**:

```yaml
# Explicit URLs in config.yaml
federation:
  identity_url: "https://identity.example.com:8180"
  jose_url: "https://jose.example.com:8280"
```

**2. Docker Compose Service Names**:

```yaml
# Docker networks provide DNS resolution
federation:
  identity_url: "https://identity-authz:8180"  # Service name from compose.yml
  jose_url: "https://jose-server:8280"
```

**3. Kubernetes Service Discovery**:

```yaml
# Kubernetes DNS provides service resolution
federation:
  identity_url: "https://identity-authz.cryptoutil-ns.svc.cluster.local:8180"
  jose_url: "https://jose-server.cryptoutil-ns.svc.cluster.local:8280"
```

**4. Environment Variables (Docker Secrets Integration)**:

```bash
# Environment variables override config file
CRYPTOUTIL_FEDERATION_IDENTITY_URL="https://identity:8180"
CRYPTOUTIL_FEDERATION_JOSE_URL="https://jose:8280"
```

### Graceful Degradation Patterns

**Circuit Breaker**: Automatically disable federated service after N consecutive failures

```go
type CircuitBreaker struct {
    failureThreshold int       // Open circuit after N failures
    timeout          time.Duration // Reset circuit after timeout
    halfOpenRequests int       // Test N requests before closing circuit
}
```

**Fallback Modes**:

- **Identity Unavailable**: Local token validation (cached public keys), reject all (strict), allow all (development only)
- **JOSE Unavailable**: Internal crypto implementation (use KMS's own JWE/JWS)
- **CA Unavailable**: Self-signed TLS certificates (development), cached certificates (production)

**Retry Strategies**:

- **Exponential Backoff**: 1s, 2s, 4s, 8s, 16s (max 5 retries)
- **Timeout Escalation**: Increase timeout 1.5x per retry (10s → 15s → 22.5s)
- **Health Check Before Retry**: Poll `/admin/v1/healthz` endpoint before resuming traffic

### Federation Health Monitoring

**Regular Health Checks**:

```go
// Check federated service health every 30 seconds
ticker := time.NewTicker(30 * time.Second)
for range ticker.C {
    if err := checkFederatedServiceHealth(identityURL); err != nil {
        logger.Warn("identity service unhealthy", "error", err)
        // Activate fallback mode
    }
}
```

**Metrics and Alerts**:

- `federation_request_duration_seconds{service="identity"}` - Latency tracking
- `federation_request_failures_total{service="identity"}` - Error rate
- `federation_circuit_breaker_state{service="identity"}` - Circuit state (closed/open/half-open)

### Cross-Service Authentication

**Service-to-Service mTLS** (Preferred):

```yaml
federation:
  identity_url: "https://identity-authz:8180"
  identity_client_cert: "file:///run/secrets/kms_client_cert"
  identity_client_key: "file:///run/secrets/kms_client_key"
  identity_ca_cert: "file:///run/secrets/identity_ca_cert"
```

**OAuth 2.1 Client Credentials** (Alternative):

```yaml
federation:
  identity_url: "https://identity-authz:8180"
  identity_client_id: "kms-service"
  identity_client_secret: "file:///run/secrets/kms_client_secret"
  identity_token_endpoint: "https://identity-authz:8180/service/token"
```

### Federation Testing Requirements

**Integration Tests MUST**:

- Test each federated service independently (mock others)
- Test graceful degradation when federated service unavailable
- Test circuit breaker behavior (failure thresholds, timeouts, recovery)
- Test retry logic (exponential backoff, max retries)
- Verify timeout configurations prevent cascade failures

**E2E Tests MUST**:

- Deploy full stack (all federated services)
- Test cross-service communication paths
- Test federation with Docker Compose service discovery
- Verify health checks detect service failures
- Test failover and recovery scenarios
