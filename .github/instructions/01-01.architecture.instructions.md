---
description: "Instructions for products and services architecture"
applyTo: "**"
---
# Products & Services Architecture - CRITICAL

**cryptoutil** is a production-ready suite of four cryptographic-based services, designed with enterprise-grade security, **FIPS 140-3** standards compliance, Zero-Trust principles, and security-on-by-default.

## Product Suite Architecture - CRITICAL

Each product can be used independently, or together as a comprehensive security solution. The four services are:

| Service Alias | Product | Service | Public Ports | Admin Port | Description |
|---------------|-----------|-------------|------------|-------------|
| **sm-kms** | Secrets Manager | Key Management Service (KMS) | 8080-8089 | 127.0.0.1:9090 | REST APIs for per-tenant ElasticKeys, each composed of MaterialKeys |
| **pki-ca** | Public Key Infrastructure | Certificate Authority (CA) | 8443-8449 | 127.0.0.1:9090 | X.509 certificate lifecycle, EST, SCEP, OCSP, CRLDP, CMPv2, CMC, time-stamping |
| **jose-ja** | JOSE | JWK Authority (JA) | 9443-9449 | 127.0.0.1:9090 | JWK, JWKS, JWE, JWS, JWT operations |
| **identity-authz** | Identity | Authorization Server (authz) | 18000-18009 | 127.0.0.1:9090 | OAuth 2.1 authorization server, OIDC Discovery |
| **identity-idp** | Identity | Identity Provider (IdP) | 18100-18109 | 127.0.0.1:9090 | OIDC 1.0 authentication, login/consent UI, MFA enrollment |
| **identity-rs** | Identity | Resource Server (RS) | 18200-18209 | 127.0.0.1:9090 | Protected API with token validation (reference implementation) |
| **identity-rp** | Identity | Relying Party (RP) | 18300-18309 | 127.0.0.1:9090 | Backend-for-Frontend pattern (reference implementation) |
| **identity-spa** | Identity  Single Page Application (SPA) | 18400-18409 | 127.0.0.1:9090 | Static hosting for SPA clients (reference implementation) |

| Service Alias | Product | Service | Public Port | Admin Port | Description |
|---------------|-----------|-------------|------------|-------------|
| **learn-ps** | Learn | Pet Store | 8888-8889 | 127.0.0.1:9090 | Educational service demonstrating service template usage |

## Microservices Architecture - CRITICAL

**MANDATORY: All 9 Services in All 5 Products MUST support Dual HTTPS Endpoints**

All services MUST implement separate HTTPS endpoints for public operations and private administration operations. TLS client certificate authentication can also be enforced as a configuration option; HTTP is NEVER allowed.

### Deployment Environments

**Production Deployments**:

- All services MUST run in containers
- Public endpoints MUST use 0.0.0.0 IPv4 bind address inside containers (enables external access)
- Public endpoints MAY use configurable bind address outside containers (defaults to 0.0.0.0)
- Private endpoints MUST use 127.0.0.1:9090 inside containers (not mapped outside)
- Port mappings: Public ports map host→container on same port number
- IPv6: MUST NOT use due to dual-stack issues in Docker

**Development/Test Environments**:

- Public endpoints MUST use 127.0.0.1 IPv4 bind address (prevents Windows Firewall prompts)
- Public endpoints MUST use port 0 (dynamic allocation) to avoid port collisions
- Private endpoints MUST use 127.0.0.1:9090 (static port)
- Rationale: 0.0.0.0 binding triggers Windows Firewall exception prompts, blocking test automation

### Dual-Endpoint Architecture Pattern

#### 1. TLS Certificate Configuration

All services MUST support configurable TLS server certificate chains and private keys:

**Dynamic TLS Certificates** (Auto-Generated):

- Leaf certificate, intermediate CA certificates, and root CA certificate auto-generated by private CA
- CA scoped per-product or per-suite
- Useful for development, testing, ephemeral environments

**Static TLS Certificates** (Externally Provided):

- Private keys stored in Docker Secrets (production) or file paths (development)
- Certificate chains provided via file paths or PEM-encoded data
- Trusted CA certificates configurable for client verification
- Required for production deployments with organizational PKI

#### 2. Private HTTPS Endpoint (Admin Server)

**Purpose**: Administration, health checks, graceful shutdown

**Configuration**:

- Default port: 0 (dynamic allocation)
- Production port: 127.0.0.1:9090 (static binding)
- Bind address: ALWAYS 127.0.0.1 (IPv4 loopback only)
- TLS: MANDATORY (never HTTP)
- External access: NEVER (localhost-only)

**Endpoints**:

- `/admin/v1/livez` - Liveness probe (service running)
- `/admin/v1/readyz` - Readiness probe (service ready to accept traffic)
- `/admin/v1/healthz` - Health check (service healthy)
- `/admin/v1/shutdown` - Graceful shutdown trigger

**Consumers**: Docker health checks, Kubernetes probes, monitoring systems, orchestration tools

#### 3. Public HTTPS Endpoint (Public Server)

**Purpose**: Business APIs, browser UIs, external client access

**Configuration**:

- Default port: 0 (dynamic allocation for tests)
- Production ports: Service-specific ranges (8080-8089 for KMS, 8180-8189 for Identity, etc.)
- Bind address: 0.0.0.0 (production containers), 127.0.0.1 (tests/development)
- TLS: MANDATORY (never HTTP)
- External access: YES (exposed to clients)

**Request Path Prefixes and Middlewares**:

All services implement TWO security middleware stacks on the SAME OpenAPI specification:

**Service-to-Service APIs** (`/service/**` prefix):

- Authentication: OAuth 2.1 Client Credentials Flow (HTTP Authorization header)
- Token type: Bearer tokens (machine-to-machine)
- Middleware: IP allowlist, rate limiting, request logging
- Access: Service clients ONLY (browsers blocked by middleware)

**Browser-to-Service APIs/UI** (`/browser/**` prefix):

- Authentication: OAuth 2.1 Authorization Code + PKCE Flow (HTTP Cookie header)
- Token type: Session cookies (user-to-service)
- Middleware: CSRF protection, CORS policies, CSP headers, IP allowlist, rate limiting
- Access: Browser clients ONLY (service clients blocked by middleware)
- Additional content: HTML pages, JavaScript, CSS, images, fonts, etc.

**API Consistency**:

- SAME OpenAPI specification served at both `/service/**` and `/browser/**` paths
- Middleware enforces mutual exclusivity (service tokens can't access browser paths, vice versa)
- Prevents unauthorized cross-client access patterns

---

## Service Federation - CRITICAL

**MANDATORY: Services MUST support configurable federation for cross-service communication**

### Federation Configuration Pattern

Services discover and communicate with other cryptoutil services via configuration (NEVER hardcoded URLs):

```yaml
# Example KMS config with federation
federation:
  # Identity service for OAuth 2.1 authentication
  identity_url: "https://identity-authz:8180"
  identity_enabled: true
  identity_timeout: 10s

  # JOSE service for external JWE/JWS operations
  jose_url: "https://jose-server:8280"
  jose_enabled: true
  jose_timeout: 10s

  # CA service for TLS certificate operations
  ca_url: "https://ca-server:8380"
  ca_enabled: false  # Optional - KMS can use internal TLS certs
  ca_timeout: 10s

# Graceful degradation settings
federation_fallback:
  # When identity service unavailable
  identity_fallback_mode: "local_validation"  # or "reject_all", "allow_all" (dev only)

  # When JOSE service unavailable
  jose_fallback_mode: "internal_crypto"  # Use internal JWE/JWS implementation

  # When CA service unavailable
  ca_fallback_mode: "self_signed"  # Generate self-signed TLS certs
```

### Service Discovery Mechanisms

**1. Configuration File (Preferred for Static Deployments)**:

```yaml
# Explicit URLs in config.yaml
federation:
  identity_url: "https://identity.example.com:8180"
  jose_url: "https://jose.example.com:8280"
```

**2. Docker Compose Service Names**:

```yaml
# Docker networks provide DNS resolution
federation:
  identity_url: "https://identity-authz:8180"  # Service name from compose.yml
  jose_url: "https://jose-server:8280"
```

**3. Kubernetes Service Discovery**:

```yaml
# Kubernetes DNS provides service resolution
federation:
  identity_url: "https://identity-authz.cryptoutil-ns.svc.cluster.local:8180"
  jose_url: "https://jose-server.cryptoutil-ns.svc.cluster.local:8280"
```

**4. Environment Variables (Docker Secrets Integration)**:

```bash
# Environment variables override config file
CRYPTOUTIL_FEDERATION_IDENTITY_URL="https://identity:8180"
CRYPTOUTIL_FEDERATION_JOSE_URL="https://jose:8280"
```

### Graceful Degradation Patterns

**Circuit Breaker**: Automatically disable federated service after N consecutive failures

```go
type CircuitBreaker struct {
    failureThreshold int       // Open circuit after N failures
    timeout          time.Duration // Reset circuit after timeout
    halfOpenRequests int       // Test N requests before closing circuit
}
```

**Fallback Modes**:

- **Identity Unavailable**: Local token validation (cached public keys), reject all (strict), allow all (development only)
- **JOSE Unavailable**: Internal crypto implementation (use KMS's own JWE/JWS)
- **CA Unavailable**: Self-signed TLS certificates (development), cached certificates (production)

**Retry Strategies**:

- **Exponential Backoff**: 1s, 2s, 4s, 8s, 16s (max 5 retries)
- **Timeout Escalation**: Increase timeout 1.5x per retry (10s → 15s → 22.5s)
- **Health Check Before Retry**: Poll `/admin/v1/healthz` endpoint before resuming traffic

### Federation Health Monitoring

**Regular Health Checks**:

```go
// Check federated service health every 30 seconds
ticker := time.NewTicker(30 * time.Second)
for range ticker.C {
    if err := checkFederatedServiceHealth(identityURL); err != nil {
        logger.Warn("identity service unhealthy", "error", err)
        // Activate fallback mode
    }
}
```

**Metrics and Alerts**:

- `federation_request_duration_seconds{service="identity"}` - Latency tracking
- `federation_request_failures_total{service="identity"}` - Error rate
- `federation_circuit_breaker_state{service="identity"}` - Circuit state (closed/open/half-open)

### Cross-Service Authentication

**Service-to-Service mTLS** (Preferred):

```yaml
federation:
  identity_url: "https://identity-authz:8180"
  identity_client_cert: "file:///run/secrets/kms_client_cert"
  identity_client_key: "file:///run/secrets/kms_client_key"
  identity_ca_cert: "file:///run/secrets/identity_ca_cert"
```

**OAuth 2.1 Client Credentials** (Alternative):

```yaml
federation:
  identity_url: "https://identity-authz:8180"
  identity_client_id: "kms-service"
  identity_client_secret: "file:///run/secrets/kms_client_secret"
  identity_token_endpoint: "https://identity-authz:8180/service/token"
```

### Federation Testing Requirements

**Integration Tests MUST**:

- Test each federated service independently (mock others)
- Test graceful degradation when federated service unavailable
- Test circuit breaker behavior (failure thresholds, timeouts, recovery)
- Test retry logic (exponential backoff, max retries)
- Verify timeout configurations prevent cascade failures

**E2E Tests MUST**:

- Deploy full stack (all federated services)
- Test cross-service communication paths
- Test federation with Docker Compose service discovery
- Verify health checks detect service failures
- Test failover and recovery scenarios
