---
description: "Instructions for products and services architecture"
applyTo: "**"
---
# Products & Services Architecture - CRITICAL

**cryptoutil** is a production-ready suite of four cryptographic-based services, designed with enterprise-grade security, **FIPS 140-3** standards compliance, Zero-Trust principles, and security-on-by-default.

## Product Suite Architecture - CRITICAL

Each product can be used independently, or together as a comprehensive security solution. The four services are:

1. **Key Management Service (KMS)** - One service. Elastic Keys per tenant support Encrypt/Decrypt or Sign/Verify (depending on algorithm). Each Elastic Key is a key ring of 1-N Material Keys of specified algorithm. Latest Material Key is always used for Encrypt||Sign, and historical Material Key is always used for Decrypt||Verify. Encrypt/Decrypt payload is JWE. Sign/Verify payload is JWS.
2. **Identity Service** - Five services. Authorization server supports OAuth 2.1 and OIDC 1.0. IdP server supports multi-factor authentication (e.g. Username/Password, mTLS, WebAuthn, Passkeys, TOTP, HOTP, Magic Link, Yubikey). Relying Party, Resource Server, and Single Page Application, are all security-on-by-default reference implementations for customers to use as the basis for their custom services.
3. **Certificate Authority (CA)** - One service. Collection of APIs/UI for Administration, CMP, CMPv2, SCEP, EST, RA, CRLDP, OSCP, TimeStamping
4. **JSON Object Signing and Encryption (JOSE)** - One service. Collection of APIs/UI for Administration, JWK, JWKSet, JWE, JWS, JWT

Examples of using multiple services together:

- KMS with CA+Identity+JOSE: KMS Product uses CA Product for TLS, Identity Product for authentication and authorization, and JOSE Product for API-based Encrypt/Decrypt JWE operations and Sign/Verify JWS operations.
- CA with Identity+JOSE: CA Product uses Identity Product for authentication and authorization, and JOSE Product for internal-based Encrypt/Decrypt JWE operations and Sign/Verify JWS operations.
- Identity with JOSE: Identity Product uses internal-based Encrypt/Decrypt JWE operations and Sign/Verify JWS operations.

## Microservices Architecture - CRITICAL

**MANDATORY: All Services in All Four Products MUST support Dual HTTPS**

- **HTTPS ONLY** - All Services MUST use TLS 1.3 by default; never use HTTP
- **HTTPS Certificates** - All Services MUST support configurable dynamic or static TLS server cert chains and private key:
  - Dynamic TLS server cert chain; leaf cert, intermediate CA certs, and root CA cert all auto-generated by a private CA scoped to per-Product or per-Suite.
  - Static TLS server cert cain; Docker Secrets for Private Keys, and Public File Paths or Public PEM data for TLS Server cert chain and Trusted CA certs
- **Private HTTPS Endpoint**: All Services MUST support configurable dynamic or static HTTPS port for administration-only
  - Default is 0 (dynamic port), can be set to a static port like 9090+
  - /admin/v1/** prefix for all endpoints: `/admin/v1/livez`, `/admin/v1/readyz`, `/admin/v1/healthz`, `/admin/v1/shutdown`
  - Not externally accessible; IPv4 127.0.0.1 only, never IPv6, never localhost
  - Used by Docker health checks, Kubernetes probes, monitoring, testing
- **Public HTTPS Endpoint**: All Services MUST support configurable dynamic or static HTTPS port for clients and users, but different prefixes and middlewares for browser-based vs non-browser-based clients
  - Default is 0 (dynamic port), can be set to a static port like 8080+
  - /service/** prefix for non-browser clients: Access token (HTTP Authorization header) enforces /service/ path prefix, and uses non-browser client middlewares (e.g. IP Allowlist, Rate Limiting)
  - /browser/** prefix for browser-based clients: Session token (HTTP Cookie header) enforces /browser/ path prefix, and browser-based client middleware (e.g. CSRF, CORS, CSP, IP Allowlist, Rate Limiting, etc)
  - /service/** access tokens must be obtained via OAuth 2.0 Client Authorization Flow; these are HTTP Authorization header bear tokens
  - /browser/** access tokens must be obtained via OAuth 2.0 Authorization Code + PKCE flow; these are HTTP Cookie header session tokens
  - /browser/**and /service/** must service the same APIs via a shared OpenAPI spec for API consistency, but under two different request paths with mutually exclusive access and middlewares
  - /browser/** must also service UI-only requests via HTML pages, JavaScript, CSS, images, fonts, etc
- **Example Dual Ports for Services** (Source: SPECKIT-CONFLICTS-ANALYSIS C4 answer D, 2025-12-19):
  - KMS:            Public HTTPS APIs/UI: 127.0.0.1:8080 (unit/integration tests) or 0.0.0.0:8080 (docker compose), Private HTTPS Admin: 127.0.0.1:9090
  - Identity AuthZ: Public HTTPS APIs/UI: 127.0.0.1:8180 (unit/integration tests) or 0.0.0.0:8180 (docker compose), Private HTTPS Admin: 127.0.0.1:9091
  - Identity IdP:   Public HTTPS APIs/UI: 127.0.0.1:8181 (unit/integration tests) or 0.0.0.0:8181 (docker compose), Private HTTPS Admin: 127.0.0.1:9091
  - Identity RS:    Public HTTPS APIs/UI: 127.0.0.1:8182 (unit/integration tests) or 0.0.0.0:8182 (docker compose), Private HTTPS Admin: 127.0.0.1:9091
  - Identity RP:    Public HTTPS APIs/UI: 127.0.0.1:8183 (unit/integration tests) or 0.0.0.0:8183 (docker compose), Private HTTPS Admin: 127.0.0.1:9091
  - Identity SPA:   Public HTTPS APIs/UI: 127.0.0.1:8184 (unit/integration tests) or 0.0.0.0:8184 (docker compose), Private HTTPS Admin: 127.0.0.1:9091
  - CA:             Public HTTPS APIs/UI: 127.0.0.1:8380 (unit/integration tests) or 0.0.0.0:8380 (docker compose), Private HTTPS Admin: 127.0.0.1:9092
  - JOSE:           Public HTTPS APIs/UI: 127.0.0.1:8280 (unit/integration tests) or 0.0.0.0:8280 (docker compose), Private HTTPS Admin: 127.0.0.1:9093

**Admin Port Assignments** (unique per product to prevent collisions in unified deployment):

- **KMS**: 9090 (all KMS instances share same admin port, bound to 127.0.0.1)
- **Identity**: 9091 (all 5 Identity services share same admin port)
- **CA**: 9092 (all CA instances share same admin port)
- **JOSE**: 9093 (all JOSE instances share same admin port)

**Rationale**: Admin ports bound to 127.0.0.1 only (not externally accessible). In Docker Compose, each service instance is a separate container with isolated network namespace, so same admin port (9090/9091/9092/9093) can be reused across instances of same product without collision.

IMPORTANT: Use 127.0.0.1 in unit/integration tests to avoid Windows Firewall exception popups

---

## Service Federation - CRITICAL

**MANDATORY: Services MUST support configurable federation for cross-service communication**

### Federation Configuration Pattern

Services discover and communicate with other cryptoutil services via configuration (NEVER hardcoded URLs):

```yaml
# Example KMS config with federation
federation:
  # Identity service for OAuth 2.1 authentication
  identity_url: "https://identity-authz:8180"
  identity_enabled: true
  identity_timeout: 10s

  # JOSE service for external JWE/JWS operations
  jose_url: "https://jose-server:8280"
  jose_enabled: true
  jose_timeout: 10s

  # CA service for TLS certificate operations
  ca_url: "https://ca-server:8380"
  ca_enabled: false  # Optional - KMS can use internal TLS certs
  ca_timeout: 10s

# Graceful degradation settings
federation_fallback:
  # When identity service unavailable
  identity_fallback_mode: "local_validation"  # or "reject_all", "allow_all" (dev only)

  # When JOSE service unavailable  
  jose_fallback_mode: "internal_crypto"  # Use internal JWE/JWS implementation

  # When CA service unavailable
  ca_fallback_mode: "self_signed"  # Generate self-signed TLS certs
```

### Service Discovery Mechanisms

**1. Configuration File (Preferred for Static Deployments)**:

```yaml
# Explicit URLs in config.yaml
federation:
  identity_url: "https://identity.example.com:8180"
  jose_url: "https://jose.example.com:8280"
```

**2. Docker Compose Service Names**:

```yaml
# Docker networks provide DNS resolution
federation:
  identity_url: "https://identity-authz:8180"  # Service name from compose.yml
  jose_url: "https://jose-server:8280"
```

**3. Kubernetes Service Discovery**:

```yaml
# Kubernetes DNS provides service resolution
federation:
  identity_url: "https://identity-authz.cryptoutil-ns.svc.cluster.local:8180"
  jose_url: "https://jose-server.cryptoutil-ns.svc.cluster.local:8280"
```

**4. Environment Variables (Docker Secrets Integration)**:

```bash
# Environment variables override config file
CRYPTOUTIL_FEDERATION_IDENTITY_URL="https://identity:8180"
CRYPTOUTIL_FEDERATION_JOSE_URL="https://jose:8280"
```

### Graceful Degradation Patterns

**Circuit Breaker**: Automatically disable federated service after N consecutive failures

```go
type CircuitBreaker struct {
    failureThreshold int       // Open circuit after N failures
    timeout          time.Duration // Reset circuit after timeout
    halfOpenRequests int       // Test N requests before closing circuit
}
```

**Fallback Modes**:

- **Identity Unavailable**: Local token validation (cached public keys), reject all (strict), allow all (development only)
- **JOSE Unavailable**: Internal crypto implementation (use KMS's own JWE/JWS)
- **CA Unavailable**: Self-signed TLS certificates (development), cached certificates (production)

**Retry Strategies**:

- **Exponential Backoff**: 1s, 2s, 4s, 8s, 16s (max 5 retries)
- **Timeout Escalation**: Increase timeout 1.5x per retry (10s → 15s → 22.5s)
- **Health Check Before Retry**: Poll `/admin/v1/healthz` endpoint before resuming traffic

### Federation Health Monitoring

**Regular Health Checks**:

```go
// Check federated service health every 30 seconds
ticker := time.NewTicker(30 * time.Second)
for range ticker.C {
    if err := checkFederatedServiceHealth(identityURL); err != nil {
        logger.Warn("identity service unhealthy", "error", err)
        // Activate fallback mode
    }
}
```

**Metrics and Alerts**:

- `federation_request_duration_seconds{service="identity"}` - Latency tracking
- `federation_request_failures_total{service="identity"}` - Error rate
- `federation_circuit_breaker_state{service="identity"}` - Circuit state (closed/open/half-open)

### Cross-Service Authentication

**Service-to-Service mTLS** (Preferred):

```yaml
federation:
  identity_url: "https://identity-authz:8180"
  identity_client_cert: "file:///run/secrets/kms_client_cert"
  identity_client_key: "file:///run/secrets/kms_client_key"
  identity_ca_cert: "file:///run/secrets/identity_ca_cert"
```

**OAuth 2.1 Client Credentials** (Alternative):

```yaml
federation:
  identity_url: "https://identity-authz:8180"
  identity_client_id: "kms-service"
  identity_client_secret: "file:///run/secrets/kms_client_secret"
  identity_token_endpoint: "https://identity-authz:8180/service/token"
```

### Federation Testing Requirements

**Integration Tests MUST**:

- Test each federated service independently (mock others)
- Test graceful degradation when federated service unavailable
- Test circuit breaker behavior (failure thresholds, timeouts, recovery)
- Test retry logic (exponential backoff, max retries)
- Verify timeout configurations prevent cascade failures

**E2E Tests MUST**:

- Deploy full stack (all federated services)
- Test cross-service communication paths
- Test federation with Docker Compose service discovery
- Verify health checks detect service failures
- Test failover and recovery scenarios
