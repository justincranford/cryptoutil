---
description: "Common anti-patterns and mistakes"
applyTo: "**"
---
# Anti Patterns

## CRITICAL Regression-Prone Areas

### Format_go Self-Modification - P0 INCIDENTS

**Root Cause**: LLM agents lose exclusion context during narrow-focus refactoring, inadvertently modifying self-exclusion patterns.

#### MANDATORY Prevention Rules

**NEVER DO**:

- ❌ Modify comments or test data in `enforce_any.go` without reading full package context
- ❌ Change `` `interface{}` `` to `` `any` `` in format_go package without verification
- ❌ Refactor code in isolation (single-file view)
- ❌ Simplify "verbose" CRITICAL comments without understanding purpose

**ALWAYS DO**:

- ✅ Read complete package context before refactoring self-modifying code
- ✅ Check for CRITICAL/SELF-MODIFICATION tags in comments
- ✅ Verify self-exclusion patterns exist and are respected
- ✅ Run tests after ANY changes to format_go package
- ✅ Grep for exclusion constants in `magic_cicd.go`

#### Pattern Recognition

**Indicators of Intentional Protection**:

- **CRITICAL comments**: High-priority annotations requiring preservation
- **Backticked strings** in code: `` `interface{}` `` → Prevents replacement by pattern matching
- **Test data patterns**: May use "wrong" values intentionally (e.g., `interface{}` as input to test replacement)
- **Self-exclusion constants**: `MagicCICDFilterExcludeEnforceAny` in `magic_cicd.go`

#### Code Archaeology Checklist

**Required Reading**: enforce_any.go, filter.go, magic_cicd.go, format_go_test.go, self_modification_test.go, docs/P0.*, git log

---

### SQLite Connection Pool Deadlocks - P0 INCIDENT

**Problem**: GORM transactions require multiple connections, `MaxOpenConns=1` causes deadlock.

**Rules**:

- ❌ NEVER set `MaxOpenConns=1` with GORM transactions
- ❌ NEVER use `sql.TxOptions{ReadOnly: true}` with SQLite (not supported)
- ✅ ALWAYS set `MaxOpenConns=5` (`cryptoutilMagic.SQLiteMaxOpenConnections`)
- ✅ ALWAYS enable WAL mode
- ✅ ALWAYS set busy timeout 30s (`cryptoutilMagic.DBSQLiteBusyTimeout`)

**Reference**: `internal/server/repository/sqlrepository/sql_provider.go` lines 201-213

---

### Docker Compose Port Conflicts - E2E FAILURES

**Problem**: Multiple services including same telemetry compose file cause host port conflicts.

**Rules**:

- ❌ NEVER expose container ports to host if multiple instances may run
- ✅ ALWAYS use container-to-container networking (no host port mappings)
- ✅ Services communicate via container names (e.g., `opentelemetry-collector-contrib:4317`)

**Detection**: "bind: address already in use" or "port is already allocated"

**Diagnosis**:

```bash
# Check what's using the port
netstat -ano | findstr "4317"  # Windows
lsof -i :4317                  # Linux/Mac

# Check included compose files
grep -r "ports:" deployments/*/compose.yml
```

**Fix**:

1. Remove host port mappings from shared compose files
2. Use container-to-container networking only
3. Update application configs to use container names
4. Test all E2E workflows in sequence to verify no conflicts

---

### Incomplete Service Implementation - WORKFLOW DEBUGGING

**Problem**: Missing public HTTP servers cause cascading configuration errors that mask root cause.

#### Root Cause

**Assumption Bias**: Assumed container crashes were ALWAYS configuration problems, not missing code.

#### Symptom Pattern

**Progressive Configuration Fixes with Zero Symptom Change**:

- Decreasing log bytes = earlier crash = deeper problem (NOT configuration)
- Same bytes despite valid fixes = implementation issue, NOT configuration

#### NEVER DO

❌ **Keep applying configuration fixes when symptoms don't change**
❌ **Assume container crash is always a configuration problem**
❌ **Debug configuration before verifying complete architecture exists**

#### ALWAYS DO

✅ **Code archaeology FIRST - compare with working service before debugging config**
✅ **Verify all required files exist** (server.go, application.go, admin.go)
✅ **Check Application.Start() initializes both public + admin servers**
✅ **Compare container log byte counts across fix attempts**

#### Detection Pattern

**Indicators of Missing Implementation**:

1. **Byte count pattern**: Same bytes across multiple fix rounds = no symptom change
2. **Error message pattern**: Early rounds show specific errors, later rounds show generic startup then silence
3. **File structure pattern**: Compare with working service - notice missing files

#### Time Wasted Pattern

- Configuration Debugging: 40-60 minutes (4-6 rounds × 10 minutes each)
- Code Archaeology Upfront: 9 minutes (download logs + compare architecture)

**Lesson**: Code archaeology should be FIRST step, NOT last resort

---

## Documentation Anti-Patterns

### Creating Standalone Session Documentation

**Problem**: Creating dated session documentation files leads to documentation bloat.

**Result**: 50+ session docs scattered across `docs/`, difficult to find historical context

#### NEVER DO

❌ **Create dated session documentation files** (docs/SESSION-*.md)
❌ **Create standalone analysis documents for session work**
❌ **Create separate work log files per session**

#### ALWAYS DO

✅ **See**: [01-03.speckit.instructions.md](.github/instructions/01-03.speckit.instructions.md) for documentation patterns
✅ **Create separate docs ONLY for permanent reference material** (ADRs, post-mortems, user guides)

#### Rule of Thumb

**Session-specific work** → Append to `DETAILED.md`

**Permanent reference** → Create dedicated doc:

- `docs/ADR-001-database-choice.md` (architectural decision)
- `docs/P0.1-format-go-regression.md` (post-mortem)
- `docs/USER-GUIDE.md` (user documentation)

---

## Architecture Anti-Patterns

### Missing Service Federation Configuration

**Problem**: Services don't know how to discover or communicate with federated services.

**Symptom**: Hardcoded service URLs in code, fails when service moves (e.g., cipher-im service in different namespace)

#### NEVER DO

❌ **Hardcode service URLs in application code**
❌ **Assume services are always co-located**

#### ALWAYS DO

✅ **Use configuration for service discovery** (YAML, environment, DNS)
✅ **Support multiple federation patterns** (DNS-based discovery, Config file URLs, Service mesh integration)
✅ **Implement graceful degradation when federated services unavailable**

#### Pattern

**Service A depends on Service B** → Configure B's URL in A's config, NOT hardcode

---

## Performance Anti-Patterns

### Mutation Testing Timeout (>45 minutes)

**Problem**: Running gremlins on entire codebase sequentially causes 45-minute timeouts.

**Symptom**: CI workflow exceeds job timeout, incomplete mutation coverage

#### NEVER DO

❌ **Run mutation testing on all packages sequentially**
❌ **Include test utilities and generated code in mutation scope**

#### ALWAYS DO

✅ **Parallelize by package using GitHub Actions matrix strategy**
✅ **Exclude tests, generated code, vendor directories**
✅ **Set per-job timeout (15 minutes max)**
✅ **Target <20 minutes total with parallel execution**

#### Optimization

**4-6 packages per parallel job**, focus on business logic only

**Expected Result**: Sequential 45 minutes → Parallel 15-20 minutes (2-3× speedup)

---

### Test Timing Violations (>15s per package)

**Problem**: Test packages taking >15 seconds due to exhaustive algorithm variant testing.

**Symptom**: `go test ./...` takes >180 seconds (violates target)

#### NEVER DO

❌ **Test every key size variant (RSA 2048/3072/4096) every time**
❌ **Use `TestProbAlways` for redundant variants**

#### ALWAYS DO

✅ **Use `TestProbTenth` (10%) or `TestProbQuarter` (25%) for algorithm variants**
✅ **Reserve `TestProbAlways` (100%) for base algorithms only**
✅ **Target <15s per unit test package, <180s full unit test suite**

#### Rationale

**Statistical Sampling**: Bugs eventually caught without running all variants every time

**Magic Constants**:

- `TestProbAlways = 100` (100%) - Base algorithms
- `TestProbQuarter = 25` (25%) - Important variants
- `TestProbTenth = 10` (10%) - Redundant variants

---

## Key Takeaways

### Context Reading - CRITICAL

**ALWAYS read complete context before refactoring self-modifying code**. Check for CRITICAL tags, self-exclusion patterns, test validation patterns.

### Windows Firewall - CRITICAL

**ALWAYS bind to 127.0.0.1 in tests** (NEVER 0.0.0.0). Use 0.0.0.0 ONLY in Docker containers (isolated namespace).

### Port Conflicts - CRITICAL

**Remove host port mappings for shared services in Docker Compose**. Use container-to-container networking only.

### Mutation Parallelization - PERFORMANCE

**NEVER run sequentially** - use GitHub Actions matrix. 4-6 packages per job, <20 minutes total.

### Test Timeouts - COMPATIBILITY

**ALWAYS increase timeouts 10× for race detector mode**. Race detector overhead ~10× normal execution.

### Port Conflicts - CRITICAL

**Remove host port mappings for shared services in Docker Compose**. Use container-to-container networking only.

### Mutation Parallelization - PERFORMANCE

**NEVER run sequentially** - use GitHub Actions matrix. 4-6 packages per job, <20 minutes total.

### Test Timeouts - COMPATIBILITY

**ALWAYS increase timeouts 10× for race detector mode**. Race detector overhead ~10× normal execution.

---

## Cross-References

**Related Documentation**: coding.md (format_go protection patterns), security.md (Windows Firewall prevention), sqlite-gorm.md (SQLite configuration), docker.md (Docker Compose patterns), testing.md (testing standards), git.md (git workflow), docs/WORKFLOW-FIXES-CONSOLIDATED.md (workflow debugging), docs/P0.* files (post-mortems)
