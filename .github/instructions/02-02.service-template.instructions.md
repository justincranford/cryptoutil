---
description: "Service template requirements and patterns for all cryptoutil services"
applyTo: "**"
---
# Service Template

---

description: "Service template requirements and patterns for all cryptoutil services"
applyTo: "**"
---

# Service Template - Tactical Guidance

**This file contains ONLY tactical implementation patterns**

## Template Components Quick Reference

- **Two HTTPS Servers**: Public (business) + Admin (health checks)
- **Two Public Paths**: `/browser/**` (sessions) vs `/service/**` (tokens)
- **Three Admin APIs**: `/admin/v1/livez`, `/admin/v1/readyz`, `/admin/v1/shutdown`
- **Database**: PostgreSQL || SQLite with GORM
- **Telemetry**: OTLP → otel-collector-contrib → Grafana LGTM
- **Config**: Docker secrets + YAML + CLI parameters

## Migration Priority

learn-im FIRST (validate template) → jose-ja → pki-ca → identity services → sm-kms LAST

## NEVER DO

- ❌ Copy-paste service infrastructure code
- ❌ Duplicate dual-server, health checks, shutdown logic
- ❌ Reimplement middleware, telemetry, crypto, GORM setup

## Overview

**CRITICAL: NEVER duplicate service infrastructure code - ALWAYS use extracted template**

All cryptoutil services MUST use shared service template for consistency, reduced duplication, quality across 9 services.

## Template Components

**Template extracted from KMS reference implementation**:

**1. Two HTTPS Servers**: Public (client access) + Private (admin operations). See `02-03.https-ports.instructions.md`

**2. Two Public API Paths**:

- **`/browser/api/v1/*`**: Session-based auth (browsers) - CSRF, CORS, CSP middleware
- **`/service/api/v1/*`**: Token-based auth (headless) - IP allowlist, rate limiting

**3. Three Private APIs**:

- **`/admin/v1/livez`**: Liveness (process alive, lightweight, K8s liveness probe)
- **`/admin/v1/readyz`**: Readiness (dependencies healthy, heavyweight, K8s readiness probe)
- **`/admin/v1/shutdown`**: Graceful shutdown (drain connections, close resources)

**4. Database Abstraction**: PostgreSQL || SQLite dual support, GORM ORM, embedded migrations, connection pooling. See `03-04.database.instructions.md`, `03-05.sqlite-gorm.instructions.md`

**5. OpenTelemetry Integration**: OTLP export (traces, metrics, logs to otel-collector-contrib), structured logging, Prometheus metrics, trace propagation. See `02-05.observability.instructions.md`

**6. Config Management**: YAML files (primary), CLI flags (overrides), Docker secrets (`file://` pattern), NO environment variables for secrets. See `04-02.docker.instructions.md`

## Template Parameterization

### Constructor Injection Pattern

```go
type ServiceTemplate struct {
    Config         *ServiceConfig
    Handlers       HandlerRegistry
    Middleware     MiddlewareChain
    OpenAPISpec    *openapi3.T
}

func NewService(config *ServiceConfig, handlers HandlerRegistry) (*ServiceTemplate, error) {
    // Inject parameters for configuration, handlers, middleware
    // Business logic separated from infrastructure concerns
}
```

### Service-Specific Customization

- **OpenAPI specs**: Service-specific endpoints, models, paths
- **Business logic handlers**: Injected via handler registry
- **Middleware customization**: Additional service-specific middleware
- **Database schema**: Service-specific tables, migrations

## Mandatory Usage Rules

### MUST DO

- ✅ Extract reusable template before implementing new services
- ✅ ALL new services MUST use template (consistency, reduced duplication)
- ✅ ALL existing services MUST be refactored to use template (iterative migration)
- ✅ Template success criteria: learn-im service validates template works

### NEVER DO

- ❌ Copy-paste service infrastructure code between services
- ❌ Duplicate dual-server pattern, health checks, shutdown logic
- ❌ Reimplement middleware pipeline, telemetry integration, crypto, sql/gorm setup

### Migration Validation

**Template success criteria (learn-im service)**:

1. Implements ALL template requirements (dual HTTPS, health checks, config, telemetry)
2. Passes all unit/integration/e2e tests
3. Passes all CI/CD workflows
4. Deep analysis shows NO blockers to migrate existing services
5. Documentation demonstrates template reusability

## Service Template Migration Priority

**HIGH PRIORITY phased migration**:

### Phase 1: learn-im FIRST - CRITICAL

- - **Success Criteria**: Passes all tests, workflows, no migration blockers
- **Timeline**: Complete before production service migrations

### Phase 2: One Service at a Time (excludes sm-kms)

- **Migration Order**: jose-ja → pki-ca → identity services
- **Pattern**: Sequential refactoring, full test validation per service
- **Rollback**: Keep original code until new template implementation validated

### Phase 3: sm-kms LAST

- **Reason**: Most mature service, used as template extraction source
- **Timing**: Only after ALL other services running excellently on template
- **Benefit**: Validates template handles all edge cases before touching reference implementation

## Key Takeaways

1. **Single Template**: Extract from KMS, reuse for all services (9 services total)
2. **Dual HTTPS**: Public (business) + Admin (health checks) servers mandatory
3. **Dual Paths**: `/browser/**` (session-based) vs `/service/**` (token-based)
4. **Health Checks**: Liveness (process alive) vs Readiness (dependencies healthy)
5. **Migration Priority**: learn-im first (validation), production services sequential, sm-kms last
6. **Zero Duplication**: Template parameterization prevents code duplication across services
