---
description: "Service template requirements"
applyTo: "**"
---
# Service Template

# Service Template - Tactical Guidance

## Template Components Quick Reference

- **Two HTTPS Servers**: Public (business) + Admin (health checks)
- **Two Public Paths**: `/browser/**` (sessions) vs `/service/**` (tokens)
- **Three Admin APIs**: `/admin/api/v1/livez`, `/admin/api/v1/readyz`, `/admin/api/v1/shutdown`
- **Database**: PostgreSQL || SQLite with GORM
- **Telemetry**: OTLP → otel-collector-contrib → Grafana LGTM
- **Config**: Docker secrets + YAML + CLI parameters

## Migration Priority

cipher-im FIRST (validate template) → jose-ja → pki-ca → identity services → sm-kms LAST

## Key Rotation Pattern - MANDATORY

**Per-Message Key Rotation**: ALL services MUST rotate keys per message (new JWK per message)
**Storage Pattern**: Domain-specific table for JWKs, encrypted with Barrier service before storage
**Rationale**: Most secure pattern - limits key exposure to single message

## CRITICAL: Autonomous Execution - NEVER ASK PERMISSION

**MANDATORY: ALWAYS proceed with next logical step WITHOUT asking user**

- ❌ NEVER ask "Should I proceed with X?"
- ❌ NEVER ask "Do you want me to continue?"
- ❌ NEVER ask "Shall I modify Y?"
- ❌ NEVER present options and wait for user choice
- ❌ NEVER pause between tasks for confirmation
- ✅ ALWAYS execute next logical step immediately
- ✅ ALWAYS make decisions autonomously based on context
- ✅ ALWAYS continue until ALL tasks complete or user clicks STOP

**Pattern**: Complete current task → Commit → IMMEDIATELY start next task (ZERO text asking permission)

**See**: `01-02.continuous-work.instructions.md` for complete autonomous execution patterns

## NEVER DO

- ❌ Copy-paste service infrastructure code
- ❌ Duplicate dual-server, health checks, shutdown logic
- ❌ Reimplement middleware, telemetry, crypto, GORM setup
- ❌ Ask permission to continue work
- ❌ Stop to wait for user approval between tasks

## Overview

**CRITICAL: NEVER duplicate service infrastructure code - ALWAYS use extracted template**

All cryptoutil services MUST use shared service template for consistency, reduced duplication, quality across 9 services.

## Template Components

**Template extracted from KMS reference implementation**:

**1. Two HTTPS Servers**: Public (client access) + Private (admin operations). See [02-03.https-ports.instructions.md](.github/instructions/02-03.https-ports.instructions.md)

**2. Two Public API Paths**:

- **`/browser/api/v1/*`**: Session-based auth (browsers) - CSRF, CORS, CSP middleware
- **`/service/api/v1/*`**: Token-based auth (headless) - IP allowlist, rate limiting

**3. Three Private APIs**:

- **`/admin/api/v1/livez`**: Liveness (process alive, lightweight, K8s liveness probe)
- **`/admin/v1/readyz`**: Readiness (dependencies healthy, heavyweight, K8s readiness probe)
- **`/admin/v1/shutdown`**: Graceful shutdown (drain connections, close resources)

**4. Database Abstraction**: PostgreSQL || SQLite dual support, GORM ORM, embedded migrations, connection pooling. See [03-04.database.instructions.md](.github/instructions/03-04.database.instructions.md), [03-05.sqlite-gorm.instructions.md](.github/instructions/03-05.sqlite-gorm.instructions.md)

**5. OpenTelemetry Integration**: OTLP export (traces, metrics, logs to otel-collector-contrib), structured logging, Prometheus metrics, trace propagation. See [02-05.observability.instructions.md](.github/instructions/02-05.observability.instructions.md)

**6. Config Management**: YAML files (primary), CLI flags (overrides), Docker secrets (`file://` pattern), NO environment variables for secrets. See [04-02.docker.instructions.md](.github/instructions/04-02.docker.instructions.md)

## Template Parameterization

### Constructor Injection Pattern

```go
type ServiceTemplate struct {
    Config         *ServiceConfig
    Handlers       HandlerRegistry
    Middleware     MiddlewareChain
    OpenAPISpec    *openapi3.T
}

func NewService(config *ServiceConfig, handlers HandlerRegistry) (*ServiceTemplate, error) {
    // Inject parameters for configuration, handlers, middleware
    // Business logic separated from infrastructure concerns
}
```

### Service-Specific Customization

- **OpenAPI specs**: Service-specific endpoints, models, paths
- **Business logic handlers**: Injected via handler registry
- **Middleware customization**: Additional service-specific middleware
- **Database schema**: Service-specific tables, migrations

## Mandatory Usage Rules

### MUST DO

- ✅ Extract reusable template before implementing new services
- ✅ ALL new services MUST use template (consistency, reduced duplication)
- ✅ ALL existing services MUST be refactored to use template (iterative migration)
- ✅ Template success criteria: cipher-im service validates template works

### NEVER DO

- ❌ Copy-paste service infrastructure code between services
- ❌ Duplicate dual-server pattern, health checks, shutdown logic
- ❌ Reimplement middleware pipeline, telemetry integration, crypto, sql/gorm setup

### Migration Validation

**Template success criteria (cipher-im service)**:

1. Implements ALL template requirements (dual HTTPS, health checks, config, telemetry)
2. Passes all unit/integration/e2e tests
3. Passes all CI/CD workflows
4. Deep analysis shows NO blockers to migrate existing services
5. Documentation demonstrates template reusability

## Service Template Migration Priority

cipher-im FIRST (validation) → production services sequential → sm-kms LAST

## Key Takeaways

1. **Single Template**: Extract from KMS, reuse for all services (9 services total)
2. **Dual HTTPS**: Public (business) + Admin (health checks) servers mandatory
3. **Dual Paths**: `/browser/**` (session-based) vs `/service/**` (token-based)
4. **Health Checks**: Liveness (process alive) vs Readiness (dependencies healthy)
5. **Migration Priority**: cipher-im first (validation), production services sequential, sm-kms last
6. **Zero Duplication**: Template parameterization prevents code duplication across services
