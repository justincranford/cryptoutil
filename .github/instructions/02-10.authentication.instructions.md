---
description: "Authentication and authorization architecture, factor lists, storage realms, session patterns"
applyTo: "**"
---
# Authentication and Authorization - CRITICAL

## Single Factor Authentication Methods - MANDATORY

**CRITICAL: All services MUST support configured authentication factors with specified storage realms**

### Headless-Based Clients (10 Methods)

**Request Path**: `/service/**` paths only

**Non-Federated Methods** (3):

| Method | Storage Realm | Priority | Description |
|--------|---------------|----------|-------------|
| **Basic (Client ID/Secret)** | YAML + SQL | Config > DB | HTTP Basic authentication with client credentials |
| **Bearer (API Token)** | YAML + SQL | Config > DB | Bearer token authentication (API keys) |
| **HTTPS Client Certificate** | YAML + SQL | Config > DB | mTLS client certificate authentication |

**Federated Methods** (7):

| Method | Storage Realm | Priority | Description |
|--------|---------------|----------|-------------|
| **Basic (Client ID/Secret)** | YAML + SQL | Config > DB | HTTP Basic with OAuth 2.1 client credentials |
| **Bearer (API Token)** | YAML + SQL | Config > DB | Bearer token from external OAuth 2.1 provider |
| **HTTPS Client Certificate** | YAML + SQL | Config > DB | mTLS with OAuth 2.1 service-to-service |
| **JWE Access Token** | YAML + SQL | Config > DB | JSON Web Encryption access tokens |
| **JWS Access Token** | YAML + SQL | Config > DB | JSON Web Signature access tokens |
| **Opaque Access Token** | YAML + SQL | Config > DB | Non-JWT access tokens |
| **Opaque Refresh Token** | YAML + SQL | Config > DB | Non-JWT refresh tokens |

### Browser-Based Clients (28 Methods)

**Request Path**: `/browser/**` paths only

**Non-Federated Methods** (6):

| Method | Storage Realm | Priority | Description |
|--------|---------------|----------|-------------|
| **JWE Session Cookie** | YAML + SQL | Config > DB | Encrypted session cookie (JSON Web Encryption) |
| **JWS Session Cookie** | YAML + SQL | Config > DB | Signed session cookie (JSON Web Signature) |
| **Opaque Session Cookie** | YAML + SQL | Config > DB | Non-JWT session cookie |
| **Basic (Username/Password)** | YAML + SQL | Config > DB | HTTP Basic authentication with user credentials |
| **Bearer (API Token)** | YAML + SQL | Config > DB | Bearer token authentication |
| **HTTPS Client Certificate** | YAML + SQL | Config > DB | mTLS client certificate authentication |

**Federated Methods** (22):

All non-federated methods (6) PLUS:

| Method | Storage Realm | Priority | Description |
|--------|---------------|----------|-------------|
| **TOTP (Authenticator App)** | SQL ONLY | DB-only | Time-based One-Time Password (Google Authenticator, Authy) |
| **HOTP (Hardware Token)** | SQL ONLY | DB-only | HMAC-based One-Time Password (YubiKey, RSA SecurID) |
| **Recovery Codes** | SQL ONLY | DB-only | Backup single-use recovery codes |
| **WebAuthn with Passkeys** | SQL ONLY | DB-only | FIDO2 WebAuthn with platform authenticators (Face ID, Touch ID, Windows Hello) |
| **WebAuthn without Passkeys** | SQL ONLY | DB-only | FIDO2 WebAuthn with security keys (YubiKey, Titan Key) |
| **Push Notification** | SQL ONLY | DB-only | Mobile app push-based authentication |
| **Email/Password** | YAML + SQL | Config > DB | Email address + password authentication |
| **Magic Link (Email)** | SQL ONLY | DB-only | Passwordless email-based authentication |
| **Magic Link (SMS)** | SQL ONLY | DB-only | Passwordless SMS-based authentication |
| **Random OTP (Email)** | SQL ONLY | DB-only | One-time password sent via email |
| **Random OTP (SMS)** | SQL ONLY | DB-only | One-time password sent via SMS |
| **Random OTP (Phone)** | SQL ONLY | DB-only | One-time password sent via voice call |
| **Social Login (Google)** | YAML + SQL | Config > DB | OAuth 2.0 with Google Identity Platform |
| **Social Login (Microsoft)** | YAML + SQL | Config > DB | OAuth 2.0 with Microsoft Identity Platform |
| **Social Login (GitHub)** | YAML + SQL | Config > DB | OAuth 2.0 with GitHub |
| **Social Login (Facebook)** | YAML + SQL | Config > DB | OAuth 2.0 with Facebook |
| **Social Login (Apple)** | YAML + SQL | Config > DB | OAuth 2.0 with Sign in with Apple |
| **Social Login (LinkedIn)** | YAML + SQL | Config > DB | OAuth 2.0 with LinkedIn |
| **Social Login (Twitter/X)** | YAML + SQL | Config > DB | OAuth 2.0 with Twitter/X |
| **Social Login (Amazon)** | YAML + SQL | Config > DB | OAuth 2.0 with Amazon Login |
| **Social Login (Okta)** | YAML + SQL | Config > DB | OAuth 2.0 with Okta Identity Cloud |
| **SAML 2.0** | YAML + SQL | Config > DB | SAML 2.0 federated authentication |

### Storage Realm Priority - CRITICAL

**Config (YAML) > SQL (GORM) disaster recovery pattern**:

- **Primary**: YAML configuration files (fast, no database dependency)
- **Fallback**: SQL database via GORM (distributed disaster recovery)
- **Rationale**: Configuration files enable service startup even if database unavailable

**YAML + SQL Realms**:

- Credentials stored in BOTH configuration files AND database
- Service attempts YAML first, falls back to SQL if YAML unavailable
- Updates written to BOTH realms for consistency

**SQL ONLY Realms**:

- Credentials stored ONLY in database (no YAML support)
- User-specific data requiring persistence (TOTP secrets, WebAuthn credentials, recovery codes)
- Cannot be pre-configured in YAML (dynamic per-user enrollment)

### Multi-Factor Authentication (MFA) - CRITICAL

**MANDATORY: Services MUST support combining 2+ single factors for MFA**

**Common MFA Combinations**:

- **Browser + TOTP**: Password + Authenticator App (most common)
- **Browser + WebAuthn**: Password + Security Key
- **Browser + Push**: Password + Mobile App Push
- **Browser + OTP**: Password + SMS/Email OTP
- **Headless + mTLS**: Client ID/Secret + TLS Client Certificate
- **Headless + Bearer**: Client ID/Secret + API Token

**MFA Step-Up Authentication** (Time-Based):

- Re-authentication MANDATORY every 30 minutes for sensitive resources
- Applies regardless of operation type
- Session remains valid for low-sensitivity operations
- Configurable per resource sensitivity level

**MFA Enrollment Workflow** (Optional with Limited Access):

- OPTIONAL enrollment during initial setup
- Access LIMITED to low-sensitivity resources until additional factors enrolled
- Only one identifying factor required for initial login
- Admin configures minimum factors required per resource sensitivity

### Session Token Format - CRITICAL

**Configuration-Driven Selection**:

- **Non-Federated mode**: Product-specific config determines format (opaque, JWE, JWS)
- **Federated mode**: Identity Provider config determines format
- Admin configures via YAML or environment variable

**Supported Formats**:

| Format | Description | Use Case |
|--------|-------------|----------|
| **Opaque** | Random UUID, server-side lookup | Maximum security, no token inspection |
| **JWE** | Encrypted JWT | Stateless, encrypted claims |
| **JWS** | Signed JWT | Stateless, inspectable claims |

**Example Configuration**:

```yaml
identity:
  session:
    token_format: "jwe"  # opaque, jwe, or jws
    token_ttl: 3600      # 1 hour
    refresh_ttl: 604800  # 7 days
```

### Session Storage Backend - CRITICAL

**Supported Backends**:

- **SQLite**: Single-node deployments, development, testing
- **PostgreSQL**: Distributed/high-availability deployments with shared session data

**NEVER SUPPORTED**:

- ❌ Redis (BANNED - adds operational complexity)
- ❌ Memcached (BANNED - volatile storage unsuitable for sessions)
- ❌ In-memory (BANNED - lost on restart, breaks multi-instance deployments)

**Rationale**: SQLite/PostgreSQL provide ACID guarantees, persistence, and consistency.

### Realm Failover Behavior - CRITICAL

**Priority List Pattern**:

Admin configures priority list of Realm+Type tuples:

```yaml
authentication:
  realm_failover:
    - realm: file
      type: yaml
      path: /etc/cryptoutil/credentials.yaml
    - realm: database
      type: postgresql
      dsn: postgres://user:pass@host/db
    - realm: database
      type: sqlite
      path: /var/lib/cryptoutil/credentials.db
```

**Failover Logic**:

- System tries each realm in priority order until success or all fail
- First successful authentication wins
- No realm caching (always re-evaluate on next request)

### Zero Trust Authorization - CRITICAL

**MANDATORY: Authorization MUST be evaluated on EVERY request**

- ❌ **NO caching of authorization decisions** (prevents stale permissions)
- ✅ **Always fetch latest permissions from database**
- ✅ **Performance via efficient policy evaluation, NOT caching**

**Cross-Service Authorization** (Direct Token Validation):

- Session Token passed between federated services
- Each service independently validates token AND enforces authorization
- NO token transformation or delegation
- NO trust-on-first-use patterns

**Consent Tracking Granularity** (Scope+Resource Tuples):

- Tracked as `(scope, resource)` tuples
- Example: `("read:keys", "key-123")` separate from `("read:keys", "key-456")`
- User grants consent per scope+resource combination

---

## Authorization Methods - MANDATORY

### Headless-Based Clients (2 Methods)

| Method | Description | Use Case |
|--------|-------------|----------|
| **Scope-Based Authorization** | OAuth 2.1 scopes (read:keys, write:keys) | API access control |
| **RBAC** | Role-Based Access Control (admin, operator, viewer) | Service-to-service permissions |

### Browser-Based Clients (4 Methods)

| Method | Description | Use Case |
|--------|-------------|----------|
| **Scope-Based Authorization** | OAuth 2.1 scopes | API access control |
| **RBAC** | Role-Based Access Control | User role permissions |
| **Resource-Level Access Control** | Per-resource ownership and ACLs | User-owned resources |
| **Consent Tracking** | (scope, resource) tuples | User consent management |

---

## Implementation Patterns - MANDATORY

### Middleware Stack Pattern

**Service-to-Service APIs** (`/service/**` prefix):

```go
// Middleware chain for headless clients
serviceRouter.Use(
    ipAllowlistMiddleware,     // IP/CIDR allowlist
    rateLimitMiddleware,        // Per-IP rate limiting
    tokenValidationMiddleware,  // Validate Bearer/mTLS
    scopeAuthzMiddleware,       // Scope-based authorization
    requestLoggingMiddleware,   // Audit log
)
```

**Browser-to-Service APIs** (`/browser/**` prefix):

```go
// Middleware chain for browser clients
browserRouter.Use(
    ipAllowlistMiddleware,      // IP/CIDR allowlist
    corsMiddleware,             // CORS policies
    csrfMiddleware,             // CSRF protection
    cspMiddleware,              // Content Security Policy headers
    rateLimitMiddleware,        // Per-IP rate limiting
    sessionValidationMiddleware, // Validate session cookie
    resourceAuthzMiddleware,    // Resource-level authorization
    requestLoggingMiddleware,   // Audit log
)
```

### Configuration File Pattern

**YAML Configuration Example**:

```yaml
# Authentication configuration
authentication:
  # Headless client methods
  headless:
    enabled_methods:
      - basic_client_credentials
      - bearer_api_token
      - https_client_certificate
    storage:
      primary: yaml
      fallback: postgresql

  # Browser client methods
  browser:
    enabled_methods:
      - jwe_session_cookie
      - basic_username_password
      - totp
      - webauthn_passkeys
    storage:
      primary: yaml
      fallback: postgresql

    # MFA configuration
    mfa:
      step_up_interval: 1800  # 30 minutes
      required_factors: 2
      enrollment_optional: true

# Authorization configuration
authorization:
  mode: zero_trust  # Never cache decisions
  consent_tracking: true
  scope_granularity: resource  # Per-resource scopes

# Session configuration
session:
  token_format: jwe  # opaque, jwe, or jws
  storage_backend: postgresql  # sqlite or postgresql
  ttl: 3600          # 1 hour
  refresh_ttl: 604800 # 7 days

# Realm failover
realm_failover:
  - realm: file
    type: yaml
    path: /etc/cryptoutil/auth.yaml
  - realm: database
    type: postgresql
  - realm: database
    type: sqlite
```

---

## Testing Requirements - MANDATORY

**Authentication Tests MUST**:

- Test all 10 headless + 28 browser authentication methods
- Verify storage realm failover (YAML → PostgreSQL → SQLite)
- Verify MFA combinations (2-factor, 3-factor)
- Test step-up authentication timing (30-minute intervals)
- Test enrollment workflows (optional with limited access)

**Authorization Tests MUST**:

- Test Zero Trust evaluation (no caching)
- Test cross-service token validation
- Test consent tracking (scope+resource tuples)
- Test realm failover behavior

**Coverage Targets**:

- Authentication handlers: ≥95% coverage
- Authorization middleware: ≥95% coverage
- Realm failover logic: ≥98% coverage (infrastructure)

---

## Migration Checklist - MANDATORY

**When implementing authentication/authorization**:

- [ ] Define supported authentication factors (headless + browser)
- [ ] Configure storage realms (YAML + SQL with failover)
- [ ] Implement middleware stacks (`/service/**` vs `/browser/**`)
- [ ] Configure session token format and storage backend
- [ ] Implement MFA step-up and enrollment workflows
- [ ] Configure realm failover priority list
- [ ] Implement Zero Trust authorization (no caching)
- [ ] Add consent tracking for scope+resource tuples
- [ ] Write tests for all authentication methods
- [ ] Write tests for authorization policies
- [ ] Document authentication factor configuration in deployment guides

---

## Key Takeaways

1. **10 headless + 28 browser authentication methods** - Comprehensive factor support
2. **YAML + SQL storage with Config > DB priority** - Disaster recovery pattern
3. **Zero Trust authorization** - NO caching, always re-evaluate permissions
4. **MFA step-up every 30 minutes** - Time-based re-authentication for sensitive resources
5. **Session format configurable** - Opaque, JWE, or JWS tokens
6. **PostgreSQL/SQLite session storage** - NO Redis/Memcached
7. **Realm failover with priority list** - Try YAML → PostgreSQL → SQLite
8. **Consent tracking at scope+resource granularity** - Fine-grained user consent
