---
description: Integration test pattern using TestMain for GORM databases
applyTo: "**"
---

# TestMain Integration Pattern

## CRITICAL RULES

- **ALWAYS use TestMain pattern for integration tests with GORM databases to set up a single full working instance of a product-service per package (for happy-path integration).**
- **ALL unit and integration test functions that test Fiber HTTP handlers (happy-path or sad-path) MUST use Fiber's `app.Test()` for in-memory handler testing.**
- **NEVER start real HTTPS servers or bind to network ports in any unit or integration test.**
- **NEVER create GORM mocking infrastructure (interfaces, mocks) for integration tests.**

## Required Pattern

```go
var (
    testDB     *gorm.DB
    testSQLDB  *sql.DB
    testServer *Server
)

func TestMain(m *testing.M) {
    // Setup heavyweight resources ONCE
    ctx := context.Background()
    sqlDB, _ := sql.Open("sqlite", ":memory:")
    testSQLDB = sqlDB
    testDB, _ = gorm.Open(sqlite.Dialector{Conn: testSQLDB}, &gorm.Config{})

    // Run migrations
    testDB.AutoMigrate(&Model{})

    // Start server (for full instance setup only, NOT for handler tests)
    testServer, _ = NewServer(testDB)
    go testServer.Start()
    defer testServer.Shutdown(ctx)

    exitCode := m.Run()
    testSQLDB.Close()
    os.Exit(exitCode)
}

func TestSomething(t *testing.T) {
    // Use shared testDB - NO per-test setup
    // Use UUIDv7 for orthogonal test data
    id := googleUuid.NewV7()
    err := testServer.Create(ctx, &Model{ID: id})
    require.NoError(t, err)
}

// Handler tests (unit or integration) MUST use in-memory app.Test()
func TestHealthcheck_Handler(t *testing.T) {
    t.Parallel()

    app := fiber.New(fiber.Config{
        DisableStartupMessage: true,
    })
    app.Get("/admin/api/v1/livez", func(c *fiber.Ctx) error {
        return c.JSON(fiber.Map{"status": "alive"})
    })
    req := httptest.NewRequest("GET", "/admin/api/v1/livez", nil)
    resp, err := app.Test(req, -1)
    require.NoError(t, err)
    defer resp.Body.Close()
    require.Equal(t, 200, resp.StatusCode)
}
```

## FORBIDDEN Patterns

- Starting real HTTPS servers or binding to network ports in any unit or integration test
- Using TestMain to start a real server for handler tests (use only for instance setup)
- Per-test DB creation (repeated overhead)
- Creating GORM mocking infrastructure for integration tests

```go
//  WRONG - per-test DB creation
func setupTestDB(t *testing.T) *gorm.DB {
    db := createDatabase()
    return db
}

func TestSomething(t *testing.T) {
    db := setupTestDB(t)  //  Repeated overhead
}
```

## When to Use TestMain

- Integration tests with GORM repositories
- API tests requiring full server (for happy-path integration only)
- Service tests with database dependencies
- Any test requiring >100ms setup

## When to Use app.Test()

- ALL unit and integration handler tests (happy-path or sad-path)
- Middleware and endpoint validation
- Any test that exercises HTTP handlers

## Correct Examples

- internal/apps/template/service/server/apis/test_main_test.go
- internal/apps/jose/ja/service/testmain_test.go
- internal/apps/cipher/im/repository/testmain_test.go

## Database Error Testing

NO mocking needed - use real database constraints:

```go
func TestCreate_DuplicateKey(t *testing.T) {
    id := googleUuid.NewV7()
    testRepo.Create(ctx, &Model{ID: id})

    // Real constraint violation
    err := testRepo.Create(ctx, &Model{ID: id})
    require.Error(t, err)
}
```
