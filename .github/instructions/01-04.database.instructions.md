---
description: "Instructions for database operations and ORM patterns"
applyTo: "**"
---
# Database and ORM Instructions

- Use [GORM ORM](https://gorm.io/) (never sql.DB directly)
- Use transactions, error mapping, migrations, pooling, pagination, filters, UUIDv7 PKs, FKs, debug logging as needed
- Implement proper error mapping from GORM errors to application HTTP errors in `toAppErr` methods
- Use embedded SQL migrations with golang-migrate for schema changes
- Support both PostgreSQL (production) and SQLite (development/testing) backends
- Always apply database migrations on startup
- Use proper pagination with offset/limit patterns for large result sets
- Log database schema information in debug mode for troubleshooting

## Cross-Database Compatibility - CRITICAL

### UUID Type Handling

**SQLite does not support native UUID type - ALWAYS use TEXT:**

```go
// CORRECT for cross-DB compatibility (PostgreSQL and SQLite)
ID googleUuid.UUID `gorm:"type:text;primaryKey"`

// WRONG - breaks SQLite
ID googleUuid.UUID `gorm:"type:uuid;primaryKey"`
```

**Why:** SQLite lacks native UUID type. PostgreSQL supports both UUID and TEXT for UUIDs, so TEXT works everywhere.

### Nullable UUID Foreign Keys

**Use NullableUUID type for optional UUID foreign keys:**

```go
// Domain model (internal/identity/domain/nullable_uuid.go)
type NullableUUID struct {
    UUID  googleUuid.UUID
    Valid bool
}

// Implements sql.Scanner and driver.Valuer for proper NULL handling

// Usage in domain models
ClientProfileID NullableUUID `gorm:"type:text;index"`

// WRONG - pointer UUIDs cause "row value misused" errors in SQLite
ClientProfileID *googleUuid.UUID `gorm:"type:text;index"`
```

**Why:** Pointer UUIDs (`*googleUuid.UUID`) don't serialize correctly to TEXT columns in SQLite with GORM, causing "SQL logic error: row value misused" errors.

### JSON Array/Object Fields

**ALWAYS use `serializer:json` instead of `type:json` for cross-DB compatibility:**

```go
// CORRECT for cross-DB compatibility
AllowedScopes []string `gorm:"serializer:json" json:"allowed_scopes"`
MFAChain      []string `gorm:"serializer:json" json:"mfa_chain"`

// WRONG - breaks SQLite (no native JSON type)
AllowedScopes []string `gorm:"type:json" json:"allowed_scopes"`
```

**Why:**
- SQLite lacks native JSON type (stores as TEXT)
- PostgreSQL has native JSON/JSONB types
- `serializer:json` tells GORM to handle JSON encoding/decoding for TEXT columns
- `type:json` tells GORM to use native JSON type (fails on SQLite with "row value misused")

### SQL Migration Schema Consistency

**Ensure GORM annotations match SQL migration column types:**

```sql
-- SQLite migration (0001_init.up.sql)
CREATE TABLE clients (
    id TEXT PRIMARY KEY,
    allowed_scopes TEXT DEFAULT '[]',  -- JSON array as TEXT
    client_profile_id TEXT              -- Nullable UUID as TEXT
);
```

```go
// Domain model MUST match migration types
type Client struct {
    ID              googleUuid.UUID `gorm:"type:text;primaryKey"`
    AllowedScopes   []string        `gorm:"serializer:json"`
    ClientProfileID NullableUUID    `gorm:"type:text;index"`
}
```

**Why:** Type mismatches between GORM annotations and SQL schema cause runtime errors.

## SQLite Concurrent Write Operations - CRITICAL

**ALWAYS configure these SQLite settings to handle concurrent writes and parallel testing:**

### Required PRAGMA Settings

```go
// Enable WAL mode for better concurrency (allows multiple readers + 1 writer)
if _, err := sqlDB.Exec("PRAGMA journal_mode=WAL;"); err != nil {
    return fmt.Errorf("failed to enable WAL mode: %w", err)
}

// Set busy timeout for handling concurrent write operations (30 seconds)
if _, err := sqlDB.Exec("PRAGMA busy_timeout = 30000;"); err != nil {
    return fmt.Errorf("failed to set busy timeout: %w", err)
}
```

### Connection Pool Configuration

```go
// For SQLite, limit connection pool to prevent write contention
// SQLite only supports 1 concurrent writer (even in WAL mode)
sqlDB.SetMaxOpenConns(1)  // Use magic constant: cryptoutilMagic.SQLiteMaxOpenConnections
sqlDB.SetMaxIdleConns(1)
```

### Why This Matters

- **WAL mode** (Write-Ahead Logging) allows multiple concurrent readers and one writer
- **busy_timeout** makes SQLite retry when database is locked instead of immediately failing
- **MaxOpenConns=1** prevents connection pool from trying concurrent writes (which would fail)
- **Without these settings**, parallel Go tests using `t.Parallel()` will fail with database locking errors

### Reference Implementation

See `internal/server/repository/sqlrepository/sql_provider.go` lines 201-213 for the canonical SQLite configuration pattern used in the KMS server code.

### Magic Constants

Use these constants from `internal/common/magic/magic_database.go`:
- `cryptoutilMagic.DBSQLiteBusyTimeout` = 30 seconds
- `cryptoutilMagic.SQLiteMaxOpenConnections` = 1

## Database DSN Usage

**Database DSN (Use localhost):**
```go
dsn := "postgres://user:pass@localhost:5432/dbname?sslmode=disable"
```
