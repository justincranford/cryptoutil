---
description: "Common anti-patterns and mistakes to avoid based on post-mortems and session learnings"
applyTo: "**"
---
# Anti-Patterns and Lessons Learned

## CRITICAL Regression-Prone Areas

### Format_go Self-Modification (P0 Incidents)

**Historical Context**: Multiple regressions (b934879b, b0e4b6ef, 8c855a6e, 71b0e90d)

**Root Cause**: LLM agents lose exclusion context during narrow-focus refactoring

**NEVER DO**:

- ❌ Modify comments/test data in `enforce_any.go` or `format_go_test.go`
- ❌ Change `` `interface{}` `` to `` `any` `` in format_go package without reading full context
- ❌ Refactor code in isolation without reading related files

**ALWAYS DO**:

- ✅ Read complete package context before refactoring self-modifying code
- ✅ Check for CRITICAL/SELF-MODIFICATION tags in comments
- ✅ Verify self-exclusion patterns exist and are respected
- ✅ Run tests after ANY changes to format_go package

**Pattern Recognition**:

- **CRITICAL comments**: NEVER simplify or remove without understanding purpose
- **Backticked strings** in code: Intentional protection against replacement
- **Test data patterns**: May use "wrong" values intentionally

### Windows Firewall Exception Prevention

**Problem**: Binding to `0.0.0.0` triggers Windows Firewall prompts, blocking automation

**NEVER DO**:

- ❌ Bind to `0.0.0.0` in unit tests or integration tests
- ❌ Use `localhost` (may resolve to IPv6 `::1`)

**ALWAYS DO**:

- ✅ Bind to `127.0.0.1` (IPv4 loopback) in tests
- ✅ Use `0.0.0.0` ONLY in Docker containers (isolated network namespace)

**Why**: Each `0.0.0.0` binding = 1 firewall popup = blocked CI/CD

### SQLite Connection Pool Deadlocks

**Problem**: GORM explicit transactions require multiple connections, MaxOpenConns=1 causes deadlock

**NEVER DO**:

- ❌ Set `MaxOpenConns=1` with GORM transactions
- ❌ Use `sql.TxOptions{ReadOnly: true}` with SQLite (not supported)

**ALWAYS DO**:

- ✅ Set `MaxOpenConns=5` for GORM transaction support
- ✅ Enable WAL mode: `PRAGMA journal_mode=WAL;`
- ✅ Set busy timeout: `PRAGMA busy_timeout = 30000;`
- ✅ Use standard transactions for read operations (SQLite doesn't support read-only)

**Rationale**: GORM transaction wrapper requires separate connection from base operations

### Docker Compose Port Conflicts (E2E Failures)

**Problem**: Multiple services include same telemetry compose file, causing port conflicts

**Root Cause** (2025-12-19 session): CA and JOSE deployments both try to bind OTEL collector ports 4317, 4318, 8888, 8889, 13133 to host

**NEVER DO**:

- ❌ Expose container ports to host if multiple instances may run simultaneously
- ❌ Use same compose include in multiple services without considering port conflicts

**ALWAYS DO**:

- ✅ Use container-to-container networking (no host port mappings) for shared services
- ✅ Services communicate via Docker network using container names (e.g., `opentelemetry-collector-contrib:4317`)
- ✅ Test E2E workflows with sequential deployments to catch port conflicts

**Pattern**: If `docker compose up` for service B fails after service A succeeds, check for port conflicts in included compose files

---

## Testing Anti-Patterns

### Coverage Improvement Without Baseline Analysis

**Problem**: Writing 60+ tests without analyzing baseline coverage HTML = 0% improvement

**NEVER DO**:

- ❌ Write tests without checking baseline coverage first
- ❌ Add tests randomly hoping to hit uncovered code
- ❌ Trial-and-error test writing cycles

**ALWAYS DO**:

- ✅ Generate baseline: `go test -coverprofile=coverage.out`
- ✅ Analyze HTML: `go tool cover -html=coverage.out -o coverage.html`
- ✅ Identify RED (uncovered) lines in specific functions
- ✅ Write targeted tests for identified gaps
- ✅ Verify improvement with new coverage report

**Lesson**: Coverage ≠ test count. Many tests can add 0% if exercising already-covered code paths.

### Individual Test Functions vs Table-Driven

**Problem**: Creating TestFunc_Variant1, TestFunc_Variant2, TestFunc_Variant3 as separate functions

**Result**: 1371-line test file (2.7x hard limit), maintenance nightmare, slower LLM processing

**NEVER DO**:

- ❌ Separate test functions for algorithm/key size variants
- ❌ Duplicate setup code across multiple test functions

**ALWAYS DO**:

- ✅ Use table-driven tests with variants as rows
- ✅ Group related test cases in single function with `t.Run(tt.name, ...)`
- ✅ Keep test files under 500 lines (hard limit)

### Race Condition Testing Patterns

**Problem**: Race detector overhead (~10x) causes test timeouts with short deadlines

**NEVER DO**:

- ❌ Hardcode 2-second timeouts for network operations
- ❌ Assume race detector runs at normal speed

**ALWAYS DO**:

- ✅ Use 10+ second timeouts for network operations in race mode
- ✅ Increase test timeouts 10x when race detector enabled
- ✅ Add thread-safe accessor methods (RLock/RUnlock) for shared state
- ✅ Never access shared maps/slices without mutex protection

**Pattern**: `context deadline exceeded` errors under `-race` = insufficient timeout, not actual bug

---

## Git Workflow Anti-Patterns

### Amending Repeatedly (Loses History)

**Problem**: Using `git commit --amend` repeatedly loses history, masks mistakes, breaks bisect

**NEVER DO**:

- ❌ Amend commit after push (breaks shared history)
- ❌ Amend repeatedly during debugging session
- ❌ Use amend to hide incremental fixes

**ALWAYS DO**:

- ✅ Commit each logical unit independently
- ✅ Preserve full timeline of changes and decisions
- ✅ Enable git bisect to identify when bugs were introduced
- ✅ Use amend ONLY for immediate typo fixes (within 1 minute, before push)

**Rationale**: Incremental commits preserve context, enable selective revert, show thought process

### Applying Fixes to Corrupted HEAD

**Problem**: Assuming HEAD is correct when it may be corrupted from previous failed attempts

**NEVER DO**:

- ❌ Apply "one more fix" on top of corrupted code
- ❌ Mix baseline restoration with new fixes in same commit
- ❌ Assume HEAD is always clean

**ALWAYS DO**:

- ✅ Restore clean baseline from known-good commit FIRST
- ✅ Verify baseline works (tests pass)
- ✅ Apply ONLY the new fix (minimal change)
- ✅ Commit as NEW commit with clear description

**Pattern**: Find last known-good commit → restore entire package → verify → apply targeted fix → verify → commit

---

## Documentation Anti-Patterns

### Creating Standalone Session Documentation

**Problem**: Creating `docs/SESSION-2025-12-14-*.md` files leads to documentation bloat

**NEVER DO**:

- ❌ Create dated session documentation files
- ❌ Create standalone analysis documents for session work
- ❌ Create separate work log files per session

**ALWAYS DO**:

- ✅ Append to `specs/*/implement/DETAILED.md` Section 2 timeline
- ✅ Single source of truth for implementation timeline
- ✅ Create separate docs ONLY for permanent reference material (ADRs, post-mortems, user guides)

**Rule of Thumb**: If it's session-specific work → append to DETAILED.md. If it's permanent reference → create dedicated doc.

---

## Architecture Anti-Patterns

### Missing Service Federation Configuration

**Problem**: Services don't know how to discover or communicate with federated services

**NEVER DO**:

- ❌ Hardcode service URLs in application code
- ❌ Assume services are always co-located

**ALWAYS DO**:

- ✅ Use configuration for service discovery (YAML, environment, DNS)
- ✅ Support multiple federation patterns (DNS, config files, service mesh)
- ✅ Implement graceful degradation when federated services unavailable

**Pattern**: Service A depends on Service B → configure B's URL in A's config, not hardcode

---

## Performance Anti-Patterns

### Mutation Testing Timeout (>45 minutes)

**Problem**: Running gremlins on entire codebase sequentially causes 45-minute timeouts

**NEVER DO**:

- ❌ Run mutation testing on all packages sequentially
- ❌ Include test utilities and generated code in mutation scope

**ALWAYS DO**:

- ✅ Parallelize by package using GitHub Actions matrix strategy
- ✅ Exclude tests, generated code, vendor directories
- ✅ Set per-job timeout (15 minutes max)
- ✅ Target <20 minutes total with parallel execution

**Optimization**: 4-6 packages per parallel job, focus on business logic only

### Test Timing Violations (>15s per package)

**Problem**: Test packages taking >15 seconds due to exhaustive algorithm variant testing

**NEVER DO**:

- ❌ Test every key size variant (RSA 2048/3072/4096) every time
- ❌ Use `TestProbAlways` for redundant variants

**ALWAYS DO**:

- ✅ Use `TestProbTenth` (10%) or `TestProbQuarter` (25%) for algorithm variants
- ✅ Reserve `TestProbAlways` (100%) for base algorithms only
- ✅ Target <15s per unit test package, <180s full unit test suite

**Rationale**: Statistical sampling ensures bugs eventually caught without running all variants every time

---

## Key Takeaways

1. **Context Reading**: Always read complete context before refactoring self-modifying code
2. **Windows Firewall**: Always bind to 127.0.0.1 in tests (never 0.0.0.0)
3. **Coverage Analysis**: Always analyze baseline HTML before writing tests
4. **Incremental Commits**: Never amend repeatedly - preserve history for bisect
5. **Restore from Clean**: Always restore clean baseline before applying fixes
6. **Port Conflicts**: Remove host port mappings for shared services in Docker Compose
7. **Mutation Parallelization**: Never run sequentially - use GitHub Actions matrix
8. **Test Timeouts**: Always increase timeouts 10x for race detector mode
