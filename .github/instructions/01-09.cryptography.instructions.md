---
description: "Instructions for cryptographic patterns, FIPS compliance, hash versioning, and algorithm agility"
applyTo: "**"
---
# Cryptography Instructions - CRITICAL

## FIPS 140-3 Compliance - MANDATORY

**CRITICAL: FIPS 140-3 mode is ALWAYS enabled by default and MUST NEVER be disabled**

- All cryptographic operations use FIPS-approved algorithms
- **ONLY use NIST FIPS 140-3 approved algorithms**
- **NEVER use non-FIPS algorithms**

### Approved Algorithms

**Asymmetric Cryptography**:

- RSA ≥ 2048 bits (2048, 3072, 4096)
- ECDSA (NIST curves: P-256, P-384, P-521)
- ECDH (NIST curves: P-256, P-384, P-521)
- EdDSA (Ed25519, Ed448)

**Symmetric Cryptography**:

- AES ≥ 128 bits (128, 192, 256)
- AES-GCM (authenticated encryption)
- AES-CBC (with HMAC for authentication)

**Hash Functions**:

- SHA-256, SHA-384, SHA-512
- HMAC-SHA256, HMAC-SHA384, HMAC-SHA512

**Key Derivation**:

- PBKDF2-HMAC-SHA256 (MANDATORY for password hashing)
- HKDF-SHA256, HKDF-SHA384, HKDF-SHA512

### BANNED Algorithms - NEVER USE

❌ **bcrypt** - NOT FIPS-approved, use PBKDF2-HMAC-SHA256 instead
❌ **scrypt** - NOT FIPS-approved, use PBKDF2-HMAC-SHA256 instead
❌ **Argon2** - NOT FIPS-approved, use PBKDF2-HMAC-SHA256 instead
❌ **MD5** - NOT FIPS-approved, use SHA-256 or SHA-512 instead
❌ **SHA-1** - NOT FIPS-approved, use SHA-256 or SHA-512 instead
❌ **RSA < 2048 bits** - Insufficient key length
❌ **DES, 3DES** - Deprecated ciphers

### Password Hashing Pattern - MANDATORY

```go
// ✅ CORRECT: PBKDF2-HMAC-SHA256 (FIPS-approved)
func HashPassword(password string) (string, error) {
    salt := make([]byte, 32)
    if _, err := io.ReadFull(rand.Reader, salt); err != nil {
        return "", err
    }

    iterations := 600000 // OWASP 2023 recommendation
    keyLen := 32
    hash := pbkdf2.Key([]byte(password), salt, iterations, keyLen, sha256.New)

    // Format: {version}:{algorithm}:{iterations}:base64(salt):base64(hash)
    return fmt.Sprintf("{1}:PBKDF2-HMAC-SHA256:%d:%s:%s",
        iterations,
        base64.StdEncoding.EncodeToString(salt),
        base64.StdEncoding.EncodeToString(hash)), nil
}

// ❌ WRONG: bcrypt (NOT FIPS-approved)
func HashPassword(password string) (string, error) {
    return bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
}
```

---

## Hash Service Architecture - MANDATORY

### Version-Based Policy Framework

**Version = Date-Based Policy Revision**: Each version represents a specific security policy snapshot based on standards from that year.

**Supported Versions**:

- **v1**: 2020 NIST guidelines
- **v2**: 2023 NIST guidelines
- **v3**: 2025 OWASP recommendations

**4 Registries × 3 Versions = 12 Configurations**:

- Password Registry: v1, v2, v3
- API Key Registry: v1, v2, v3
- Data Digest Registry: v1, v2, v3
- Signature Registry: v1, v2, v3

### Hash Output Format - MANDATORY

```
{version}:{algorithm}:{params}:base64_hash
```

**Examples**:

```
{1}:PBKDF2-HMAC-SHA256:rounds=600000:abcd1234...
{2}:PBKDF2-HMAC-SHA384:rounds=600000:efgh5678...
{3}:HKDF-SHA512:info=api-key,salt=xyz:ijkl9012...
```

### Version Update Pattern

**Trigger**: Manual operator decision (update config, restart service)

```yaml
# config.yaml
hash_service:
  password_registry:
    current_version: 2  # New passwords use v2
    # Old v1 passwords still verified correctly
```

**Migration Strategy**:

- Old hashes stay on original version (v1, v2, etc.)
- New hashes use current_version
- Gradual migration (no forced re-hash)
- Version prefix enables correct verification

### Backward Compatibility - MANDATORY

**Reject Unprefixed Hashes**: Force re-hash on next authentication

```go
// ✅ CORRECT: Verify with version prefix
func VerifyHash(input, storedHash string) (bool, error) {
    parts := strings.Split(storedHash, ":")
    if len(parts) < 4 {
        return false, ErrUnprefixedHash // Force re-hash
    }

    version := parts[0] // {1}, {2}, {3}
    algorithm := parts[1] // PBKDF2-HMAC-SHA256, etc.
    params := parts[2] // rounds=600000, etc.
    expectedHash := parts[3]

    // Use version-specific verification
    return verifyWithVersion(version, algorithm, params, input, expectedHash)
}

// ❌ WRONG: Accept unprefixed hashes
func VerifyHash(input, storedHash string) (bool, error) {
    // Ambiguous - which algorithm? which parameters?
    return bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(input))
}
```

---

## Algorithm Agility - MANDATORY

**All cryptographic operations MUST support configurable algorithms with FIPS-approved defaults**

### Key Generation Pattern

```go
// ✅ CORRECT: Configurable algorithm with FIPS default
type KeyGenConfig struct {
    Algorithm string // "RSA2048", "ECDSA-P256", "Ed25519"
    KeySize   int    // For RSA: 2048, 3072, 4096
}

func GenerateKey(config KeyGenConfig) (interface{}, error) {
    switch config.Algorithm {
    case "RSA2048", "RSA3072", "RSA4096":
        return rsa.GenerateKey(rand.Reader, config.KeySize)
    case "ECDSA-P256":
        return ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
    case "ECDSA-P384":
        return ecdsa.GenerateKey(elliptic.P384(), rand.Reader)
    case "Ed25519":
        return ed25519.GenerateKey(rand.Reader)
    default:
        return nil, fmt.Errorf("unsupported algorithm: %s", config.Algorithm)
    }
}

// ❌ WRONG: Hardcoded algorithm
func GenerateKey() (*rsa.PrivateKey, error) {
    return rsa.GenerateKey(rand.Reader, 2048) // Not configurable
}
```

### Encryption Pattern

```go
// ✅ CORRECT: Algorithm agility with FIPS defaults
type EncryptConfig struct {
    Algorithm string // "AES-256-GCM", "AES-192-GCM", "AES-128-GCM"
    KeySize   int    // 128, 192, 256
}

func Encrypt(plaintext []byte, config EncryptConfig) ([]byte, error) {
    key := make([]byte, config.KeySize/8)
    if _, err := io.ReadFull(rand.Reader, key); err != nil {
        return nil, err
    }

    var block cipher.Block
    var err error

    switch config.Algorithm {
    case "AES-256-GCM", "AES-192-GCM", "AES-128-GCM":
        block, err = aes.NewCipher(key)
    default:
        return nil, fmt.Errorf("unsupported algorithm: %s", config.Algorithm)
    }

    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }

    return gcm.Seal(nonce, nonce, plaintext, nil), nil
}
```

---

## Key Management - MANDATORY

### Key Derivation - CRITICAL

**ALWAYS derive keys deterministically for interoperability**

All cryptoutil instances using the same set of shared unseal secrets MUST derive the same unseal JWKs, including KIDs and key materials, for cryptographic interoperability between instances.

```go
// ✅ CORRECT: Deterministic key derivation
func DeriveUnsealKey(masterSecret, salt []byte, purpose string) ([]byte, error) {
    info := []byte(purpose) // "encryption", "signing", etc.

    // HKDF ensures same inputs → same output
    kdf := hkdf.New(sha256.New, masterSecret, salt, info)

    key := make([]byte, 32) // 256-bit key
    if _, err := io.ReadFull(kdf, key); err != nil {
        return nil, err
    }

    return key, nil
}

// ❌ WRONG: Random key generation (breaks interoperability)
func DeriveUnsealKey() ([]byte, error) {
    key := make([]byte, 32)
    _, err := rand.Read(key) // Different key per instance!
    return key, err
}
```

### Key Rotation Pattern

```go
// ✅ CORRECT: Key versioning for rotation
type KeyRing struct {
    ActiveKeyID  string
    Keys         map[string]Key // keyID -> Key
    RotationDate time.Time
}

func (kr *KeyRing) Encrypt(plaintext []byte) ([]byte, error) {
    activeKey := kr.Keys[kr.ActiveKeyID] // Always use active key
    ciphertext := activeKey.Encrypt(plaintext)

    // Prefix with key ID for later decryption
    return append([]byte(kr.ActiveKeyID+":"), ciphertext...), nil
}

func (kr *KeyRing) Decrypt(ciphertext []byte) ([]byte, error) {
    parts := bytes.SplitN(ciphertext, []byte(":"), 2)
    keyID := string(parts[0])

    key, ok := kr.Keys[keyID] // Use historical key for decryption
    if !ok {
        return nil, ErrKeyNotFound
    }

    return key.Decrypt(parts[1])
}
```

---

## Secure Random Generation - MANDATORY

**ALWAYS use crypto/rand, NEVER use math/rand**

```go
// ✅ CORRECT: Cryptographically secure random
import "crypto/rand"

func GenerateToken(length int) ([]byte, error) {
    token := make([]byte, length)
    _, err := rand.Read(token)
    return token, err
}

// ❌ WRONG: Predictable random (security vulnerability)
import "math/rand"

func GenerateToken(length int) []byte {
    token := make([]byte, length)
    rand.Read(token) // Predictable!
    return token
}
```

---

## Certificate Validation - MANDATORY

**Full cert chain validation, TLS 1.3+, NEVER InsecureSkipVerify**

```go
// ✅ CORRECT: Strict TLS configuration
tlsConfig := &tls.Config{
    MinVersion:         tls.VersionTLS13,
    InsecureSkipVerify: false, // ALWAYS validate certs
    RootCAs:            certPool,
    ClientCAs:          certPool,
    ClientAuth:         tls.RequireAndVerifyClientCert,
}

// ❌ WRONG: Insecure TLS (bypasses validation)
tlsConfig := &tls.Config{
    InsecureSkipVerify: true, // NEVER do this
    MinVersion:         tls.VersionTLS12, // Too old
}
```

---

## CA/Browser Forum Baseline Requirements

Adhere to latest CA/Browser Forum Baseline Requirements for TLS Server Certificates:

- **Certificate Serial Numbers** (Section 7.1): Minimum 64 bits CSPRNG, non-sequential, >0, <2^159
- **Approved Algorithms** (Section 6.1.5, 6.1.6): Use only approved cryptographic algorithms and key sizes
- **Validity Periods**: Max 398 days for subscriber certificates (post-2020-09-01)
- **Required Extensions** (Section 7.1.2): Implement required certificate extensions
- **Subject/Issuer Encoding** (Section 7.1.4): Proper subject/issuer name encoding
- **Signature Algorithms** (Section 7.1.3.2): Use approved signature algorithms
- **CRL/OCSP Profiles** (Sections 7.2, 7.3): Follow CRL and OCSP profile requirements
- **Audit Logging** (Section 5.4.1): Implement proper audit logging for certificate lifecycle events

---

## Cryptographic Libraries - MANDATORY

**Prefer standard library crypto packages**:

- `crypto/rand` - Secure random generation
- `crypto/rsa` - RSA operations
- `crypto/ecdsa` - ECDSA operations
- `crypto/ed25519` - EdDSA operations
- `crypto/aes` - AES encryption
- `crypto/sha256`, `crypto/sha512` - Hash functions
- `crypto/hmac` - HMAC operations
- `crypto/tls` - TLS connections
- `golang.org/x/crypto/pbkdf2` - PBKDF2 key derivation
- `golang.org/x/crypto/hkdf` - HKDF key derivation

**Avoid third-party crypto libraries unless necessary** (review required)

---

## Key Takeaways

1. **FIPS 140-3 ALWAYS enabled** - No exceptions
2. **Password hashing: PBKDF2-HMAC-SHA256** - NEVER bcrypt/scrypt/Argon2
3. **Hash versioning: {version}:{algorithm}:{params}:hash** - Always prefix
4. **Algorithm agility: Configurable with FIPS defaults** - Support multiple algorithms
5. **Deterministic key derivation: HKDF** - For instance interoperability
6. **crypto/rand ALWAYS** - Never math/rand
7. **TLS 1.3+ with full validation** - Never InsecureSkipVerify
