---
description: "Local Git commands and commit conventions"
applyTo: "**"
---
# Git

# Git and Documentation Instructions - Tactical Guidance

## Conventional Commits Format

**Format**: `<type>[optional scope]: <description>`

**Types**: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert

**Examples**:

```bash
feat(auth): add OAuth2 client credentials flow
fix(database): prevent connection pool exhaustion
feat(api)!: remove deprecated v1 endpoints  # Breaking change
```

## Incremental Commits - CRITICAL

✅ ALWAYS commit incrementally (NOT amend) → preserves history for bisect, selective revert
❌ NEVER repeatedly amend → loses context, hard to bisect

## Restore from Clean Baseline Pattern

**When fixing regressions, ALWAYS restore clean baseline FIRST**:

```bash
# 1. Find last known-good commit
git log --oneline --grep="baseline" | head -5

# 2. Restore entire package from clean commit
git checkout <clean-commit-hash> -- path/to/package/

# 3. Verify baseline works
go test ./path/to/package/

# 4. Apply targeted fix ONLY (minimal change)
# Edit specific file

# 5. Verify fix independently
go test ./path/to/package/

# 6. Commit as NEW commit (not amend)
git commit -m "fix(package): add defensive check for X"
```

**Why**: HEAD may be corrupted from previous failed attempts. Start from known-good state.

## Session Documentation Strategy

**NEVER create standalone session docs**: `docs/SESSION-*.md`, `docs/session-*.md`, `docs/analysis-*.md`

## PowerShell Notes

- Chain commands with `;` (NOT `&&`)
- No `sed` by default - use `git diff -- <file>` instead
- Use `Get-Content file | Select-String 'pattern'` for grep-like searches

## Git Workflow for Copilot Chat Sessions

**Terminal Commands**: git status, add -A, commit -m, push, log, diff (NOT Copilot chat commands)

**Commit vs Push**: Commit frequently (atomic changes), push strategically (CI/CD ready)
**Local Iteration**: Acceptable to use `--no-verify` while iterating
**Push Readiness**: ALWAYS run tests, linting before pushing/PR

**Branch Strategy**: Feature branches, merge after CI passes, keep short-lived, rebase on main before merge
**Commit Hygiene**: Atomic and focused, conventional messages, avoid "WIP" in main

## Conventional Commits - MANDATORY

**Format**: `<type>[scope]: <description>`

**Types**: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert

**Rules**: Imperative mood, lowercase, no period, <72 chars, breaking changes use `!` or `BREAKING CHANGE:`

**Examples**: `feat(auth): add OAuth2 client credentials flow`, `fix(database): prevent connection pool exhaustion`

## Commit Strategy - Incremental vs Amend - CRITICAL

### ALWAYS Commit Incrementally (NOT Amend)

**Why**: Preserves timeline, enables bisect, allows selective revert, shows thought process, easier review

**WRONG**: Amend repeatedly (loses history, masks mistakes, hard to bisect)
**CORRECT**: Commit each logical unit independently

### When to Use Amend (Rare)

**ONLY**: Fix typos in message immediately (<1 min, before push), add forgotten files (<1 min, before push)
**NEVER**: After pushing, repeatedly during debugging, to hide fixes, as default workflow

## Restore from Clean Baseline Pattern - CRITICAL

**When**: Fixing regressions, multiple failed attempts, uncertain HEAD state, code worked previously

**Why**: HEAD may be corrupted by failed attempts, incremental fixes compound problem

**Steps**:

1. Find last known-good commit (`git log --grep="baseline"`, git bisect)
2. Restore package (`git checkout <hash> -- path/to/package/`)
3. Verify baseline works (`go test`)
4. Apply ONLY new fix (targeted change)
5. Verify fix works
6. Commit as NEW commit (NOT amend)

**Common Mistakes**: Assuming HEAD correct, applying fixes on corrupted code, mixing restoration with fixes, using amend

## Terminal Command Auto-Approval

**Pattern Checking**: Verify command matches `.vscode/settings.json` patterns, track unmatched, end-of-session review
**Auto-Enable**: Safe read-only, build ops (status, list, build, test, format)
**Auto-Disable**: Destructive ops (rm, delete, prune, reset, push)

## PowerShell Notes

**Command Chaining**: Use `;` (NOT `&&`)
**Unix Utilities**: NOT available - use Git commands (git diff, git grep) or PowerShell (Select-String)

---

## Pull Request Descriptions

**Title**: `type(scope): description` (<72 chars)
**Sections**: What (present tense), Why (rationale), How (approach), Testing (coverage), Breaking Changes, Documentation
**Security**: No sensitive data, input validation, secure defaults
**Quality**: Tests added (≥95%/98%), linting passes, docs updated

**PR Size**: <200 (small), 200-500 (medium), 500+ (large, consider splitting), 1000+ (epic, break down)

---

## Session Documentation Strategy - CRITICAL

### NEVER Create Standalone Session Documentation

**Violations**: NEVER create `docs/SESSION-*.md`, `docs/session-*.md`, `docs/analysis-*.md`, `docs/work-log-*.md`

**Create New Docs ONLY For**: Permanent specs, reference guides, post-mortems, ADRs

## Core Documentation Organization

**Keep in 2 files**: README.md (main), docs/README.md (deep dive)

**ALWAYS add to existing README** instead of creating new files
**NEVER create**: docs/SCRIPT-NAME.md, docs/TOOL-NAME.md

## TODO Documentation Organization

**Keep 1-6 `./docs/todos-*.md` files**, review before ending sessions, **delete completed tasks immediately**
**Large cleanups**: Use `create_file` to rewrite, don't use complex `replace_string_in_file`

---

## Common Anti-Patterns

### Amending Repeatedly (Loses History)

**Problem**: Using `git commit --amend` repeatedly loses history, masks mistakes, breaks bisect.

**Symptom**: Commit history shows 1 commit with 50 changes, impossible to identify when specific bug introduced

#### NEVER DO

❌ **Amend commit after push (breaks shared history)**
❌ **Amend repeatedly during debugging session**
❌ **Use amend to hide incremental fixes**

#### ALWAYS DO

✅ **Commit each logical unit independently**
✅ **Preserve full timeline of changes and decisions**
✅ **Enable git bisect to identify when bugs were introduced**
✅ **Use amend ONLY for immediate typo fixes (within 1 minute, before push)**

#### Rationale

**Incremental Commits**:

- Preserve context (why each change was made)
- Enable selective revert (revert specific fix without losing others)
- Show thought process (debugging steps visible)
- Support bisect (identify exact commit that introduced bug)

---

### Applying Fixes to Corrupted HEAD

**Problem**: Assuming HEAD is correct when it may be corrupted from previous failed attempts.

**Symptom**: Apply "one more fix" on top of corrupted code → fails again → more fixes → fails again (cycle)

#### NEVER DO

❌ **Apply "one more fix" on top of corrupted code**
❌ **Mix baseline restoration with new fixes in same commit**
❌ **Assume HEAD is always clean**

#### ALWAYS DO

✅ **Restore clean baseline from known-good commit FIRST**
✅ **Verify baseline works (tests pass)**
✅ **Apply ONLY the new fix (minimal change)**
✅ **Commit as NEW commit with clear description**

#### Pattern

**Find Last Known-Good** → **Restore Baseline** → **Verify Baseline** → **Apply Targeted Fix** → **Verify Fix** → **Commit Separately**

**Why**: HEAD corruption accumulates from failed attempts. Start fresh from verified clean state.
