---
description: "Instructions for testing"
applyTo: "**"
---
# Testing Instructions - Tactical Guidance

**Reference**: See `.specify/memory/testing.md` for complete specifications (coverage requirements, main() test pattern, mutation testing workflow, parallel test safety, anti-patterns)

**This file contains ONLY tactical implementation patterns**

## Coverage Targets Quick Reference

| Category | Packages | Minimum Coverage |
|----------|----------|------------------|
| Production | internal/{jose,identity,kms,ca} | 95% |
| Infrastructure | internal/cmd/cicd/* | 98% |
| Utility | internal/shared/*, pkg/* | 98% |
| Main Functions | cmd/*/main.go | 0%* (*if internalMain() ≥95%) |

## main() Pattern - MANDATORY

```go
// ✅ CORRECT: Thin main() delegates to testable internalMain()
func main() {
    os.Exit(internalMain(os.Args, os.Stdin, os.Stdout, os.Stderr))
}

// internalMain is testable - accepts injected dependencies
func internalMain(args []string, stdin io.Reader, stdout, stderr io.Writer) int {
    if len(args) < 2 {
        fmt.Fprintln(stderr, "usage: cmd <arg>")
        return 1
    }
    // ... business logic
    return 0
}
```

## Coverage Analysis Before Writing Tests - MANDATORY

```bash
# 1. Generate baseline
go test ./pkg -coverprofile=./test-output/coverage_pkg.out

# 2. Analyze uncovered lines (HTML)
go tool cover -html=./test-output/coverage_pkg.out -o ./test-output/coverage_pkg.html

# 3. Find RED lines, write targeted tests

# 4. Verify improvement
go test ./pkg -coverprofile=./test-output/coverage_pkg_new.out
```

## Timeout Configuration - MANDATORY

```go
// ✅ DO: Use 5s+ timeouts for network operations
client := &http.Client{
    Transport: &http.Transport{TLSClientConfig: tlsConfig},
    Timeout: 5 * time.Second,
}

ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
```

## Table-Driven Tests - MANDATORY

```go
func TestHappyPaths(t *testing.T) {
    t.Parallel()
    tests := []struct {
        name string
        alg  Algorithm
    }{
        {name: "HMAC_HS256", alg: AlgHS256},
        {name: "RSA_2048", alg: AlgRS256},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()
            // test logic
        })
    }
}
```

## Probability-Based Execution - MANDATORY

**Use for algorithm/key size variants only**:
- ✅ RSA 2048/3072/4096, AES 128/192/256
- ✅ HMAC-SHA256/384/512, ECDSA P-256/384/521
- ❌ Fundamentally different algorithms (RSA vs ECDSA)
- ❌ Business logic branches

**Magic Constants** (`internal/shared/magic/magic_testing.go`):
- `TestProbAlways = 100` (100%) - Base algorithms
- `TestProbQuarter = 25` (25%) - Important variants
- `TestProbTenth = 10` (10%) - Redundant variants

## Test Execution Commands

```bash
# ✅ CORRECT: Concurrent with shuffle
go test ./... -cover -shuffle=on

# ❌ WRONG: Sequential execution (hides bugs)
go test ./... -p=1          # NEVER DO THIS
go test ./... -parallel=1   # NEVER DO THIS

# Race detection (requires CGO_ENABLED=1)
go test -race -count=2 ./...
```

## File Size Limits - MANDATORY

| Limit | Lines | Action Required |
|-------|-------|-----------------|
| Soft | 300 | Ideal target |
| Medium | 400 | Acceptable with justification |
| Hard | 500 | NEVER EXCEED - refactor required |

## Key Takeaways

1. **Coverage**: 95%+ production, 98%+ infrastructure/utility (NO EXCEPTIONS)
2. **main() Pattern**: Thin wrapper → testable internalMain() (ALL commands)
3. **Baseline Analysis**: ALWAYS analyze HTML before writing tests
4. **Timeouts**: 5s+ for network ops, 10s+ for TLS in GitHub Actions
5. **Table-Driven**: ALWAYS use with t.Parallel()
6. **Concurrency**: NEVER use -p=1 or -parallel=1
7. **File Size**: Split at 500 lines (soft: 300, medium: 400)
8. **Test Timing**: <15s per package, <180s full suite (unit tests only)
