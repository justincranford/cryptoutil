---
description: "Instructions for testing"
applyTo: "**"
---
# Testing Instructions - Tactical Guidance

## CRITICAL: READ ENTIRE FILE BEFORE WRITING ANY TESTS

**MANDATORY: Before writing or modifying ANY test code, read this ENTIRE file to understand:**
- Table-driven test pattern (REQUIRED for multiple test cases)
- app.Test() pattern (REQUIRED for ALL HTTP handler tests)
- TestMain pattern (REQUIRED for heavyweight dependencies) - See [07-01.testmain-integration-pattern.instructions.md](.github/instructions/07-01.testmain-integration-pattern.instructions.md)
- Test isolation with t.Parallel() (REQUIRED for concurrent execution)
- Coverage targets: ≥95% production, ≥98% infrastructure/utility

**If you skip reading this file and create standalone test functions, table-driven test violations, or real HTTPS listeners, your work will be rejected and you will need to refactor.**

---

## CRITICAL ANTI-PATTERNS - NEVER DO THESE

**FORBIDDEN Testing Practices** (violations MUST be refactored):

### ❌ FORBIDDEN #1: Standalone Test Functions for Variants

**NEVER create multiple standalone test functions for similar test cases:**

```go
// ❌ WRONG: Standalone test functions (15+ functions for similar cases)
func TestIssueSession_MissingRealm(t *testing.T) { ... }
func TestIssueSession_MissingTenant(t *testing.T) { ... }
func TestIssueSession_InvalidRequest(t *testing.T) { ... }
```

**✅ ALWAYS use table-driven tests:**

```go
// ✅ CORRECT: Single table-driven test function
func TestIssueSession_ValidationErrors(t *testing.T) {
    t.Parallel()
    tests := []struct {
        name    string
        setup   func() context.Context
        wantErr string
    }{
        {name: "missing realm", setup: ctxWithoutRealm, wantErr: "realm"},
        {name: "missing tenant", setup: ctxWithoutTenant, wantErr: "tenant"},
        {name: "invalid request", setup: ctxWithInvalid, wantErr: "invalid"},
    }
    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            t.Parallel()
            // Test logic using tc
        })
    }
}
```

**Rationale**:
- Single test function per error category (not per error variant)
- Easy to add new error cases (just add table row)
- Reduced code duplication (~200 lines saved per consolidation)
- Faster execution (shared setup runs once)

---

### ❌ FORBIDDEN #2: Real HTTPS Listeners in Tests

**NEVER start real HTTPS servers or bind to network ports in unit/integration tests:**

```go
// ❌ WRONG: Starting real server in test
func TestHandler(t *testing.T) {
    server := NewServer()
    go server.Start()  // ← Binds to network port, triggers Windows Firewall!
    defer server.Shutdown()

    resp, _ := http.Get("https://localhost:8080/api")
}
```

**✅ ALWAYS use Fiber's app.Test() for in-memory handler testing:**

```go
// ✅ CORRECT: In-memory handler test
func TestHealthcheck_Handler(t *testing.T) {
    t.Parallel()

    app := fiber.New(fiber.Config{DisableStartupMessage: true})
    app.Get("/admin/api/v1/livez", healthcheckHandler)

    req := httptest.NewRequest("GET", "/admin/api/v1/livez", nil)
    resp, err := app.Test(req, -1)  // ← In-memory, <1ms, no network binding
    require.NoError(t, err)
    defer resp.Body.Close()

    require.Equal(t, 200, resp.StatusCode)
}
```

**Rationale**:
- In-memory testing: Fast (<1ms), reliable, no network binding
- Prevents Windows Firewall popups (blocks CI/CD automation)
- TestMain ONLY for instance setup, NOT for handler tests

---

### ❌ FORBIDDEN #3: Per-Test Database Creation

**NEVER create database per test (repeated overhead):**

```go
// ❌ WRONG: Per-test DB creation
func setupTestDB(t *testing.T) *gorm.DB {
    container, _ := postgres.RunContainer(ctx, ...)
    db, _ := gorm.Open(...)
    return db
}

func TestSomething(t *testing.T) {
    db := setupTestDB(t)  // ← Repeated 10-30s overhead!
}
```

**✅ ALWAYS use TestMain for heavyweight dependencies:**

```go
// ✅ CORRECT: Single DB for all tests
var testDB *gorm.DB

func TestMain(m *testing.M) {
    container, _ := postgres.RunContainer(ctx, ...)
    defer container.Terminate(ctx)

    testDB, _ = gorm.Open(...)  // ← Created ONCE
    os.Exit(m.Run())
}

func TestSomething(t *testing.T) {
    // Use shared testDB - instant startup
}
```

**Rationale**:
- PostgreSQL containers: 10-30s startup (do ONCE, not per test)
- Shared resources: testDB, testServer (package-level variables)
- Fast test execution: No per-test overhead

---

### ❌ FORBIDDEN #4: Hardcoded Test Data

**NEVER use hardcoded UUIDs/strings (causes conflicts in parallel tests):**

```go
// ❌ WRONG: Hardcoded test data
func TestCreate(t *testing.T) {
    user := &User{ID: "123e4567-e89b-12d3-a456-426614174000"}  // ← UNIQUE constraint failure!
    repo.Create(ctx, user)
}
```

**✅ ALWAYS use UUIDv7 for dynamic test data:**

```go
// ✅ CORRECT: Dynamic test data
func TestCreate(t *testing.T) {
    t.Parallel()
    id := googleUuid.NewV7()  // ← Unique per test
    user := &User{ID: id, Name: fmt.Sprintf("user_%s", id)}
    repo.Create(ctx, user)
}
```

**Rationale**:
- UUIDv7: Thread-safe, process-safe, time-ordered
- Prevents UNIQUE constraint violations in parallel tests
- Pattern: Generate ONCE, reuse in test case

---

### ❌ FORBIDDEN #5: Missing t.Parallel() in Subtests

**NEVER omit t.Parallel() from test functions or subtests:**

```go
// ❌ WRONG: Missing t.Parallel()
func TestSomething(t *testing.T) {
    // ← Missing t.Parallel()
    tests := []struct{ ... }{ ... }
    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            // ← Missing t.Parallel() in subtest too!
        })
    }
}
```

**✅ ALWAYS add t.Parallel() to both parent and subtests:**

```go
// ✅ CORRECT: t.Parallel() everywhere
func TestSomething(t *testing.T) {
    t.Parallel()  // ← Parent test parallel
    tests := []struct{ ... }{ ... }
    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            t.Parallel()  // ← Subtest parallel
        })
    }
}
```

**Rationale**:
- Reveals race conditions, deadlocks, data conflicts
- If tests can't run concurrently, production code can't either
- Faster test execution (utilizes all CPU cores)

---

## Enforcement Checklist - BEFORE COMMITTING TESTS

**Run this checklist before marking test work complete:**

- [ ] **Table-Driven Pattern**: All tests with multiple cases use table-driven pattern (NOT standalone functions)
- [ ] **app.Test() Pattern**: ALL HTTP handler tests use app.Test() (NO real HTTPS listeners)
- [ ] **TestMain Pattern**: Heavyweight resources (PostgreSQL, servers) initialized once in TestMain
- [ ] **t.Parallel() Everywhere**: All test functions and subtests have t.Parallel()
- [ ] **Dynamic Test Data**: NO hardcoded UUIDs/strings, ONLY UUIDv7 or magic constants
- [ ] **Coverage Analysis**: Generated HTML coverage report, targeted RED lines
- [ ] **Tests Pass**: `go test ./...` passes with shuffle (`-shuffle=on`)
- [ ] **No Race Conditions**: `go test -race -count=2 ./...` passes (if CGO enabled)
- [ ] **File Size**: Test files ≤500 lines (refactor if exceeded)
- [ ] **Mutation Testing**: ≥95% efficacy production, ≥98% infrastructure/utility

---

## Coverage Targets by Package Type - MANDATORY

**Category-Based Coverage Expectations**:

| Package Type | Examples | Minimum Coverage | Rationale |
|--------------|----------|------------------|-----------|
| **Production Code** | internal/{jose,identity,kms,ca} | 95% | Business logic must be thoroughly tested |
| **Infrastructure** | internal/cmd/cicd/* | 98% | CI/CD tools affect entire project - higher bar |
| **Utility** | internal/shared/*, pkg/* | 98% | Widely reused - bugs propagate across codebase |
| **Main Functions** | cmd/*/main.go | 0% (if internalMain() ≥95%) | Thin wrapper exempted when testable function has coverage |
| **Generated Code** | api/*/openapi_gen_*.go, *_gen.go | 0% (excluded from coverage) | Generated code is stable, mutation testing adds no value |

**main() Pattern Requirement**:
```go
// ✅ CORRECT: Thin main() delegates to testable internalMain()
func main() {
    os.Exit(internalMain(os.Args, os.Stdin, os.Stdout, os.Stderr))
}

// internalMain() MUST have ≥95% coverage to exempt main()
func internalMain(args []string, stdin io.Reader, stdout, stderr io.Writer) int {
    // ... business logic with comprehensive test coverage
    return 0
}
```

**Coverage Configuration** (.github/workflows/ci-coverage.yml):
```yaml
- name: Check coverage thresholds
  run: |
    if [ "$production_coverage" -lt 95 ]; then
      echo "❌ BLOCKING: Production coverage $production_coverage% < 95%"
      exit 1
    fi
    if [ "$infrastructure_coverage" -lt 98 ]; then
      echo "❌ BLOCKING: Infrastructure coverage $infrastructure_coverage% < 98%"
      exit 1
    fi
```

## SQLite DateTime UTC Comparison - CRITICAL

**Problem**: SQLite stores DATETIME in UTC, Go's `time.Now()` respects local timezone
**Symptom**: Tests fail in non-UTC timezones (PST/EST) but pass in CI
**Root Cause**: `time.Now()` returns local time, SQLite normalizes to UTC
**Fix**: ALWAYS use `time.Now().UTC()` when comparing with SQLite timestamps

```go
// ❌ WRONG: time.Now() without .UTC()
if session.CreatedAt.After(time.Now()) { ... }

// ✅ CORRECT: Always use .UTC()
if session.CreatedAt.After(time.Now().UTC()) { ... }
```

**Automatic Enforcement**:

- **Pre-commit hook** automatically converts `time.Now()` → `time.Now().UTC()`
- Formatter: `enforce-time-now-utc` in `internal/cmd/cicd/format_go/`
- Evidence: Auto-applied 1394 fixes across 273 files during initial deployment
- Purpose: Prevents recurring LLM agent mistakes with timezone handling
- Hook runs via `cicd-enforce-internal` in `.pre-commit-config.yaml`

**Rationale for Automation**:

- LLM agents frequently forget `.UTC()` suffix
- Manual code reviews miss timezone issues
- Tests pass in UTC environments (CI/CD), fail in PST/EST (local dev)
- Formatter provides defensive safety net

**See**: `docs/pre-commit-hooks.md` for complete formatter documentation

## main() Pattern - MANDATORY

```go
// ✅ CORRECT: Thin main() delegates to testable internalMain()
func main() {
    os.Exit(internalMain(os.Args, os.Stdin, os.Stdout, os.Stderr))
}

// internalMain is testable - accepts injected dependencies
func internalMain(args []string, stdin io.Reader, stdout, stderr io.Writer) int {
    if len(args) < 2 {
        fmt.Fprintln(stderr, "usage: cmd <arg>")
        return 1
    }
    // ... business logic
    return 0
}
```

## Coverage Analysis - MANDATORY

**Pattern**: `go test -coverprofile=coverage.out && go tool cover -html=coverage.out` → find RED lines → write targeted tests

## Timeout Configuration - MANDATORY

```go
// ✅ DO: Use 5s+ timeouts for network operations
client := &http.Client{
    Transport: &http.Transport{TLSClientConfig: tlsConfig},
    Timeout: 5 * time.Second,
}

ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
```

## TestMain Pattern - MANDATORY FOR HEAVYWEIGHT DEPENDENCIES

**ALWAYS use TestMain to start heavyweight services once per package**

**Rationale**: Starting databases/servers in each test = slow execution. TestMain starts once, reuses across all tests.

**See Also**: [07-01.testmain-integration-pattern.instructions.md](.github/instructions/07-01.testmain-integration-pattern.instructions.md) for complete integration test patterns with GORM databases.

**Pattern**:

```go
var (testDB *gorm.DB; testServer *Server)

func TestMain(m *testing.M) {
    // Setup heavyweight dependencies ONCE
    container, _ := postgres.RunContainer(ctx, ...)
    defer container.Terminate(ctx)

    testDB, _ = gorm.Open(postgres.Open(connStr), &gorm.Config{})
    testServer, _ = NewServer(testDB, ...)
    go testServer.Start()
    defer testServer.Shutdown()

    os.Exit(m.Run())
}

func TestSomething(t *testing.T) {
    // Use testDB and testServer - already started
}
```

**Use For**: PostgreSQL containers, HTTP servers, crypto services (>100ms initialization)
**Don't Use For**: Simple unit tests, mocks, lightweight helpers


**Fiber Handler Testing - MANDATORY**

**ALL unit and integration test functions that test Fiber HTTP handlers (happy-path or sad-path) MUST use Fiber's `app.Test()` for in-memory handler testing.**

**NEVER start real HTTPS servers or bind to network ports in any unit or integration test.**

**Rationale**:
- Starting real HTTPS servers in tests triggers Windows Firewall exceptions, blocks CI/CD, and requires manual intervention.
- In-memory handler testing with `app.Test()` is fast (<1ms), reliable, and avoids network binding.
- TestMain pattern is ONLY for setting up a full working instance of a product-service per package (for happy-path integration), but all handler tests (unit and integration) MUST use in-memory `app.Test()`.

**Pattern**:

```go
func TestHealthcheck_Handler(t *testing.T) {
    t.Parallel()

    // Create standalone Fiber app - NO listener started
    app := fiber.New(fiber.Config{
        DisableStartupMessage: true,
    })

    // Register handler under test
    app.Get("/admin/api/v1/livez", func(c *fiber.Ctx) error {
        return c.JSON(fiber.Map{"status": "alive"})
    })

    // Create HTTP request (no network call)
    req := httptest.NewRequest("GET", "/admin/api/v1/livez", nil)

    // Test handler in-memory - completes instantly
    resp, err := app.Test(req, -1) // -1 = no timeout
    require.NoError(t, err)
    defer resp.Body.Close()

    // Verify response
    require.Equal(t, 200, resp.StatusCode)

    body := make([]byte, 1024)
    n, _ := resp.Body.Read(body)
    require.Contains(t, string(body[:n]), `"status":"alive"`)
}
```

**Reference Implementations**:
- `internal/apps/template/service/server/application/application_listener_test.go` - Healthcheck handler tests with timeout scenarios
- `internal/jose/server/middleware/apikey_test.go` - API key middleware with app.Test()
- `internal/ca/api/handler/handler_est_csrattrs_test.go` - EST endpoint handler tests

**When to Use app.Test()**:
- Testing individual HTTP handlers (unit or integration)
- Verifying middleware behavior
- Timeout/error scenarios
- Response validation

**When to Use TestMain**:
- To set up a single full working instance of a product-service per package (for happy-path integration tests)
- All handler tests MUST still use in-memory app.Test() and MUST NOT start real servers

**Anti-Pattern (FORBIDDEN):**
- Starting real HTTPS servers or binding to network ports in any unit or integration test
- Using TestMain to start a real server for handler tests (use only for instance setup)

## Windows Testcontainers - TROUBLESHOOTING

**Error Message**: "testcontainers-go does not support rootless Docker"

**Root Cause**: Docker Desktop is not running on Windows

**Solution**:

1. Open Docker Desktop (background process)
2. Wait for Docker to fully start (30-60 seconds)
3. Verify with: `docker ps` (should succeed, not error)
4. Re-run tests

**NEVER skip testcontainer tests on Windows** - Fix by starting Docker Desktop first

**Pattern to AVOID**:

```go
// ❌ WRONG - Skips tests unnecessarily on Windows
if runtime.GOOS == "windows" {
    t.Skip("Skipping PostgreSQL container test on Windows")
}
```

**Correct Pattern**:

```go
// ✅ CORRECT - Tests run when Docker Desktop is running
container, err := postgres.RunContainer(ctx, ...)
if err != nil {
    t.Fatalf("Failed to start PostgreSQL container (is Docker Desktop running?): %v", err)
}
```

```go
var (
    testDB *gorm.DB
    testServer *Server
)

func TestMain(m *testing.M) {
    // Setup: Start heavyweight dependencies ONCE
    ctx := context.Background()

    // Start PostgreSQL test-container (expensive - do once)
    container, _ := postgres.RunContainer(ctx,
        postgres.WithDatabase(fmt.Sprintf("test_%s", googleUuid.NewV7().String())),
        postgres.WithUsername(fmt.Sprintf("user_%s", googleUuid.NewV7().String())),
    )
    defer container.Terminate(ctx)

    connStr, _ := container.ConnectionString(ctx)
    testDB, _ = gorm.Open(postgres.Open(connStr), &gorm.Config{})

    // Start test server (expensive - do once)
    testServer, _ = NewServer(testDB, ...)
    go testServer.Start()
    defer testServer.Shutdown()

    // Run all tests
    exitCode := m.Run()

    // Cleanup happens via defer
    os.Exit(exitCode)
}

func TestSomething(t *testing.T) {
    // Use testDB and testServer - already started
    // Test runs fast because no startup overhead
}
```

**Use TestMain For**: PostgreSQL containers, HTTP servers, repositories, crypto services, any resource taking >100ms to initialize

**DON'T Use TestMain For**: Simple unit tests, mocks, lightweight helpers

## Table-Driven Tests Pattern - MANDATORY

**ALWAYS use table-driven tests for multiple test cases**

**Rationale**: Clearer structure, faster execution (shared setup), easier to add cases

**Pattern**:

```go
func TestSomething(t *testing.T) {
    // Common setup BEFORE test loop (runs once)
    db := setupDB(t)
    server := setupServer(t, db)

    tests := []struct{
        name string
        input X
        want Y
    }{
        {name: "happy path", input: validX, want: validY},
        {name: "error case", input: invalidX, want: errorY},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()
            // Test logic using tt.input and tt.want
        })
    }
}
```

**Benefits**: Common variables (db, server) created once before loop, not N times inside loop. Faster execution, clearer code.

## Probability-Based Execution

**Use for algorithm variants only** (RSA 2048/3072/4096, AES 128/192/256, ECDSA P-256/384/521)
**Magic Constants**: `TestProbAlways=100`, `TestProbQuarter=25`, `TestProbTenth=10`

## Test Execution Commands

```bash
# ✅ CORRECT: Concurrent with shuffle
go test ./... -cover -shuffle=on

# ❌ WRONG: Sequential execution (hides bugs)
go test ./... -p=1          # NEVER DO THIS
go test ./... -parallel=1   # NEVER DO THIS

# Race detection (requires CGO_ENABLED=1)
go test -race -count=2 ./...
```

## Race Detector Probabilistic Execution - MANDATORY

**ALWAYS run race detector with count=2+ for probabilistic execution**:

- Race detector uses randomization to detect timing-dependent bugs
- Single execution may miss races (probabilistic detection)
- Pattern: `go test -race -count=5 ./...` for CI (balance coverage vs time)
- Local dev: `go test -race -count=2 ./...` for faster feedback

## E2E Coverage Requirements - MANDATORY

**MUST test BOTH `/service/**` and `/browser/**` paths**:

- E2E tests MUST cover both service-to-service and browser-to-service APIs
- Verify middleware behavior (IP allowlist, CSRF, CORS) for each path
- Pattern: Separate test suites for `/service/**` and `/browser/**` paths

## Mutation Testing Exemptions - MANDATORY

**Exempt these code categories from mutation testing**:

- **OpenAPI-generated code**: Client/server stubs from `oapi-codegen`
- **GORM models**: Database schema definitions (no business logic)
- **Protobuf-generated code**: gRPC/protobuf stubs
- Reason: Generated code is stable, mutation testing adds no value

## File Size Limits - MANDATORY

| Limit | Lines | Action Required |
|-------|-------|-----------------|
| Soft | 300 | Ideal target |
| Medium | 400 | Acceptable with justification |
| Hard | 500 | NEVER EXCEED - refactor required |

## Test Concurrency Requirements

**ALWAYS use concurrent test execution, NEVER disable parallelization**

**Rationale**: Parallel tests reveal race conditions, deadlocks, data conflicts. If tests can't run concurrently, production code can't either.

**Execution**:

```bash
# ✅ CORRECT - Concurrent with shuffle (recommended)
go test ./... -cover -shuffle=on

# ❌ WRONG - Sequential execution (hides concurrency bugs)
go test ./... -p=1  # NEVER DO THIS
go test ./... -parallel=1  # NEVER DO THIS
```

**Race Detection** (requires CGO_ENABLED=1):

```bash
go test -race -count=2 ./...
```

---

## Test Execution Time Targets

**MANDATORY Timing Targets**:

- Per-package: <15 seconds (unit tests only)
- Full suite: <180 seconds (3 minutes, unit tests only)
- Integration/E2E: Excluded from strict timing (Docker startup overhead acceptable)
- Probabilistic execution: MANDATORY for packages approaching 15s limit

#### Common Timing Violations and Fixes

**Problem**: Test packages taking >15 seconds due to exhaustive algorithm variant testing.

**Symptom**: `go test ./...` takes >180 seconds (violates target)

#### NEVER DO

❌ **Test every key size variant (RSA 2048/3072/4096) every time**
❌ **Use `TestProbAlways` for redundant variants**

#### ALWAYS DO

✅ **Use `TestProbTenth` (10%) or `TestProbQuarter` (25%) for algorithm variants**
✅ **Reserve `TestProbAlways` (100%) for base algorithms only**
✅ **Target <15s per unit test package, <180s full unit test suite**

#### Rationale

**Statistical Sampling**: Bugs eventually caught without running all variants every time

**Magic Constants**:

- `TestProbAlways = 100` (100%) - Base algorithms
- `TestProbQuarter = 25` (25%) - Important variants
- `TestProbTenth = 10` (10%) - Redundant variants

---

## Test Data Isolation Requirements

**MANDATORY Patterns**:

- Unique values: UUIDv7 for all test data (thread-safe, process-safe)
- Dynamic ports: port 0 pattern for all test servers
- TestMain for dependencies: Start once per package (PostgreSQL containers, service dependencies)

**Test Values**:

- Option A: Generate once, reuse: `id := googleUuid.NewV7()` then use `id` in test cases
- Option B: Magic values from `internal/identity/magic` package

**NEVER**: Inline hardcoded UUIDs, strings, or call `NewV7()` twice expecting same result

**Real Dependencies vs Mocks**: Prefer test containers (PostgreSQL, Otel Collector Contrib), real crypto, real HTTP servers. Mocks ONLY for hard-to-reach corner cases or external services that can't run locally.

---

## Core Test Rules

1. Coverage targets: 95%+ production, 98%+ infrastructure/utility
2. Table-driven tests: ALWAYS use with `t.Parallel()` for orthogonal data
3. Assertions: ALWAYS use testify `require` for fast fail
4. Exit codes: NEVER os.Exit() in test code (only main() calls os.Exit())
5. Response bodies: ALWAYS check and close: `defer require.NoError(t, resp.Body.Close())`
6. Error handling: ALWAYS check errors from helper functions
6. Mutation testing: ≥98% ideal efficacy (all packages), ≥95% mandatory minimum (with documented blockers only)
8. Temporary files: NEVER create temporary test files requiring deletion
9. Test values: NEVER hardcode - use UUIDv7 or magic constants
10. Concurrency: ALWAYS use concurrent execution, NEVER `-p=1` or `-parallel=1`

---

## Test File Organization

| Type | Suffix | Example |
|------|--------|---------|
| Unit | `_test.go` | `calc_test.go` |
| Bench | `_bench_test.go` | `calc_bench_test.go` |
| Fuzz | `_fuzz_test.go` | `calc_fuzz_test.go` |
| Property | `_property_test.go` | `calc_property_test.go` |
| Integration | `_integration_test.go` | `api_integration_test.go` |

---

## Race Condition Prevention

**MANDATORY Rules**:

- NEVER write to parent scope variables in parallel sub-tests
- NEVER use t.Parallel() with global state manipulation (os.Stdout, env vars)
- ALWAYS use inline assertions: `require.NoError(t, resp.Body.Close())`
- ALWAYS create fresh test data per test case (new sessions, UUIDs)
- ALWAYS protect shared maps/slices with sync.Mutex or sync.Map
- NEVER compare database timestamps against `time.Now()` in concurrent tests

**Detection**: `go test -race -count=2 ./...` (requires CGO_ENABLED=1)

---

## Mutation Testing - MANDATORY

**Category-Based Targets**: ≥98% ideal efficacy (all packages), ≥95% mandatory minimum (production code with documented blockers only), ≥98% infrastructure/utility (no exceptions)

**Execution**: `gremlins unleash --tags=!integration` or `gremlins unleash ./internal/jose`

**Windows Compatibility**: gremlins v0.6.0 panics on Windows in some scenarios. Use CI/CD (Linux) for mutation testing until Windows compatibility verified.

#### Avoiding Timeouts in Mutation Testing

**Problem**: Running gremlins on entire codebase sequentially causes 45-minute timeouts.

**Symptom**: CI workflow exceeds job timeout, incomplete mutation coverage

#### NEVER DO

❌ **Run mutation testing on all packages sequentially**
❌ **Include test utilities and generated code in mutation scope**

#### ALWAYS DO

✅ **Parallelize by package using GitHub Actions matrix strategy**
✅ **Exclude tests, generated code, vendor directories**
✅ **Set per-job timeout (15 minutes max)**
✅ **Target <20 minutes total with parallel execution**

#### Optimization

**4-6 packages per parallel job**, focus on business logic only

**Expected Result**: Sequential 45 minutes → Parallel 15-20 minutes (2-3× speedup)

---

## Benchmarking - Mandatory for Crypto

**File Suffix**: `_bench_test.go`

**Execution**: `go test -bench=. -benchmem ./pkg/crypto`

**Pattern**:

```go
func BenchmarkAESEncrypt(b *testing.B) {
    key := make([]byte, 32)
    plaintext := make([]byte, 1024)
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, _ = encrypt(key, plaintext)
    }
}
```

---

## Fuzz Testing - MANDATORY

**CRITICAL**: Fuzz tests MUST ONLY contain fuzz functions (Fuzz*)

**Requirements**:

- Use `//go:build !fuzz` tag to exclude property tests from fuzz test runs
- Fuzz test names MUST be unique, NOT substrings of others (e.g., `FuzzHKDFAllVariants` not `FuzzHKDF`)
- ALWAYS run from project root: `go test -fuzz=FuzzXXX -fuzztime=15s ./path`
- Minimum fuzz time: 15 seconds per test

**File Organization**: `*_fuzz_test.go` ONLY fuzz functions, `*_test.go` unit/integration tests

---

## Property-Based Testing - MANDATORY

**Library**: [gopter](https://github.com/leanovate/gopter)

**File Suffix**: `_property_test.go`

**Pattern**:

```go
func TestEncryptionRoundTrip(t *testing.T) {
    properties := gopter.NewProperties(nil)
    properties.Property("encrypt then decrypt returns original", prop.ForAll(
        func(plaintext []byte) bool {
            ciphertext, _ := Encrypt(key, plaintext)
            result, _ := Decrypt(key, ciphertext)
            return bytes.Equal(plaintext, result)
        },
        gen.SliceOf(gen.UInt8()),
    ))
    properties.TestingRun(t)
}
```

---

## Test File Size Limits - MANDATORY

| Limit | Lines | Action |
|-------|-------|--------|
| Soft | 300 | Ideal target |
| Medium | 400 | Acceptable with justification |
| Hard | 500 | NEVER EXCEED - refactor required |

**Refactoring Strategies** (when file exceeds 400 lines): Split by functionality, algorithm type, extract test helpers to `*_test_util.go` files, move integration tests to `*_integration_test.go`

---

## Dynamic Port Allocation - MANDATORY

**ALWAYS use port 0 and extract actual assigned port**

```go
listener, err := net.Listen("tcp", "127.0.0.1:0")
require.NoError(t, err)
actualPort := listener.Addr().(*net.TCPAddr).Port
resp, err := http.Get(fmt.Sprintf("http://127.0.0.1:%d/api", actualPort))
```

---

## Common Testing Anti-Patterns - NEVER DO THESE

1. **Writing Tests Without Baseline Coverage Analysis**: Adding 60+ tests without analyzing baseline coverage HTML first → 0% coverage improvement. ALWAYS generate baseline, analyze HTML for RED lines, target specific gaps.
2. **Individual Test Functions Instead of Table-Driven**: Creating TestFunc_Variant1, TestFunc_Variant2, TestFunc_Variant3 → 1371-line test file (2.7x hard limit). Use table-driven tests with variants as rows.
3. **Test Outputs in Source Directories**: Placing coverage files in internal/jose/test-coverage.out → source tree pollution. ALWAYS use ./test-output/ directory.
4. **Exceeding File Size Limits**: Allowing test files to grow to 1371 lines → slower LLM processing, harder maintenance. Split at 500 lines using functional grouping.
5. **Trial-and-Error Test Writing**: Writing tests, checking coverage, writing more tests, repeat → wasted effort. Baseline → HTML analysis → targeted test → verify improvement cycle.

6. **Race Condition Testing Patterns**: Race detector overhead (~10×) causes test timeouts with short deadlines. Tests pass normally, fail with `context deadline exceeded` under `-race`. Use 10+ second timeouts for network operations in race mode, increase test timeouts 10× when race detector enabled, add thread-safe accessor methods (RLock/RUnlock) for shared state, never access shared maps/slices without mutex protection. `context deadline exceeded` errors under `-race` = insufficient timeout, NOT actual bug. Fix: Increase timeout 10× or use dynamic timeout based on race detector flag.

7. **Per-Test Database Initialization**: Creating `setupTestDB(t *testing.T)` and calling it in each test → repeated overhead. ALWAYS use TestMain pattern to initialize heavyweight resources (PostgreSQL containers, GORM connections, servers) once per package. Share `testDB`, `testServer` across all tests via package-level variables.

8. **Hardcoded Test Data**: Using hardcoded strings/UUIDs in tests → UNIQUE constraint failures, test data conflicts. ALWAYS use `googleUuid.NewV7()` for dynamic test data (thread-safe, process-safe, time-ordered). Pattern: `id := googleUuid.NewV7()` then use `id` in test cases.

9. **Marking Tasks BLOCKED Without Resolution Phases**: Encountering blocker → marking task BLOCKED → moving to next work → blocker forgotten. ALWAYS create Phase N+1 immediately when encountering blockers with explicit resolution tasks, estimated LOE, acceptance criteria. Pattern: Blocker discovered in Phase 3 Task 3.2 → Create Phase 4 "P3.2 Resolution" with tasks 4.1-4.N to resolve blocker.

**Key Insight**: Coverage ≠ test count. Many tests can add 0% coverage if exercising already-covered code paths. HTML baseline analysis eliminates guesswork and waste.

---

## cicd Utility Testing Requirements

**Commands organized as `internal/cmd/cicd/<snake_case>/` subdirectories**

EVERY command MUST exclude its own subdirectory (self-exclusion pattern). Define exclusion in `internal/common/magic/magic_cicd.go`, add self-exclusion test to verify pattern works. Target 95%+ coverage per command subdirectory.
