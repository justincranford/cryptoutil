---
description: "Testing standards, patterns, and quality gates"
applyTo: "**"
---
# Testing Instructions

## CRITICAL: Read Before Writing Tests

- Table-driven tests REQUIRED for multiple cases.
- Fiber app.Test() REQUIRED for ALL HTTP handler tests.
- TestMain REQUIRED for heavyweight dependencies (DB, servers).
- t.Parallel() REQUIRED on all test functions and subtests.
- Coverage: >=95% production, >=98% infrastructure/utility.

## FORBIDDEN Patterns

### 1. Standalone Test Functions for Variants

```go
// WRONG: Multiple standalone functions for similar cases
func TestIssueSession_MissingRealm(t *testing.T) { ... }
func TestIssueSession_MissingTenant(t *testing.T) { ... }

// CORRECT: Table-driven test
func TestIssueSession_ValidationErrors(t *testing.T) {
    t.Parallel()
    tests := []struct{ name string; setup func() context.Context; wantErr string }{
        {name: "missing realm", setup: ctxWithoutRealm, wantErr: "realm"},
        {name: "missing tenant", setup: ctxWithoutTenant, wantErr: "tenant"},
    }
    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) { t.Parallel() /* test logic */ })
    }
}
```

### 2. Real HTTPS Listeners in Tests

NEVER start real servers or bind network ports. ALWAYS use Fiber app.Test():

```go
app := fiber.New(fiber.Config{DisableStartupMessage: true})
app.Get("/admin/api/v1/livez", healthcheckHandler)
req := httptest.NewRequest("GET", "/admin/api/v1/livez", nil)
resp, err := app.Test(req, -1)  // In-memory, <1ms, no network
```

### 3. Per-Test Database Creation

NEVER create DB per test. Use TestMain (shared setup once):

```go
var testDB *gorm.DB

func TestMain(m *testing.M) {
    container, _ := postgres.RunContainer(ctx, ...)
    defer container.Terminate(ctx)
    testDB, _ = gorm.Open(postgres.Open(connStr), &gorm.Config{})
    os.Exit(m.Run())
}
```

### 4. Hardcoded Test Data

NEVER use hardcoded UUIDs. ALWAYS use `googleUuid.NewV7()` (thread-safe, unique).

### 5. Missing t.Parallel()

ALWAYS add t.Parallel() to both parent test and subtests.

## TestMain Integration Pattern

**Use For**: PostgreSQL containers, HTTP servers, crypto services (>100ms init).
**Don't Use For**: Simple unit tests, mocks, lightweight helpers.

```go
var (testDB *gorm.DB; testServer *Server)

func TestMain(m *testing.M) {
    ctx := context.Background()
    container, _ := postgres.RunContainer(ctx,
        postgres.WithDatabase(fmt.Sprintf("test_%s", googleUuid.NewV7().String())),
        postgres.WithUsername(fmt.Sprintf("user_%s", googleUuid.NewV7().String())),
    )
    defer container.Terminate(ctx)
    testDB, _ = gorm.Open(postgres.Open(connStr), &gorm.Config{})
    testServer, _ = NewServer(testDB, ...)
    go testServer.Start()
    defer testServer.Shutdown()
    os.Exit(m.Run())
}
```

**Database error testing**: Use real constraints (no mocking needed):

```go
func TestCreate_DuplicateKey(t *testing.T) {
    id := googleUuid.NewV7()
    testRepo.Create(ctx, &Model{ID: id})
    err := testRepo.Create(ctx, &Model{ID: id})  // Real constraint violation
    require.Error(t, err)
}
```

## Coverage Targets

| Package Type | Minimum | Examples |
|--------------|---------|----------|
| Production | 95% | internal/{jose,identity,kms,ca} |
| Infrastructure/Utility | 98% | internal/cmd/cicd/*, internal/shared/*, pkg/* |
| Main Functions | 0% (if internalMain >=95%) | cmd/*/main.go |
| Generated Code | Excluded | api/*_gen.go |

**Pattern**: `go test -coverprofile=coverage.out && go tool cover -html=coverage.out` -> find RED lines -> write targeted tests.

**main() Pattern**: Thin main() delegates to testable internalMain(args, stdin, stdout, stderr).

## SQLite DateTime UTC - CRITICAL

ALWAYS use `time.Now().UTC()` when comparing with SQLite timestamps. Pre-commit hook auto-converts.

## Test Execution

```bash
# Standard (concurrent with shuffle)
go test ./... -cover -shuffle=on

# Race detection (requires CGO_ENABLED=1)
go test -race -count=2 ./...
```

**NEVER**: `-p=1` or `-parallel=1` (hides concurrency bugs).

## Timing Targets

- Per-package: <15 seconds (unit tests)
- Full suite: <180 seconds (unit tests)
- Integration/E2E: Excluded from timing (Docker overhead acceptable)

## Probability-Based Execution

For algorithm variants (RSA 2048/3072/4096, AES sizes, ECDSA curves):
- `TestProbAlways=100`: Base algorithms only
- `TestProbQuarter=25`: Important variants
- `TestProbTenth=10`: Redundant variants

## Timeout Configuration

```go
client := &http.Client{Timeout: 5 * time.Second}
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
```

## Mutation Testing

**Targets**: >=95% mandatory minimum, >=98% ideal. Run: `gremlins unleash --tags=!integration`
**Exempt**: OpenAPI-generated code, GORM models, protobuf stubs.
**Windows**: Use CI/CD (Linux) for gremlins - v0.6.0 panics on Windows.

## Fuzz Testing

- File suffix: `_fuzz_test.go` (ONLY fuzz functions).
- Minimum fuzz time: 15s per test.
- Run from project root: `go test -fuzz=FuzzXXX -fuzztime=15s ./path`

## Benchmarking

File suffix: `_bench_test.go`. Mandatory for crypto operations.

## Test File Organization

| Type | Suffix |
|------|--------|
| Unit | `_test.go` |
| Bench | `_bench_test.go` |
| Fuzz | `_fuzz_test.go` |
| Property | `_property_test.go` |
| Integration | `_integration_test.go` |

## File Size Limits

Soft: 300 lines, Medium: 400, Hard: 500 (NEVER exceed - refactor).

## Enforcement Checklist

- [ ] Table-driven pattern for all multi-case tests
- [ ] app.Test() for ALL handler tests (no real listeners)
- [ ] TestMain for heavyweight resources
- [ ] t.Parallel() on all tests and subtests
- [ ] Dynamic test data (UUIDv7, no hardcoded values)
- [ ] Tests pass with shuffle (`-shuffle=on`)
- [ ] File size <=500 lines
