---
description: "Instructions for testing"
applyTo: "**"
---
# Testing Instructions

## Core Rules

- Run `go test ./... -cover` for automated tests; use testify `require` for assertions
- Target coverage: 95%+ production, 100%+ infrastructure (cicd), 100% utility code
- Mutation testing: ≥80% gremlins score per package (mandatory)
- ALWAYS use table-driven tests with `t.Parallel()` - reveals real concurrency bugs
- NEVER hardcode test values - use magic package constants OR runtime-generated UUIDv7
- NEVER create temporary test files requiring deletion - create permanent tests only

## Test Values

**Option A**: Magic values from `internal/identity/magic` package
**Option B**: Generate once, reuse: `id := googleUuid.NewV7()` then use `id` in test cases
**NEVER**: Hardcoded UUIDs, strings, or calling `NewV7()` twice expecting same result

## Table-Driven Pattern (Mandatory)

```go
func TestMyFunction(t *testing.T) {
    t.Parallel()
    tests := []struct{ name string; input string; wantErr bool }{
        {"valid", "good", false},
        {"invalid", "", true},
    }
    for _, tc := range tests {
        tc := tc
        t.Run(tc.name, func(t *testing.T) {
            t.Parallel()
            // test using tc fields
        })
    }
}
```

**WRONG**: Separate `TestX_Case1`, `TestX_Case2` functions for same functionality

## Test File Organization

| Type | Suffix | Example |
|------|--------|---------|
| Unit | `_test.go` | `calc_test.go` |
| Bench | `_bench_test.go` | `calc_bench_test.go` |
| Fuzz | `_fuzz_test.go` | `calc_fuzz_test.go` |
| Property | `_property_test.go` | `calc_property_test.go` |
| Integration | `_integration_test.go` | `api_integration_test.go` |

## Mutation Testing (Mandatory)

- Use [gremlins](https://github.com/go-gremlins/gremlins) for mutation testing
- Target: ≥80% mutation score per package
- Run: `gremlins unleash --tags=!integration` (excludes integration tests)
- Focus on business logic, parsers, validators, crypto operations
- Create baseline report and track improvements in specs/

## Benchmarking (Mandatory for Crypto)

- **ALWAYS create benchmarks for cryptographic operations** (happy and sad paths)
- File suffix: `_bench_test.go`
- Run: `go test -bench=. -benchmem ./pkg/crypto`
- Track performance regressions in CI/CD
- Examples: key generation, encryption/decryption, signing/verification, hashing

```go
func BenchmarkAESEncrypt(b *testing.B) {
    key := make([]byte, 32)
    plaintext := make([]byte, 1024)
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, _ = encrypt(key, plaintext)
    }
}
```

## Fuzz Testing (Mandatory)

- **ALWAYS create fuzz tests for parsers, validators, and input handlers**
- Fuzz test names MUST be unique, NOT substrings of others (e.g., `FuzzHKDFAllVariants` not `FuzzHKDF`)
- ALWAYS run from project root: `go test -fuzz=FuzzXXX -fuzztime=15s ./path`
- Minimum fuzz time: 15 seconds per test
- Use unquoted names, PowerShell `;` for chaining

## Property-Based Testing (Recommended)

- Use [gopter](https://github.com/leanovate/gopter) for property-based testing
- Focus on invariants and mathematical properties
- File suffix: `_property_test.go`
- Examples: encryption(decryption(x)) == x, sign(verify(x)) == x

```go
func TestEncryptionRoundTrip(t *testing.T) {
    properties := gopter.NewProperties(nil)
    properties.Property("encrypt then decrypt returns original", prop.ForAll(
        func(plaintext []byte) bool {
            ciphertext, _ := Encrypt(key, plaintext)
            result, _ := Decrypt(key, ciphertext)
            return bytes.Equal(plaintext, result)
        },
        gen.SliceOf(gen.UInt8()),
    ))
    properties.TestingRun(t)
}
```

## Test Execution

- Place coverage files in `./test-output/`: `go test ./pkg -coverprofile=test-output/coverage_pkg.out`
- Long-running suites (orm, client, server) can take 5-10+ min - use targeted runs: `-run=TestSpecific`

## Test Directory Conventions

| Directory | Purpose | Examples |
|-----------|---------|----------|
| `./test-output/` | Test result outputs | Coverage files, test logs, Report outputs | Autoapprove logs, CI reports |
| `./testdata/` or `pkg/testdata/` | Test input fixtures | YAML configs, test files |

## Dynamic Port Allocation Pattern (Mandatory for Server Tests)

**ALWAYS use port 0 and extract actual assigned port** for server tests to enable concurrent test execution:

```go
// TestMain pattern for Fiber server tests
var (
    testSettings = cryptoutilConfig.RequireNewForTest("pkg_test")
    serverApp    *ServerApplicationListener
    testBaseURL  string
)

func TestMain(m *testing.M) {
    // Config uses port 0 - OS assigns dynamic port
    serverApp, err = StartServerListenerApplication(testSettings)
    if err != nil {
        log.Fatalf("failed to start server: %v", err)
    }
    go serverApp.StartFunction()
    defer serverApp.ShutdownFunction()

    // Extract actual assigned port from listener
    testBaseURL = fmt.Sprintf("https://%s:%d",
        testSettings.BindPublicAddress,
        serverApp.ActualPublicPort)  // Use actual port, not config port

    exitCode := m.Run()
    os.Exit(exitCode)
}
```

**Why**: Hard-coded ports cause port conflicts when tests run in parallel. Dynamic allocation ensures each test gets a unique port.

**Reference**: `internal/server/application/application_test.go` and `application_listener.go` lines 310-360

## cicd Utility Testing

- Commands organized as `internal/cmd/cicd/<snake_case>/` subdirectories
- EVERY command MUST exclude its own subdirectory (self-exclusion pattern)
- Define exclusion in `internal/common/magic/magic_cicd.go`
- Add self-exclusion test to verify pattern works
- Target 95%+ coverage per command subdirectory

## Parallel Testing Philosophy

- `t.Parallel()` is a FEATURE - reveals race conditions sequential tests hide
- Failing parallel tests = production bugs to fix (don't remove `t.Parallel()`)
- Use UUIDv7 for test data isolation between concurrent tests
