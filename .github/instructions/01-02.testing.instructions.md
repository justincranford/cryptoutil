---
description: "Instructions for testing"
applyTo: "**"
---
# Testing Instructions

- Run `go test ./... -cover` for automated tests
- Use testify require methods for assertions; ALWAYS use clear, concise assertions with good failure messages
- Use manual tests via Swagger UI (see README)
- Ensure coverage for all key types and pool configs
- Update/fix tests, run formatters (`golangci-lint run --fix ./...`), and run linters (`golangci-lint run ./...`), before committing
- Script testing: always test scripts after add/update tests, verify help/params, test functional/error/cross-platform paths, document results (see README for details)
- Test directories may contain non-Go performance testing tools (e.g., Java Gatling in `/test/load/`)
- When updating dependencies: run `go test ./... -cover` first to confirm code and tests work, and get coverage baseline, before attempting updates; only after tests pass, update dependencies in small batches, and repeat `go test ./... -cover` to iterate on fixing any issues caused by the update, and fixing any regressions in coverage

## Test Value Policy

### CRITICAL: NEVER Use Hardcoded Test Values

**ALWAYS use one of these two approaches for test data:**

**Option A: Magic Values from `internal/identity/magic` Package**
```go
// CORRECT - Using magic constants
func TestUserCreation(t *testing.T) {
    t.Parallel()

    tests := []struct {
        name     string
        username string
        wantErr  bool
    }{
        {
            name:     "valid username",
            username: identityMagic.TestUsername,  // From magic package
            wantErr:  false,
        },
        {
            name:     "empty username",
            username: "",
            wantErr:  true,
        },
    }
    // ... test implementation
}
```

**Option B: Random Values Generated at Runtime**
```go
// CORRECT - Random values stored in local variables
func TestSessionCreation(t *testing.T) {
    t.Parallel()

    // Generate once, reuse in test
    sessionID := googleUuid.NewV7()
    userID := googleUuid.NewV7()

    tests := []struct {
        name      string
        sessionID googleUuid.UUID
        userID    googleUuid.UUID
        wantErr   bool
    }{
        {
            name:      "valid session",
            sessionID: sessionID,  // Reuse generated value
            userID:    userID,     // Reuse generated value
            wantErr:   false,
        },
    }
    // ... test implementation
}
```

**NEVER Do These:**
```go
// ❌ WRONG - Hardcoded UUID
userID := googleUuid.MustParse("123e4567-e89b-12d3-a456-426614174000")

// ❌ WRONG - Hardcoded strings/numbers embedded in tests
username := "testuser123"
port := 8080

// ❌ WRONG - Generating random value twice expecting same result
tests := []struct {
    expected googleUuid.UUID
    actual   googleUuid.UUID
}{
    {
        expected: googleUuid.NewV7(),  // Generates UUID #1
        actual:   googleUuid.NewV7(),  // Generates UUID #2 (DIFFERENT!)
    },
}

// ✅ CORRECT - Generate once, reuse
id := googleUuid.NewV7()
tests := []struct {
    expected googleUuid.UUID
    actual   googleUuid.UUID
}{
    {
        expected: id,  // Same UUID
        actual:   id,  // Same UUID
    },
}
```

**Why This Matters:**
- **Reproducibility**: Magic values ensure consistent test behavior across environments
- **Maintainability**: Central definition in magic package makes updates easier
- **Pre-commit Compliance**: Avoids flagging by hooks detecting hardcoded UUIDs
- **Clarity**: Explicit variable names document test intent better than anonymous literals

## Test Structure Best Practices

### CRITICAL: Table-Driven Test Pattern (Mandatory)

**ALWAYS use parameterized table-driven tests** - they have clearer intent, easier to understand, more compact, less duplication, easy to add more cases, better failure reporting, and represent Go testing best practices.

**NEVER write multiple separate test functions for the same functionality** - this is a common anti-pattern that violates Go testing best practices.

**Correct Pattern (Table-Driven):**
```go
func TestProcessGoFile(t *testing.T) {
    t.Parallel()

    tests := []struct {
        name           string
        content        string
        wantReplacements int
        wantError      bool
        wantContains   string
    }{
        {
            name: "file with interface{} replaced",
            content: "var x interface{}",
            wantReplacements: 1,
            wantError: false,
        },
        {
            name: "file with no interface{} unchanged",
            content: "var x int",
            wantReplacements: 0,
            wantError: false,
        },
        {
            name: "invalid syntax returns error",
            content: "invalid go syntax {{{",
            wantReplacements: 0,
            wantError: true,
            wantContains: "syntax error",
        },
    }

    for _, tc := range tests {
        tc := tc // Capture range variable
        t.Run(tc.name, func(t *testing.T) {
            t.Parallel()

            tempDir := t.TempDir()
            testFile := filepath.Join(tempDir, "test.go")
            os.WriteFile(testFile, []byte(tc.content), 0o600)

            replacements, err := processGoFile(testFile)

            if tc.wantError {
                require.Error(t, err)
                if tc.wantContains != "" {
                    require.Contains(t, err.Error(), tc.wantContains)
                }
            } else {
                require.NoError(t, err)
                require.Equal(t, tc.wantReplacements, replacements)
            }
        })
    }
}
```

**WRONG Anti-Pattern (Separate Functions):**
```go
// ❌ DON'T DO THIS - separate test functions for same functionality
func TestProcessGoFile_WithInterface(t *testing.T) { /* ... */ }
func TestProcessGoFile_NoInterface(t *testing.T) { /* ... */ }
func TestProcessGoFile_InvalidSyntax(t *testing.T) { /* ... */ }
```

**When Separate Functions ARE Acceptable:**
- Testing completely different functions/methods (not variations of same function)
- Integration tests with different setup/teardown requirements
- Tests requiring different global state or environment setup

**Key Benefits of Table-Driven Tests:**
- All test cases visible at a glance in one place
- Easy to add new test cases (just add row to table)
- Consistent test structure and execution pattern
- Better test coverage visibility
- Reduces code duplication dramatically

### Additional Best Practices

- **ALWAYS cover happy and sad path scenarios** in all test tables; include edge cases, invalid inputs, error conditions
- **ALWAYS run tests after writing/modifying them** to verify correctness and catch bug issues early, and catch coverage regressions early
- **ALWAYS analyze existing and new tests** for optimization opportunities: faster execution, better coverage, higher quality assertions
- **Target test coverage**: Maintain 80% or higher coverage for production code; 85% or higher for infrastructure code (e.g., cicd utilities); 95% or higher for utility code

## Test Execution Best Practices

### Coverage File Management
- **ALWAYS place temporary coverage files in `/test-output/` directory** to avoid cluttering project root
- **Pattern**: `go test ./internal -coverprofile=test-output/coverage_pkg.out`
- **Rationale**: Single `.gitignore` entry (`/test-output/`) instead of multiple individual patterns
- **Cleanup**: Manual deletion of `/test-output/` directory contents as needed

### Test Execution Performance
- **CRITICAL: Be cautious with long-running test suites** (database integration tests, ORM tests, internal/client tests, internal/server tests)
- **Monitor test duration**: Some packages (sqlrepository, orm, client) can take 5-10+ minutes
- **Use targeted test runs**: Run specific test functions when iterating
- **Example**: `go test ./internal/server/repository/orm -run=TestSpecificFunction` instead of full suite
- **Rationale**: Frequent full test suite runs massively slow down development progress
 - **PowerShell tip**: When running tests from PowerShell, use `;` to chain commands (not `&&`) and prefer targeted `go test` runs, e.g. `go test ./path -run TestX -v; echo "Done"` to keep the flow cross-platform friendly.

### Test File Lifecycle
- **ALWAYS create permanent test files** that can be used going forward
- **NEVER create temporary test files** that require deletion (deletion needs manual user approval)
- **Pattern**: Add tests to existing test files or create new permanent test files
- **Rationale**: Persistent tests serve as regression prevention and documentation

## Dependency Management Best Practices

- **Automated Checks**: Use `go-update-direct-dependencies` in pre-commit hooks and CI/CD workflows for efficient, focused dependency updates
- **Avoid**: `go-update-all-dependencies` in automated contexts as it can cause unnecessary updates and potential compatibility issues
- **Manual Updates**: Use `go-update-all-dependencies` only for intentional comprehensive dependency refreshes during major version updates or maintenance windows

## Test File Organization

Follow Go testing file naming conventions for proper organization:

| Test Type | File Suffix | Purpose | Example |
|-----------|-------------|---------|---------|
| Unit Tests | `_test.go` | Blackbox/whitebox testing of functions | `calculator_test.go` |
| Benchmarks | `_bench_test.go` | Performance testing | `calculator_bench_test.go` |
| Fuzz Tests | `_fuzz_test.go` | Property-based testing | `calculator_fuzz_test.go` |
| Integration | `_integration_test.go` | Component interaction testing | `api_integration_test.go` |
| E2E | `*_test.go` with `//go:build e2e` | Full system end-to-end testing | `e2e_test.go` |

**File Separation Rules:**
- Keep unit tests, benchmarks, and fuzz tests in separate files
- Use descriptive file names that indicate the test focus
- Group related tests by functionality within each file type
- Keep file sizes manageable for readability and maintainability

## Fuzz Testing Guidelines

### CRITICAL: Unique Fuzz Test Naming Convention
- **ALL Fuzz* test function names MUST be unique and MUST NOT be substrings of any other fuzz test names**
- This ensures cross-platform compatibility without quotes or regex in `-fuzz` parameters
- **Example Problem**: `FuzzHKDF` conflicts with `FuzzHKDFwithSHA256` (substring match)
- **Solution**: Use `FuzzHKDFAllVariants` instead of `FuzzHKDF`
- **Why**: Go's `-fuzz` parameter does partial matching; unique names eliminate ambiguity
- **Cross-Platform**: Unquoted parameters work identically on Windows and Linux: `go test -fuzz=FuzzXXX`

### Common Mistakes to Avoid
- **NEVER do this**: Running fuzz tests from subdirectories (breaks Go module detection, causes "go.mod file not found" errors)
- **ALWAYS run Go fuzz tests from project root** - never use `cd` commands before `go test -fuzz` (causes module detection failures)
- **NEVER do this**: Using quotes or regex when test names are unique: `-fuzz="^FuzzXXX$"` (causes cross-platform issues)
- **NEVER do this**: Creating fuzz test names that are substrings of other fuzz test names

### Correct Fuzz Test Execution
- **ALWAYS do this**: Run from project root: `go test -fuzz=FuzzSpecificTest -fuzztime=5s ./internal/common/crypto/keygen`
- **ALWAYS do this**: Specify full package paths: `./internal/common/crypto/digests`
- **ALWAYS do this**: Use PowerShell `;` for chaining: `go test -fuzz=FuzzXXX -fuzztime=5s ./path; echo "Done"`
- **ALWAYS do this**: Use unquoted, unique test names: `-fuzz=FuzzGenerateRSAKeyPair` (no quotes needed)

### Fuzz Test Patterns
- **Specific fuzz test**: `go test -fuzz=FuzzXXX -fuzztime=15s ./<package>` (most common, no quotes)
- **All fuzz tests in package**: `go test -fuzz=. -fuzztime=15s ./<package>` (only if package has 1 fuzz test)
- **Quick verification**: Use `-fuzztime=15s` for fast feedback during development
- **Cross-platform compatibility**: Avoid quotes and regex; ensure unique test names instead

## Test Concurrency and Robustness

### CRITICAL: Parallel Testing Philosophy
- **ALWAYS use `t.Parallel()` in tests whenever possible** - this is a FEATURE, not a problem
- **Parallel tests reveal real concurrency issues** in production code that sequential tests would hide
- **Test isolation via unique data** - use UUIDv7 suffixes to prevent data collisions between concurrent tests
- **Failing parallel tests = production bugs** - if tests fail when run concurrently, the production code has concurrency issues that MUST be fixed

### Why Parallel Testing Matters
- **Validates concurrent safety**: Tests running in parallel expose race conditions, deadlocks, and data isolation bugs
- **Mirrors production reality**: Production code runs concurrently; tests should too
- **Forces robust design**: Code that works correctly with parallel tests is inherently more robust
- **Catches subtle bugs**: Sequential tests can pass while hiding critical concurrency flaws

### Parallel Testing Best Practices
- **Use `t.Parallel()` for all tests** unless there's a specific reason (shared external resource, sequential ordering requirement)
- **Design for isolation**: Each test should create unique orthogonal test data (use UUIDv7 for uniqueness)
- **UUIDv7 over counters/timestamps**: Provides time-ordered uniqueness without collision risk
- **Fix code, not tests**: If parallel tests fail, fix the production code's concurrency issues
- **Test data patterns**: Unique database names, unique entity IDs, unique file paths per test

### Parameterized Tests with Parallelism
- **Combine table-driven tests with `t.Parallel()`** for maximum coverage and concurrency validation
- **Each subtest runs in parallel**: Use `t.Run()` + `t.Parallel()` for isolated, concurrent subtests
- **Example pattern**:
```go
func TestMyFunction(t *testing.T) {
    t.Parallel() // Parent test runs in parallel

    tests := []struct {
        name string
        // ... test cases
    }{
        // ... test data with unique identifiers
    }

    for _, tc := range tests {
        tc := tc // Capture range variable
        t.Run(tc.name, func(t *testing.T) {
            t.Parallel() // Each subtest runs in parallel
            // ... test implementation using tc.uniqueID (UUIDv7)
        })
    }
}
```

### Anti-Patterns to Avoid
- **NEVER remove `t.Parallel()` to fix failing tests** - this hides real bugs
- **NEVER use shared state between parallel tests** - each test must be isolated
- **NEVER rely on test execution order** - parallel tests run in arbitrary order
- **NEVER use sequential counters for uniqueness** - use UUIDv7 instead

## Copilot Testing Guidelines

### CRITICAL: NEVER Create Temporary Test Files

**NEVER create temporary test files that require deletion** - deletion requires manual user approval and wastes chat session time.

**ALWAYS create permanent test files** that can be used going forward:
- Add tests to existing test files in the package you're testing
- Create new permanent test files if needed (e.g., `*_regression_test.go`)
- Tests serve as regression prevention and documentation

**Why this matters:**
- Temporary file deletion pauses chat session progress waiting for manual approval
- Incredibly wasteful of tokens and time
- Breaks the continuous work pattern (commit → implement → commit → repeat)

**When testing linting/validation during chat sessions:**
- **Create permanent tests in `internal/cmd/cicd/*_test.go`** - new or existing test files
- Examples: regex validation tests, linting pattern tests, code transformation tests
- All tests execute automatically during Go test runs
- Use descriptive test function names (e.g., `TestEnforceTestPatterns_RegexValidation`)

### Test Helpers and Package Boundaries

- **Use thin test helper wrappers inside the tested package** when a test needs package-level access (or to expose a function for test-only use). Create a `*_test_helpers_test.go` file in the same package with test-only helper functions, rather than changing package-level visibility or altering production code solely for testing.

### cicd Utility Organization and Self-Exclusion Patterns

**CRITICAL ARCHITECTURE RULE**: Commands MUST NOT modify their own production or test code

#### Subdirectory Organization Pattern

**FLAT STRUCTURE**: Commands organized as flat snake_case subdirectories (NO categorization):

```plaintext
internal/cmd/cicd/
├── cicd.go                                     # Main dispatcher
├── cicd_test.go                                # Dispatcher tests
├── common/                                     # Shared utilities
│   ├── logger.go
│   ├── result.go
│   └── summary.go
├── all_enforce_utf8/                           # Command: all-enforce-utf8
│   ├── utf8.go
│   └── utf8_test.go
├── go_enforce_any/                             # Command: go-enforce-any
│   ├── any.go
│   └── any_test.go
├── go_enforce_test_patterns/                   # Command: go-enforce-test-patterns
│   ├── testpatterns.go
│   └── testpatterns_test.go
├── go_check_circular_package_dependencies/     # Command: go-check-circular-package-dependencies
│   ├── circulardeps.go
│   └── circulardeps_test.go
├── go_check_identity_imports/                  # Command: go-check-identity-imports
│   ├── identityimports.go
│   └── identityimports_test.go
├── go_fix_staticcheck_error_strings/           # Command: go-fix-staticcheck-error-strings
│   ├── staticcheck.go
│   └── staticcheck_test.go
├── go_fix_copyloopvar/                         # Command: go-fix-copyloopvar
│   ├── copyloopvar.go
│   └── copyloopvar_test.go
├── go_fix_thelper/                             # Command: go-fix-thelper
│   ├── thelper.go
│   └── thelper_test.go
├── go_fix_all/                                 # Command: go-fix-all
│   ├── all.go
│   └── all_test.go
├── go_update_direct_dependencies/              # Command: go-update-direct-dependencies
│   ├── deps.go
│   └── deps_test.go
├── go_update_all_dependencies/                 # Command: go-update-all-dependencies
│   ├── deps.go
│   └── deps_test.go
└── github_workflow_lint/                       # Command: github-workflow-lint
    ├── workflow.go
    └── workflow_test.go
```

**NAMING RULE**: Command name (kebab-case) → Subdirectory name (snake_case)
- `go-enforce-any` → `go_enforce_any/`
- `all-enforce-utf8` → `all_enforce_utf8/`
- `go-fix-staticcheck-error-strings` → `go_fix_staticcheck_error_strings/`

#### Self-Exclusion Pattern Implementation

**EVERY command MUST exclude its own subdirectory** to prevent self-modification:

1. **Define exclusion pattern** in `internal/common/magic/magic_cicd.go`:

```go
GoEnforceAnyFileExcludePatterns = []string{
    `internal[/\\]cmd[/\\]cicd[/\\]go_enforce_any[/\\].*\.go$`,  // Exclude own subdirectory
    `api/client`, `api/model`, `api/server`,                      // Generated files
    `_gen\.go$`, `\.pb\.go$`, `vendor/`, `.git/`, `node_modules/`, // Standard exclusions
}
```

2. **Use exclusion pattern** in command implementation:

```go
func Enforce(logger *common.Logger, allFiles []string) error {
    // Filter out excluded files FIRST
    filteredFiles := filterFiles(allFiles, cryptoutilMagic.GoEnforceAnyFileExcludePatterns)

    // Process only filtered files
    for _, file := range filteredFiles {
        // ... enforcement logic
    }
}
```

3. **Add self-exclusion test** to verify pattern works:

```go
// go_enforce_any/any_self_exclusion_test.go
func TestEnforce_ExcludesOwnFiles(t *testing.T) {
    t.Parallel()

    logger := common.NewLogger("TestEnforce_ExcludesOwnFiles")

    // Create test file with deliberate violation in own subdirectory
    testFile := "internal/cmd/cicd/go_enforce_any/test_violation.go"
    content := `package go_enforce_any
func Process(data interface{}) { }  // Deliberate violation
`

    // Run enforcement
    err := Enforce(logger, []string{testFile})

    // Should NOT detect violation in own subdirectory
    require.NoError(t, err, "Command should exclude its own subdirectory")
}
```

#### Why Self-Exclusion is Critical

**Problem**: Commands contain test code with deliberate violations (e.g., `interface {}` in `go-enforce-any` tests)

**Without self-exclusion**: Commands detect violations in their own test files and modify them, breaking the tests

**With self-exclusion**: Commands skip their own subdirectory entirely, preserving test integrity

#### File Size and Coverage Requirements

**CRITICAL: cicd utilities are subject to strict quality standards**

**File Size Limits** (from copilot-instructions.md):
- **Soft limit: 300 lines** - Consider refactoring for better maintainability
- **Medium limit: 400 lines** - Should refactor to improve code organization
- **Hard limit: 500 lines** - Must refactor; files exceeding this threshold violate project standards
- Apply to ALL files in cicd subdirectories: production code (*.go), test code (*_test.go), configs, scripts

**Test Coverage Requirements**:
- **cicd utilities: ≥85% coverage** (infrastructure code standard)
- **Individual commands: ≥85% coverage** per subdirectory
- **Critical paths: 100% coverage** (self-exclusion patterns, file filtering, error handling)
- Use `go test ./internal/cmd/cicd/<subdirectory> -coverprofile=test-output/coverage_<command>.out` to verify

**Refactoring Triggers**:
- Production file >300 lines → Extract helper functions or split into multiple files
- Test file >400 lines → Split into multiple test files by functionality (e.g., `*_test.go`, `*_edge_cases_test.go`, `*_self_exclusion_test.go`)
- Coverage <85% → Add missing test cases for error paths and edge cases

#### Command-to-Subdirectory Mapping

| Command Name | Subdirectory | Exclusion Pattern Variable |
|--------------|--------------|----------------------------|
| all-enforce-utf8 | all_enforce_utf8/ | AllEnforceUtf8FileExcludePatterns |
| go-enforce-any | go_enforce_any/ | GoEnforceAnyFileExcludePatterns |
| go-enforce-test-patterns | go_enforce_test_patterns/ | GoEnforceTestPatternsFileExcludePatterns |
| go-check-circular-package-dependencies | go_check_circular_package_dependencies/ | GoCheckCircularPackageDependenciesFileExcludePatterns |
| go-check-identity-imports | go_check_identity_imports/ | GoCheckIdentityImportsFileExcludePatterns |
| go-fix-staticcheck-error-strings | go_fix_staticcheck_error_strings/ | GoFixStaticcheckErrorStringsFileExcludePatterns |
| go-fix-copyloopvar | go_fix_copyloopvar/ | GoFixCopyLoopVarFileExcludePatterns |
| go-fix-thelper | go_fix_thelper/ | GoFixTHelperFileExcludePatterns |
| go-fix-all | go_fix_all/ | GoFixAllFileExcludePatterns |
| go-update-direct-dependencies | go_update_direct_dependencies/ | GoUpdateDirectDependenciesFileExcludePatterns |
| go-update-all-dependencies | go_update_all_dependencies/ | GoUpdateAllDependenciesFileExcludePatterns |
| github-workflow-lint | github_workflow_lint/ | GithubWorkflowLintFileExcludePatterns |

### cicd Utility Testing Patterns

- **ALWAYS use table-driven tests** for command validation logic
- **ALWAYS add self-exclusion test** when creating/modifying commands
- **ALWAYS test with t.TempDir()** to avoid test pollution
- **Target 95%+ coverage** for cicd utility code (higher than standard 80%)
- **Test error paths thoroughly** - commands must handle malformed files gracefully
- **Use descriptive test names** indicating what's being validated (e.g., `TestEnforce_ExcludesOwnFiles`)
