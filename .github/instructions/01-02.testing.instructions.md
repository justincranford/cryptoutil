---
description: "Instructions for testing"
applyTo: "**"
---
# Testing Instructions

## CRITICAL: Test Concurrency - NEVER VIOLATE

**!!! CRITICAL: NEVER use `-p=1` for testing !!!**
**!!! CRITICAL: ALWAYS use concurrent test execution !!!**
**!!! CRITICAL: ALWAYS use `-shuffle` option for go test !!!**
**!!! CRITICAL: Justification for test concurrency is fastest test execution, and reveal concurrency bugs in production code !!!**

**Test Execution Commands**:

```bash
# CORRECT - Concurrent with shuffle
go test ./... -cover -shuffle=on

# CORRECT - Default concurrent execution
go test ./...

# WRONG - Sequential package execution (hides concurrency bugs!)
go test ./... -p=1  # ❌ NEVER DO THIS

# WRONG - Sequential test execution
go test ./... -parallel=1  # ❌ NEVER DO THIS
```

**Why Concurrent Testing is Mandatory**:

1. **Fastest test execution**: Parallel tests = faster feedback loop
2. **Reveals production bugs**: Race conditions, deadlocks, data conflicts exposed
3. **Production validation**: If tests can't run concurrently, production code can't either
4. **Quality assurance**: Concurrent tests = higher confidence in code correctness

**Test Data Isolation Requirements**:

- ✅ **ALWAYS use unique values**: UUIDv7 for all test data (thread-safe, process-safe)
- ✅ **ALWAYS use dynamic ports**: port 0 pattern for test servers
- ✅ **ALWAYS use TestMain for dependencies**: Start once per package (PostgreSQL containers, services)
- ✅ **Real dependencies preferred**: Test containers (PostgreSQL), in-memory services (telemetry)
- ✅ **Mocks only for**: Hard-to-reach corner cases, truly external dependencies

## Core Rules

- Run `go test ./... -cover -shuffle=on` for automated tests; use testify `require` for assertions
- Target coverage: 95%+ production, 100%+ infrastructure (cicd), 100% utility code
- Mutation testing: ≥80% gremlins score per package (mandatory)
- ALWAYS use table-driven tests with `t.Parallel()` - reveals real concurrency bugs
- NEVER hardcode test values - use magic package constants OR runtime-generated UUIDv7
- NEVER create temporary test files requiring deletion - create permanent tests only

## Test Values

**Option A**: Magic values from `internal/identity/magic` package
**Option B**: Generate once, reuse: `id := googleUuid.NewV7()` then use `id` in test cases
**NEVER**: Hardcoded UUIDs, strings, or calling `NewV7()` twice expecting same result

## Table-Driven Pattern (Mandatory)

```go
func TestMyFunction(t *testing.T) {
    t.Parallel()
    tests := []struct{ name string; input string; wantErr bool }{
        {"valid", "good", false},
        {"invalid", "", true},
    }
    for _, tc := range tests {
        tc := tc
        t.Run(tc.name, func(t *testing.T) {
            t.Parallel()
            // test using tc fields
        })
    }
}
```

**WRONG**: Separate `TestX_Case1`, `TestX_Case2` functions for same functionality

## TestMain Pattern for Shared Dependencies

**ALWAYS use TestMain to start test dependencies ONCE per package**:

```go
var testDB *sql.DB

func TestMain(m *testing.M) {
    // Start PostgreSQL container ONCE per package
    testDB = startPostgreSQLContainer()
    exitCode := m.Run()
    testDB.Close()
    os.Exit(exitCode)
}

func TestUserCreate(t *testing.T) {
    t.Parallel() // Safe - each test uses unique UUIDv7 data
    userID := googleUuid.NewV7()
    user := &User{ID: userID, Name: "test-" + userID.String()}
    // Test creates orthogonal data - no conflicts
}
```

**Benefits**:

- Dependencies started ONCE (fast)
- All tests in package reuse shared resources
- Each test creates unique data (no conflicts)
- Concurrent execution safe (orthogonal data)

## Test File Organization

| Type | Suffix | Example |
|------|--------|---------|
| Unit | `_test.go` | `calc_test.go` |
| Bench | `_bench_test.go` | `calc_bench_test.go` |
| Fuzz | `_fuzz_test.go` | `calc_fuzz_test.go` |
| Property | `_property_test.go` | `calc_property_test.go` |
| Integration | `_integration_test.go` | `api_integration_test.go` |

## CRITICAL: Race Condition Testing - Timestamp Comparisons

**NEVER compare database timestamps against `time.Now()` in tests with concurrent execution or async operations:**

```go
// ❌ WRONG - Causes race failures when test execution takes >5s
updatedAtTime := time.Unix(int64(claims["updated_at"].(float64)), 0)
require.WithinDuration(t, time.Now().UTC(), updatedAtTime, 5*time.Second)

// ✅ CORRECT - Compare against original record timestamp
updatedAtTime := time.Unix(int64(claims["updated_at"].(float64)), 0)
require.WithinDuration(t, tc.user.UpdatedAt, updatedAtTime, 5*time.Second)
```

**Why `time.Now()` Fails**:

1. User created at timestamp T0 (e.g., 04:25:39)
2. OAuth flow + HTTP requests take 30-60+ seconds
3. Test assertion runs at T0 + 63s (e.g., 04:26:42)
4. `time.Now()` returns 04:26:42, but DB `updated_at` is still 04:25:39
5. Difference is 63s, exceeds 5s tolerance → test fails

**When This Rule Applies**:

- Database record timestamps (created_at, updated_at)
- OAuth/OIDC token tests with multi-step flows
- Any test with async operations between record creation and assertion
- Race detector tests (ci-race workflow)

**Always compare against source of truth**: The original record timestamp from the database, NOT the current wall clock time.

## Mutation Testing (Mandatory)

- Use [gremlins](https://github.com/go-gremlins/gremlins) for mutation testing
- Target: ≥80% mutation score per package
- Run: `gremlins unleash --tags=!integration` (excludes integration tests)
- Focus on business logic, parsers, validators, crypto operations
- Create baseline report and track improvements in specs/

## Benchmarking (Mandatory for Crypto)

- **ALWAYS create benchmarks for cryptographic operations** (happy and sad paths)
- File suffix: `_bench_test.go`
- Run: `go test -bench=. -benchmem ./pkg/crypto`
- Track performance regressions in CI/CD
- Examples: key generation, encryption/decryption, signing/verification, hashing

```go
func BenchmarkAESEncrypt(b *testing.B) {
    key := make([]byte, 32)
    plaintext := make([]byte, 1024)
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, _ = encrypt(key, plaintext)
    }
}
```

## Fuzz Testing (Mandatory)

- **ALWAYS create fuzz tests for parsers, validators, and input handlers**
- **CRITICAL: Fuzz tests MUST ONLY contain fuzz functions (Fuzz*), NOT unit/property/integration tests**
- Use `//go:build !fuzz` tag to exclude property tests from fuzz test runs
- Fuzz test names MUST be unique, NOT substrings of others (e.g., `FuzzHKDFAllVariants` not `FuzzHKDF`)
- ALWAYS run from project root: `go test -fuzz=FuzzXXX -fuzztime=15s ./path`
- Minimum fuzz time: 15 seconds per test
- Use unquoted names, PowerShell `;` for chaining

**File Organization**:

- `*_fuzz_test.go`: ONLY fuzz functions (FuzzX), no unit tests
- `*_property_test.go`: Property-based tests (gopter) with `//go:build !fuzz` tag
- `*_test.go`: Unit, integration, table-driven tests

**Why Separation Matters**:

- Property tests (gopter) run before fuzzing, can take 30-60s+ for RSA
- Without build tags: Fuzz tests timeout waiting for property tests
- With `//go:build !fuzz`: Fuzz tests run independently in <10s

## Property-Based Testing (Recommended)

- Use [gopter](https://github.com/leanovate/gopter) for property-based testing
- Focus on invariants and mathematical properties
- File suffix: `_property_test.go`
- Examples: encryption(decryption(x)) == x, sign(verify(x)) == x

```go
func TestEncryptionRoundTrip(t *testing.T) {
    properties := gopter.NewProperties(nil)
    properties.Property("encrypt then decrypt returns original", prop.ForAll(
        func(plaintext []byte) bool {
            ciphertext, _ := Encrypt(key, plaintext)
            result, _ := Decrypt(key, ciphertext)
            return bytes.Equal(plaintext, result)
        },
        gen.SliceOf(gen.UInt8()),
    ))
    properties.TestingRun(t)
}
```

## Test Execution

- Place coverage files in `./test-output/`: `go test ./pkg -coverprofile=test-output/coverage_pkg.out`
- Long-running suites (orm, client, server) can take 5-10+ min - use targeted runs: `-run=TestSpecific`

## Test Directory Conventions

| Directory | Purpose | Examples |
|-----------|---------|----------|
| `./test-output/` | Test result outputs | Coverage files, test logs, Report outputs | Autoapprove logs, CI reports |
| `./testdata/` or `pkg/testdata/` | Test input fixtures | YAML configs, test files |

## Dynamic Port Allocation Pattern (Mandatory for Server Tests)

**ALWAYS use port 0 and extract actual assigned port** for server tests to enable concurrent test execution:

```go
// TestMain pattern for Fiber server tests
var (
    testSettings = cryptoutilConfig.RequireNewForTest("pkg_test")
    serverApp    *ServerApplicationListener
    testBaseURL  string
)

func TestMain(m *testing.M) {
    // Config uses port 0 - OS assigns dynamic port
    serverApp, err = StartServerListenerApplication(testSettings)
    if err != nil {
        log.Fatalf("failed to start server: %v", err)
    }
    go serverApp.StartFunction()
    defer serverApp.ShutdownFunction()

    // Extract actual assigned port from listener
    testBaseURL = fmt.Sprintf("https://%s:%d",
        testSettings.BindPublicAddress,
        serverApp.ActualPublicPort)  // Use actual port, not config port

    exitCode := m.Run()
    os.Exit(exitCode)
}
```

**Why**: Hard-coded ports cause port conflicts when tests run in parallel. Dynamic allocation ensures each test gets a unique port.

**Reference**: `internal/server/application/application_test.go` and `application_listener.go` lines 310-360

## cicd Utility Testing

- Commands organized as `internal/cmd/cicd/<snake_case>/` subdirectories
- EVERY command MUST exclude its own subdirectory (self-exclusion pattern)
- Define exclusion in `internal/common/magic/magic_cicd.go`
- Add self-exclusion test to verify pattern works
- Target 95%+ coverage per command subdirectory

## Parallel Testing Philosophy

- `t.Parallel()` is a FEATURE - reveals race conditions sequential tests hide
- Failing parallel tests = production bugs to fix (don't remove `t.Parallel()`)
- Use UUIDv7 for test data isolation between concurrent tests
