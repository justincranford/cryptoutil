---
description: "Common anti-patterns and mistakes to avoid based on post-mortems and session learnings"
applyTo: "**"
---
# Anti-Patterns and Lessons Learned

**Reference**: See `.specify/memory/anti-patterns.md` for complete specifications (P0 incidents, historical lessons, pattern recognition, key takeaways)

**This file contains ONLY tactical patterns**

## CRITICAL Regression-Prone Areas

### Format_go Self-Modification

❌ NEVER modify `enforce_any.go` or `format_go_test.go` without reading complete package context
✅ ALWAYS read filter.go, magic_cicd.go, self_modification_test.go before refactoring

### Windows Firewall Exception Prevention - CRITICAL

**Problem**: Binding to `0.0.0.0` triggers Windows Firewall prompts, blocking automation

**MANDATORY: ALWAYS bind to 127.0.0.1 (NEVER 0.0.0.0) in tests and local development**

```go
// ✅ CORRECT: Bind to loopback only (no firewall prompt)
addr := fmt.Sprintf("%s:%d", cryptoutilMagic.IPv4Loopback, port)  // "127.0.0.1"
listener, err := net.Listen("tcp", addr)

// ❌ WRONG: Bind to all interfaces (triggers firewall prompt)
listener, err := net.Listen("tcp", fmt.Sprintf("0.0.0.0:%d", port))
```

**Impact**: Each `0.0.0.0` binding = 1 Windows Firewall popup, blocks CI/CD

### Localhost vs 127.0.0.1 Decision Matrix

| Environment | Preferred | Rationale |
|-------------|-----------|-----------|
| Local Windows Dev | `127.0.0.1` | Avoid firewall prompts |
| GitHub Workflows | `127.0.0.1` | Explicit IPv4, no DNS resolution |
| Docker Containers (internal) | `127.0.0.1` | Alpine resolves localhost to ::1 (IPv6) |
| Docker Compose (host→container) | `localhost` | Docker DNS handles resolution |
| Go Code (bind addresses) | `127.0.0.1` | Explicit IPv4, no ambiguity |
| Go Code (database DSN) | `localhost` | PostgreSQL driver handles resolution |

---

## Testing Anti-Patterns

### Individual Test Functions vs Table-Driven

❌ 1371-line test file with TestFunc_Variant1, TestFunc_Variant2... (exceeds 500-line hard limit)
✅ Table-driven tests with variants as rows

### Race Detector Timeouts

✅ Use 10+ second timeouts for network ops in race mode (~10× overhead)

---

## Git Workflow Anti-Patterns

### Amending Repeatedly (Loses History)

**NEVER DO**: Use `git commit --amend` repeatedly (loses history, breaks bisect)

**ALWAYS DO**: Commit each logical unit independently

```bash
git commit -m "fix(format_go): restore clean baseline from 07192eac"
git commit -m "fix(format_go): add defensive check with filepath.Abs()"
git commit -m "test(format_go): verify self_modification_test catches regressions"
```

### Applying Fixes to Corrupted HEAD

**ALWAYS DO**: Restore clean baseline from known-good commit FIRST

```bash
git log --oneline --grep="baseline" | head -5
git checkout 07192eac -- path/to/package/
go test ./path/to/package/  # Verify baseline works
# Apply targeted fix
git commit -m "fix(package): add defensive check"
```

---

## Documentation Anti-Patterns

**NEVER DO**: Create `docs/SESSION-2025-12-14-*.md` files (documentation bloat)

**ALWAYS DO**: Append to `specs/*/implement/DETAILED.md` Section 2 timeline

---

## Performance Anti-Patterns

### Mutation Testing Timeout (>45 minutes)

**ALWAYS DO**: Parallelize by package using GitHub Actions matrix strategy

### Test Timing Violations (>15s per package)

**ALWAYS DO**: Use `TestProbTenth` (10%) or `TestProbQuarter` (25%) for algorithm variants

---

## Key Takeaways

1. **Context Reading**: ALWAYS read complete context before refactoring self-modifying code
2. **Windows Firewall**: ALWAYS bind to 127.0.0.1 in tests (NEVER 0.0.0.0)
3. **Coverage Analysis**: ALWAYS analyze baseline HTML before writing tests
4. **Incremental Commits**: NEVER amend repeatedly - preserve history for bisect
5. **Restore from Clean**: ALWAYS restore clean baseline before applying fixes
6. **Port Conflicts**: Remove host port mappings for shared services in Docker Compose
7. **Mutation Parallelization**: NEVER run sequentially - use GitHub Actions matrix
8. **Test Timeouts**: ALWAYS increase timeouts 10× for race detector mode

## CRITICAL Regression-Prone Areas

### Format_go Self-Modification (P0 Incidents)

**Root Cause**: LLM agents lose exclusion context during narrow-focus refactoring

**NEVER DO**:

- ❌ Modify comments/test data in `enforce_any.go` or `format_go_test.go`
- ❌ Change `` `interface{}` `` to `` `any` `` in format_go package without reading full context
- ❌ Refactor code in isolation without reading related files

**ALWAYS DO**:

- ✅ Read complete package context before refactoring self-modifying code
- ✅ Check for CRITICAL/SELF-MODIFICATION tags in comments
- ✅ Verify self-exclusion patterns exist and are respected
- ✅ Run tests after ANY changes to format_go package

**Pattern Recognition**:

- **CRITICAL comments**: NEVER simplify or remove without understanding purpose
- **Backticked strings** in code: Intentional protection against replacement
- **Test data patterns**: May use "wrong" values intentionally

### Windows Firewall Exception Prevention

**Problem**: Binding to `0.0.0.0` triggers Windows Firewall prompts, blocking automation

**NEVER DO**:

- ❌ Bind to `0.0.0.0` in unit tests or integration tests
- ❌ Use `localhost` (may resolve to IPv6 `::1`)

**ALWAYS DO**:

- ✅ Bind to `127.0.0.1` (IPv4 loopback) in tests
- ✅ Use `0.0.0.0` ONLY in Docker containers (isolated network namespace)

**Why**: Each `0.0.0.0` binding = 1 firewall popup = blocked CI/CD

### SQLite Connection Pool Deadlocks

**Problem**: GORM explicit transactions require multiple connections, MaxOpenConns=1 causes deadlock

**NEVER DO**:

- ❌ Set `MaxOpenConns=1` with GORM transactions
- ❌ Use `sql.TxOptions{ReadOnly: true}` with SQLite (not supported)

**ALWAYS DO**:

- ✅ Set `MaxOpenConns=5` for GORM transaction support
- ✅ Enable WAL mode: `PRAGMA journal_mode=WAL;`
- ✅ Set busy timeout: `PRAGMA busy_timeout = 30000;`
- ✅ Use standard transactions for read operations (SQLite doesn't support read-only)

**Rationale**: GORM transaction wrapper requires separate connection from base operations

### Docker Compose Port Conflicts (E2E Failures)

**Problem**: Multiple services include same telemetry compose file, causing port conflicts

**Root Cause** (2025-12-19 session): CA and JOSE deployments both try to bind OTEL collector ports 4317, 4318, 8888, 8889, 13133 to host

**NEVER DO**:

- ❌ Expose container ports to host if multiple instances may run simultaneously
- ❌ Use same compose include in multiple services without considering port conflicts

**ALWAYS DO**:

- ✅ Use container-to-container networking (no host port mappings) for shared services
- ✅ Services communicate via Docker network using container names (e.g., `opentelemetry-collector-contrib:4317`)
- ✅ Test E2E workflows with sequential deployments to catch port conflicts

**Pattern**: If `docker compose up` for service B fails after service A succeeds, check for port conflicts in included compose files

### Incomplete Service Implementation (Workflow Debugging)

**Problem**: Missing public HTTP servers cause cascading configuration errors that mask root cause

**Root Cause** (2025-12-20 WORKFLOW-FIXES): Identity services missing `server.go` files - only admin servers implemented

**Symptom Pattern**:

- Configuration fixes change error messages (TLS → DSN → credentials)
- Eventually hit error that doesn't change despite valid fixes
- Container logs show early crash (196 bytes vs 331 bytes initial)
- Zero symptom change = implementation issue, not configuration

**NEVER DO**:

- ❌ Keep applying configuration fixes when symptoms don't change
- ❌ Assume container crash is always a configuration problem
- ❌ Debug configuration before verifying complete architecture exists

**ALWAYS DO**:

- ✅ **Code archaeology FIRST** - compare with working service before debugging config
- ✅ Verify all required files exist (server.go, application.go, admin.go)
- ✅ Check Application.Start() initializes both public + admin servers
- ✅ Compare container log byte counts across fix attempts (decreasing = earlier crash = deeper problem)
- ✅ If fixes have zero symptom change → look for missing code, not config

**Detection Pattern**:

```
Round 3: 331 bytes - "TLS cert file required"
Round 4: 313 bytes - "database DSN required"
Round 5: 196 bytes - "Starting AuthZ server..." (no error logged)
Round 6: 196 bytes - SAME (zero change after valid fix)
→ Missing public HTTP server implementation
```

**Time Wasted Pattern**:

- Configuration debugging: 40-60 minutes (4-6 rounds × 10min each)
- Code archaeology upfront: 9 minutes (download logs + compare architecture)
- **Lesson**: Code archaeology should be FIRST step, not last resort

**Reference**: See `docs/WORKFLOW-FIXES-CONSOLIDATED.md` for complete timeline

---

## Testing Anti-Patterns

### Individual Test Functions vs Table-Driven

❌ Separate TestFunc_Variant1/2/3 functions → 1371-line file (2.7× limit)
✅ Table-driven with variants as rows, keep files <500 lines

### Race Detector Timeouts

✅ Use 10+ second timeouts for network ops in race mode (~10× overhead)

**Pattern**: `context deadline exceeded` errors under `-race` = insufficient timeout, not actual bug

---

## Git Workflow Anti-Patterns

### Amending Repeatedly (Loses History)

**Problem**: Using `git commit --amend` repeatedly loses history, masks mistakes, breaks bisect

**NEVER DO**:

- ❌ Amend commit after push (breaks shared history)
- ❌ Amend repeatedly during debugging session
- ❌ Use amend to hide incremental fixes

**ALWAYS DO**:

- ✅ Commit each logical unit independently
- ✅ Preserve full timeline of changes and decisions
- ✅ Enable git bisect to identify when bugs were introduced
- ✅ Use amend ONLY for immediate typo fixes (within 1 minute, before push)

**Rationale**: Incremental commits preserve context, enable selective revert, show thought process

### Applying Fixes to Corrupted HEAD

**Problem**: Assuming HEAD is correct when it may be corrupted from previous failed attempts

**NEVER DO**:

- ❌ Apply "one more fix" on top of corrupted code
- ❌ Mix baseline restoration with new fixes in same commit
- ❌ Assume HEAD is always clean

**ALWAYS DO**:

- ✅ Restore clean baseline from known-good commit FIRST
- ✅ Verify baseline works (tests pass)
- ✅ Apply ONLY the new fix (minimal change)
- ✅ Commit as NEW commit with clear description

**Pattern**: Find last known-good commit → restore entire package → verify → apply targeted fix → verify → commit

---

## Documentation Anti-Patterns

### Creating Standalone Session Documentation

**Problem**: Creating `docs/SESSION-2025-12-14-*.md` files leads to documentation bloat

**NEVER DO**:

- ❌ Create dated session documentation files
- ❌ Create standalone analysis documents for session work
- ❌ Create separate work log files per session

**ALWAYS DO**:

- ✅ Append to `specs/*/implement/DETAILED.md` Section 2 timeline
- ✅ Single source of truth for implementation timeline
- ✅ Create separate docs ONLY for permanent reference material (ADRs, post-mortems, user guides)

**Rule of Thumb**: If it's session-specific work → append to DETAILED.md. If it's permanent reference → create dedicated doc.

---

## Architecture Anti-Patterns

### Missing Service Federation Configuration

**Problem**: Services don't know how to discover or communicate with federated services

**NEVER DO**:

- ❌ Hardcode service URLs in application code
- ❌ Assume services are always co-located

**ALWAYS DO**:

- ✅ Use configuration for service discovery (YAML, environment, DNS)
- ✅ Support multiple federation patterns (DNS, config files, service mesh)
- ✅ Implement graceful degradation when federated services unavailable

**Pattern**: Service A depends on Service B → configure B's URL in A's config, not hardcode

---

## Performance Anti-Patterns

### Mutation Testing Timeout

✅ Parallelize by package using GitHub Actions matrix (4-6 packages per job, <15min timeout)
❌ NEVER run sequentially on all packages

### Test Timing Violations

✅ Use `TestProbTenth` (10%) or `TestProbQuarter` (25%) for algorithm variants
✅ Target <15s per package, <180s full unit suite
