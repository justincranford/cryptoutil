---
description: "Instructions for SQLite configuration with GORM, transaction patterns, and concurrent operations"
applyTo: "**"
---
# SQLite Configuration for GORM with Concurrent Transactions

## CRITICAL: Architecture Understanding

**GORM with explicit transactions requires multiple connections even for SQLite:**
- Explicit transaction: Uses 1 connection for `db.Transaction(func(tx *gorm.DB))`
- CRUD operations inside transaction: Need separate connection(s) to execute
- **MaxOpenConns=1 causes self-deadlock** when transaction wraps CRUD operations

## modernc.org/sqlite Driver Configuration (CGO-Free)

**ALWAYS use explicit sql.Open with modernc driver:**

```go
sqlDB, err := sql.Open("sqlite", dsn)  // Forces modernc.org/sqlite (CGO-free)
if err != nil {
    return nil, fmt.Errorf("failed to open SQLite database: %w", err)
}

// Apply PRAGMA settings BEFORE passing to GORM.
if _, err := sqlDB.Exec("PRAGMA journal_mode=WAL;"); err != nil {
    return nil, fmt.Errorf("failed to enable WAL mode: %w", err)
}
if _, err := sqlDB.Exec("PRAGMA busy_timeout = 30000;"); err != nil {
    return nil, fmt.Errorf("failed to set busy timeout: %w", err)
}

// Pass existing connection to GORM via Dialector.
dialector := sqlite.Dialector{Conn: sqlDB}
```

**NEVER use `sqlite.Open(dsn)`** - attempts go-sqlite3 (CGO), fails with CGO_ENABLED=0

## GORM Configuration for Transactions

**CRITICAL: Disable GORM's automatic transactions:**

```go
db, err := gorm.Open(dialector, &gorm.Config{
    Logger:                 gormLogger,
    SkipDefaultTransaction: true,  // Prevents nested transaction deadlocks
})
```

**Why:** GORM wraps Create/Update/Delete in automatic transactions. When your code uses explicit `db.Transaction()`, you get nested transactions requiring 2+ connections.

## Connection Pool Settings for SQLite + GORM

**CRITICAL: Use MaxOpenConns=5 for GORM transaction pattern:**

```go
sqlDB, err := db.DB()  // Get GORM's sql.DB instance
if err != nil {
    return nil, fmt.Errorf("failed to get database instance: %w", err)
}

if cfg.Type == "sqlite" {
    sqlDB.SetMaxOpenConns(5)  // Allows transaction + operations concurrently
    sqlDB.SetMaxIdleConns(5)
    sqlDB.SetConnMaxLifetime(0)  // In-memory DB: never close connections
    sqlDB.SetConnMaxIdleTime(0)
}
```

**Why 5 connections:**
- SQLite WAL mode: multiple readers + 1 writer
- GORM pattern: 1 for transaction context, 1+ for operations inside transaction
- Parallel tests: multiple test goroutines need separate connections
- Balance between concurrency and resource usage

## Transaction Context Propagation Pattern

**Store transaction DB in context for repository awareness:**

```go
// In shared ORM package (internal/identity/repository/orm/transaction.go):
type contextKey string
const txKey contextKey = "gorm_tx"

func getDB(ctx context.Context, baseDB *gorm.DB) *gorm.DB {
    if tx, ok := ctx.Value(txKey).(*gorm.DB); ok {
        return tx  // Use transaction DB from context
    }
    return baseDB  // Fallback to base DB for non-transactional operations
}

// In repository factory:
func (f *RepositoryFactory) Transaction(ctx context.Context, fn func(context.Context) error) error {
    return f.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        txCtx := context.WithValue(ctx, txKey, tx)  // Store tx in context
        return fn(txCtx)
    })
}

// In ORM repositories:
func (r *UserRepositoryGORM) Create(ctx context.Context, user *User) error {
    return getDB(ctx, r.db).WithContext(ctx).Create(user).Error
}
```

**Benefits:**
- Repositories automatically use transaction DB when inside Transaction()
- No need for separate transaction-aware repository methods
- Single cached repository instance works for both transactional and non-transactional operations

## Comparison with Direct database/sql Pattern

**KMS server (database/sql) vs Identity server (GORM):**

| Pattern | KMS Server (sql_provider.go) | Identity Server (database.go) |
|---------|------------------------------|-------------------------------|
| ORM | No (direct database/sql) | Yes (GORM) |
| Explicit transactions | Manual BeginTx/Commit/Rollback | `db.Transaction(func(tx))` |
| Auto transactions | N/A | Disabled via SkipDefaultTransaction |
| MaxOpenConns | 1 (no nested operations) | 5 (transaction + operations) |
| Why different | Single connection per operation | Transaction wraps multiple operations |

**Key insight:** MaxOpenConns=1 works for direct database/sql (no nesting), but GORM's transaction pattern requires multiple connections.

## Root Cause of Original Deadlock

**Symptom:** Tests hung for 10 minutes, goroutine dump showed waiting for connection

**Causes (all required for deadlock):**
1. MaxOpenConns=1 (only one connection available)
2. Explicit transaction holding that connection
3. CRUD operation inside transaction trying to get another connection
4. Either: GORM's automatic transaction wrapping (fixed by SkipDefaultTransaction), OR
5. The operation needing separate connection to execute (fixed by MaxOpenConns=5)

**Fix:** Increase MaxOpenConns + disable GORM auto-transactions + context-based transaction awareness

## Common Mistakes to Avoid

**❌ NEVER do this:**
```go
// Using sqlite.Open() directly (attempts go-sqlite3)
dialector := sqlite.Open(dsn) // WRONG - requires CGO!

// Setting MaxOpenConns=1 with GORM transactions
sqlDB.SetMaxOpenConns(1) // WRONG - causes transaction deadlocks with GORM!

// Not disabling GORM's automatic transactions
db, err := gorm.Open(dialector, &gorm.Config{}) // Missing SkipDefaultTransaction!

// Not propagating transaction context to repositories
func (r *UserRepo) Create(ctx context.Context, user *User) error {
    return r.db.Create(user).Error // WRONG - ignores transaction in context!
}
```

**✅ ALWAYS do this:**
```go
// Explicit modernc.org/sqlite with PRAGMA before GORM
sqlDB, err := sql.Open("sqlite", dsn)
sqlDB.Exec("PRAGMA journal_mode=WAL;")
sqlDB.Exec("PRAGMA busy_timeout = 30000;")
dialector := sqlite.Dialector{Conn: sqlDB}

// Disable GORM auto-transactions + set MaxOpenConns=5
db, err := gorm.Open(dialector, &gorm.Config{SkipDefaultTransaction: true})
sqlDB, _ = db.DB()
sqlDB.SetMaxOpenConns(5)

// Context-aware repository operations
func (r *UserRepo) Create(ctx context.Context, user *User) error {
    return getDB(ctx, r.db).WithContext(ctx).Create(user).Error
}
```

## References

- KMS Server: `internal/server/repository/sqlrepository/sql_provider.go` (direct database/sql, MaxOpenConns=1)
- Identity Server: `internal/identity/repository/database.go` (GORM pattern, MaxOpenConns=5)
- Transaction context: `internal/identity/repository/orm/transaction.go` (shared getDB helper)
- Repository example: `internal/identity/repository/orm/user_repository.go` (context-aware operations)

## In-Memory Database Shared Cache

**CRITICAL: Use shared cache mode for in-memory databases:**

```go
const (
    dsnMemory = ":memory:"
    dsnMemoryShared = "file::memory:?cache=shared"
)

// Convert :memory: to shared cache mode.
dsn := cfg.DSN
if dsn == dsnMemory {
    dsn = dsnMemoryShared
}
```

**WHY:** Without shared cache, each connection gets its own isolated in-memory database. With shared cache, all connections (up to MaxOpenConns=5) share the same in-memory database instance.

## Troubleshooting

**Symptom:** "Binary was compiled with 'CGO_ENABLED=0', go-sqlite3 requires cgo"
**Fix:** Use `sql.Open("sqlite", dsn)` + `sqlite.Dialector{Conn: sqlDB}` instead of `sqlite.Open(dsn)`

**Symptom:** Tests hang for minutes, goroutine dump shows waiting for database connection
**Fix:** MaxOpenConns=1 with GORM transactions causes deadlocks. Set MaxOpenConns=5 and SkipDefaultTransaction=true

**Symptom:** PRAGMA settings not taking effect
**Fix:** Execute PRAGMA on sql.DB before passing to GORM via Dialector{Conn: sqlDB}

**Symptom:** Operations inside transactions fail with "database is locked"
**Fix:** Ensure repositories use `getDB(ctx, r.db)` pattern to retrieve transaction DB from context
