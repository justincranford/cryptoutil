---
description: "Instructions for Dynamic Application Security Testing (DAST): Nuclei scanning, ZAP testing, and workflow execution"
applyTo: "**"
---
# DAST Instructions

## CI-DAST Lessons Learned - CRITICAL

**MANDATORY: Follow these patterns to avoid repeating PostgreSQL configuration and variable expansion mistakes**

### PostgreSQL Service Configuration Pattern

**ALWAYS use consistent credentials across all workflows:**

```yaml
env:
  POSTGRES_HOST: localhost
  POSTGRES_PORT: 5432
  POSTGRES_NAME: cryptoutil_test
  POSTGRES_USER: cryptoutil
  POSTGRES_PASS: cryptoutil_test_password

jobs:
  test-job:
    services:
      postgres:
        image: postgres:18
        env:
          POSTGRES_DB: ${{ env.POSTGRES_NAME }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASS }}
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
```

**CRITICAL RULES**:

- ✅ ALWAYS use cryptoutil_test/cryptoutil/cryptoutil_test_password across ALL workflows
- ✅ ALWAYS verify PostgreSQL service env vars match workflow env vars
- ❌ NEVER use test credentials like DB/USR/PWD (causes "role 'root' does not exist" errors)
- ❌ NEVER use different credentials per workflow (breaks consistency, causes debugging issues)

**Historical Mistakes**:

- ci-dast used POSTGRES_NAME: DB, POSTGRES_USER: USR, POSTGRES_PASS: PWD
- Application attempted to connect using these variables but PostgreSQL service rejected them
- PostgreSQL logs showed "FATAL: role 'root' does not exist" (27+ occurrences over 5 minutes)
- Root cause: Mismatch between workflow env vars and PostgreSQL service expectations
- Fix: Align all workflows to use cryptoutil_test/cryptoutil/cryptoutil_test_password

### Variable Expansion in Heredocs Pattern

**ALWAYS use curly braces `${VAR}` syntax for variable expansion in Bash heredocs:**

```yaml
- name: Generate config
  run: |
    cat > ./configs/test/config.yml <<EOF
    database-url: "postgres://${POSTGRES_USER}:${POSTGRES_PASS}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_NAME}?sslmode=disable"
    bind-public-address: "${APP_BIND_PUBLIC_ADDRESS}"
    bind-public-port: ${APP_BIND_PUBLIC_PORT}
    EOF
```

**CRITICAL RULES**:

- ✅ ALWAYS use `${VAR}` syntax (curly braces) for explicit variable expansion
- ✅ ALWAYS verify generated config files have expanded values (not literal $VAR strings)
- ✅ ALWAYS test config generation with `cat config.yml` step in workflow
- ❌ NEVER use `$VAR` syntax in heredocs (may write literal "$VAR" to file instead of expanded value)
- ❌ NEVER rely on implicit variable expansion behavior (shell-dependent, error-prone)

**Historical Mistakes**:

- ci-dast used `$POSTGRES_USER` instead of `${POSTGRES_USER}` in heredoc
- Heredoc wrote literal string "$POSTGRES_USER" to config.yml instead of expanded value
- Application read literal "$POSTGRES_USER" as username, failed to parse, defaulted to 'root'
- PostgreSQL rejected connection attempts with "role 'root' does not exist"
- Workflow logs showed `database-url: ***$POSTGRES_HOST:$POSTGRES_PORT/$POSTGRES_NAME` (literal dollar signs)
- Fix: Change all `$VAR` → `${VAR}` in heredoc (7 variables affected)

### Debugging Workflow PostgreSQL Issues

**When PostgreSQL connection errors occur in workflows:**

1. **Download workflow artifacts** - container logs, PostgreSQL logs
2. **Check PostgreSQL logs** - look for "FATAL: role '<username>' does not exist" patterns
3. **Verify credentials** - compare workflow env vars vs service container env vars
4. **Check config generation** - search workflow logs for generated config output
5. **Verify variable expansion** - ensure config has expanded values, not literal $VAR strings
6. **Compare with working workflows** - ci-coverage, ci-mutation, ci-race use correct pattern

**Evidence-Based Root Cause Analysis**:

- Frequency of errors: 27+ occurrences over 5 minutes indicates persistent misconfiguration
- Error pattern: Every 10 seconds suggests health check retry loop
- Log correlation: PostgreSQL startup succeeded, connections rejected = credentials issue
- Config output analysis: Literal "$POSTGRES_HOST" in logs = variable expansion issue

### Preventive Checklist for All 9 Services

**Before deploying new service or modifying existing workflow:**

- [ ] PostgreSQL credentials use cryptoutil_test/cryptoutil/cryptoutil_test_password
- [ ] Workflow env vars match PostgreSQL service container env vars
- [ ] Config generation uses `${VAR}` syntax (curly braces) for ALL variables
- [ ] Config generation includes verification step (`cat config.yml` in workflow logs)
- [ ] Workflow tested locally with Docker Compose before pushing
- [ ] Workflow logs reviewed after first run to verify config correctness
- [ ] PostgreSQL service health check configured (pg_isready, interval 10s)
- [ ] Application startup includes database connection verification

**Cross-References**:

- PostgreSQL service requirements: See `04-01.github.instructions.md`
- Service template health checks: See `02-03.health-checks.instructions.md`
- Database configuration patterns: See `02-10.database.instructions.md`

## Nuclei Vulnerability Scanning

**ALWAYS start cryptoutil services before running nuclei scans:**

```sh
# Prerequisites - start services first
docker compose -f ./deployments/compose/compose.yml down -v
docker compose -f ./deployments/compose/compose.yml up -d

# Verify services are ready
docker compose exec cryptoutil-sqlite wget --no-check-certificate -q -O - https://127.0.0.1:8080/ui/swagger/doc.json
```

**Manual Nuclei Scan Commands:**

```sh
# Quick security scan (info/low severity, fast)
nuclei -target https://localhost:8080/ -severity info,low

# Comprehensive security scan (medium/high/critical severity)
nuclei -target https://localhost:8080/ -severity medium,high,critical

# Targeted scans by vulnerability type
nuclei -target https://localhost:8080/ -tags cves,vulnerabilities

# Performance-optimized scans
nuclei -target https://localhost:8080/ -c 25 -rl 100 -severity high,critical
```

**Template Management:**

```sh
# Update nuclei templates
nuclei -update-templates

# Check template version
nuclei -templates-version
```
