---
description: "Database, SQLite/GORM, and server builder patterns"
applyTo: "**"
---
# Data Infrastructure

## Cross-DB Compatibility - Quick Reference

| Feature | PostgreSQL | SQLite | Solution |
|---------|-----------|---------|----------|
| UUID Type | uuid, text | text only | Use `type:text` |
| Nullable UUIDs | *UUID, NullableUUID | NullableUUID only | Use NullableUUID |
| JSON Arrays | json, text | text only | Use `serializer:json` |
| Read-Only Tx | Supported | NOT supported | Use standard tx |

See [ARCHITECTURE.md Section 7. Data Architecture](../../docs/ARCHITECTURE.md#7-data-architecture) for cross-database compatibility patterns and GORM strategies.

## Core GORM Patterns

**UUID Fields** (cross-DB compatible):

```go
ID googleUuid.UUID `gorm:"type:text;primaryKey"`  // Works everywhere
```

**Nullable UUIDs** (avoid pointer UUIDs):

```go
ClientProfileID NullableUUID `gorm:"type:text;index"`  // Custom sql.Scanner type
```

**JSON Arrays/Objects** (cross-DB compatible):

```go
AllowedScopes []string `gorm:"serializer:json"`  // Works everywhere
```

**Database DSN**:

```go
dsn := "postgres://user:pass@localhost:5432/dbname?sslmode=disable"
```

See [ARCHITECTURE.md Section 7. Data Architecture](../../docs/ARCHITECTURE.md#7-data-architecture) for comprehensive GORM patterns and database configuration.

## SQLite Configuration - CRITICAL

**Required PRAGMA settings for concurrent operations**:

```go
sqlDB, _ := sql.Open("sqlite", dsn)
sqlDB.Exec("PRAGMA journal_mode=WAL;")       // Concurrent reads + 1 writer
sqlDB.Exec("PRAGMA busy_timeout = 30000;")   // 30s retry on lock

// Pass to GORM
dialector := sqlite.Dialector{Conn: sqlDB}
db, _ := gorm.Open(dialector, &gorm.Config{SkipDefaultTransaction: true})

// Connection pool for GORM transactions
sqlDB, _ = db.DB()
sqlDB.SetMaxOpenConns(5)   // GORM tx needs separate connection from base ops
sqlDB.SetMaxIdleConns(5)
sqlDB.SetConnMaxLifetime(0) // In-memory: never close
```

**CGO-Free Driver**: Use modernc.org/sqlite (NEVER mattn/go-sqlite3 which requires CGO).

**Read-Only Tx**: SQLite does NOT support read-only transactions. Use standard tx or direct queries.

**In-Memory Shared Cache**: Use `file::memory:?cache=shared` for consistent state across connections.

### Connection Pool Rules

| Context | MaxOpenConns | Reason |
|---------|-------------|--------|
| GORM services | 5 | Transaction needs separate connection |
| Raw database/sql (KMS only) | 1 | Single writer sufficient |

### Transaction Context Pattern

```go
func getDB(ctx context.Context, baseDB *gorm.DB) *gorm.DB {
    if tx, ok := ctx.Value(txKey).(*gorm.DB); ok { return tx }
    return baseDB
}
// Repositories: return getDB(ctx, r.db).WithContext(ctx).Create(user).Error
```

### Common SQLite Issues

- **"cgo required"**: Use `sql.Open("sqlite")` not `sqlite.Open(dsn)`
- **Tests hang**: MaxOpenConns=1 + GORM tx = deadlock. Set MaxOpenConns=5.
- **"database locked"**: Missing WAL mode or repos not using `getDB(ctx, r.db)` pattern.

See [ARCHITECTURE.md Section 7. Data Architecture](../../docs/ARCHITECTURE.md#7-data-architecture) and [Section 10.3 Integration Testing Strategy](../../docs/ARCHITECTURE.md#103-integration-testing-strategy) for SQLite configuration and testing patterns.

## Multi-Tenancy - MANDATORY

**Schema-Level Isolation ONLY**: Each tenant gets separate schema (`tenant_<uuid>.users`).
**NEVER**: Row-level multi-tenancy. Set `search_path` per connection.

See [ARCHITECTURE.md Section 2.2 Architecture Strategy](../../docs/ARCHITECTURE.md#22-architecture-strategy) and [Section 7. Data Architecture](../../docs/ARCHITECTURE.md#7-data-architecture) for multi-tenancy patterns and schema isolation strategies.

## Migrations

**Use golang-migrate with embedded files** (`//go:embed migrations/*.sql`), run on startup.
**Naming**: `0001_init.up.sql`, `0001_init.down.sql`

See [ARCHITECTURE.md Section 5.2 Service Builder Pattern](../../docs/ARCHITECTURE.md#52-service-builder-pattern) and [Section 7. Data Architecture](../../docs/ARCHITECTURE.md#7-data-architecture) for migration management and versioning patterns.

## Connection Pooling

| Database | MaxOpen | MaxIdle | MaxLifetime |
|----------|---------|---------|-------------|
| PostgreSQL | 25 | 10 | 1h |
| SQLite + GORM | 5 | 5 | 0 (in-memory) |
| SQLite + raw sql (KMS) | 1 | 1 | 0 |

See [ARCHITECTURE.md Section 7. Data Architecture](../../docs/ARCHITECTURE.md#7-data-architecture) for connection pooling configuration and best practices.

## Error Mapping

**Pattern**: toAppErr method maps GORM errors to HTTP errors (ErrRecordNotFound -> 404, ErrDuplicatedKey -> 409).

See [ARCHITECTURE.md Section 8. API Architecture](../../docs/ARCHITECTURE.md#8-api-architecture) for error mapping and HTTP status code patterns.

## Server Builder Pattern

### Builder Usage

```go
builder := cryptoutilTemplateBuilder.NewServerBuilder(ctx, cfg.ServiceTemplateServerSettings)
builder.WithDomainMigrations(repository.MigrationsFS, "migrations")
builder.WithPublicRouteRegistration(func(
    base *cryptoutilTemplateServer.PublicServerBase,
    res *cryptoutilTemplateBuilder.ServiceResources,
) error {
    // Create domain repositories, register routes
    return nil
})
resources, err := builder.Build()
```

### ServiceResources

Builder returns initialized infrastructure: DB (GORM), TelemetryService, JWKGenService, BarrierService, UnsealKeysService, SessionManager, RealmService, Application, ShutdownCore(), ShutdownContainer().

### Merged Migrations

**Problem**: golang-migrate validates ALL versions against source FS. Template migrations (1001-1004) in schema_migrations but domain FS only has 2001+.

**Solution**: `mergedMigrations` type implements `fs.FS` interface. Try domain FS first, fallback to template FS. golang-migrate sees unified stream.

**Migration Ranges**: Template 1001-1004 (sessions, barrier, realms, tenants). Domain 2001+ (application-specific).

### Registration Flow (No Default Tenant)

`WithDefaultTenant()` is REMOVED. Services start "cold". Clients register via `POST /service/api/v1/auth/register`.

### Test Compatibility

Services using builder MUST provide accessor methods:

```go
func (s *Server) PublicBaseURL() string { return s.app.PublicBaseURL() }
func (s *Server) AdminBaseURL() string { return s.app.AdminBaseURL() }
func (s *Server) SetReady(ready bool) { s.app.SetReady(ready) }
```

### Phase 13 Extensions

- **DatabaseConfig**: GORM mode is MANDATORY for all services.
- **JWTAuth modes**: Session (default), Required, Optional.
- **StrictServer**: oapi-codegen strict server pattern.
- **Barrier**: MANDATORY, always enabled.
- **MigrationConfig**: TemplateWithDomain (default) or DomainOnly.

### Troubleshooting

- **"no migration found for version X"**: Use `WithDomainMigrations()` for merged FS.
- **Server starts but health fails**: Ensure `SetReady(true)` after init.
- **Tests "connection refused"**: Use `WaitForReady(ctx, 10*time.Second)` after Start().
- **Missing implementation**: Compare with working service BEFORE debugging config (code archaeology first).

See [ARCHITECTURE.md Section 5.2 Service Builder Pattern](../../docs/ARCHITECTURE.md#52-service-builder-pattern) for builder usage, ServiceResources, and registration flow patterns.

## Cross-References

See [ARCHITECTURE.md Section 7. Data Architecture](../../docs/ARCHITECTURE.md#7-data-architecture) for database strategy, multi-tenancy patterns, connection pooling, and migration management.

See [ARCHITECTURE.md Section 5.2 Service Builder Pattern](../../docs/ARCHITECTURE.md#52-service-builder-pattern) for builder usage, ServiceResources, and registration flow patterns.
