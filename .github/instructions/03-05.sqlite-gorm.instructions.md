---
description: "Instructions for SQLite configuration with GORM, transaction patterns, and concurrent operations"
applyTo: "**"
---
# Sqlite Gorm

# SQLite Configuration with GORM - Tactical Guidance

**This file contains ONLY tactical implementation patterns**

## Quick Reference: Connection Pool

| Config | KMS (database/sql) | Identity (GORM) | Reason |
|--------|-------------------|-----------------|---------|
| MaxOpenConns | 1 | 5 | GORM tx needs separate connection |
| Journal Mode | WAL | WAL | Concurrent reads + 1 writer |
| Busy Timeout | 30s | 30s | Retry on lock contention |

## Required Pattern

```go
// 1. Open with modernc driver (CGO-free)
sqlDB, _ := sql.Open("sqlite", dsn)
sqlDB.Exec("PRAGMA journal_mode=WAL;")
sqlDB.Exec("PRAGMA busy_timeout = 30000;")

// 2. Pass to GORM with auto-transactions disabled
dialector := sqlite.Dialector{Conn: sqlDB}
db, _ := gorm.Open(dialector, &gorm.Config{SkipDefaultTransaction: true})

// 3. Configure connection pool for GORM transactions
sqlDB, _ = db.DB()
sqlDB.SetMaxOpenConns(cryptoutilMagic.SQLiteMaxOpenConnections)  // 5
sqlDB.SetMaxIdleConns(cryptoutilMagic.SQLiteMaxOpenConnections)  // 5
sqlDB.SetConnMaxLifetime(0)  // In-memory: never close
```

## Transaction Context Pattern

```go
func getDB(ctx context.Context, baseDB *gorm.DB) *gorm.DB {
    if tx, ok := ctx.Value(txKey).(*gorm.DB); ok { return tx }
    return baseDB
}
// Repositories: return getDB(ctx, r.db).WithContext(ctx).Create(user).Error
```

## Common Issues

❌ "cgo required": Use `sql.Open("sqlite")` not `sqlite.Open(dsn)`
❌ Tests hang: MaxOpenConns=1 + GORM tx = deadlock, set MaxOpenConns=5
❌ "database locked": Missing WAL mode or repositories not using `getDB(ctx, r.db)` pattern

## Critical Architecture Constraints

**GORM Transaction Model**: GORM explicit transactions (`db.Begin()`) require separate database connection from base operations. MaxOpenConns=1 causes deadlock: base DB tries to create transaction, but connection already in use. Solution: MaxOpenConns=5 allows concurrent transaction wrapper + internal operations.

| Aspect | KMS Server (database/sql) | Identity Server (GORM) |
|--------|---------------------------|------------------------|
| ORM Layer | No (raw database/sql) | Yes (GORM ORM) |
| MaxOpenConns | 1 | 5 |
| Rationale | Single operation per connection | Transaction wrapper needs separate connection |

**CGO-Free SQLite Driver**: Use modernc.org/sqlite (CGO-free) not mattn/go-sqlite3 (requires CGO). Project has CGO_ENABLED=0 globally. modernc.org/sqlite is pure Go, mattn/go-sqlite3 requires CGO and breaks static builds.

---

## Required SQLite Configuration

**Pattern**: Open with modernc driver → Configure SQLite (WAL mode, busy timeout) → Pass to GORM → Configure connection pool

```go
func OpenSQLite(dsn string, debugMode bool) (*gorm.DB, error) {
    if dsn == ":memory:" {
        dsn = "file::memory:?cache=shared"
    }

    sqlDB, err := sql.Open("sqlite", dsn)
    if err != nil {
        return nil, fmt.Errorf("failed to open SQLite: %w", err)
    }

    if _, err := sqlDB.Exec("PRAGMA journal_mode=WAL;"); err != nil {
        return nil, fmt.Errorf("failed to enable WAL mode: %w", err)
    }

    if _, err := sqlDB.Exec("PRAGMA busy_timeout = 30000;"); err != nil {
        return nil, fmt.Errorf("failed to set busy timeout: %w", err)
    }

    dialector := sqlite.Dialector{Conn: sqlDB}
    gormConfig := &gorm.Config{SkipDefaultTransaction: true}
    if debugMode {
        gormConfig.Logger = logger.Default.LogMode(logger.Info)
    }

    db, err := gorm.Open(dialector, gormConfig)
    if err != nil {
        return nil, fmt.Errorf("failed to initialize GORM: %w", err)
    }

    sqlDB, err = db.DB()
    if err != nil {
        return nil, fmt.Errorf("failed to get database instance: %w", err)
    }

    sqlDB.SetMaxOpenConns(5)  // CRITICAL: Required for GORM transactions
    sqlDB.SetMaxIdleConns(5)
    sqlDB.SetConnMaxLifetime(0)  // In-memory: never close connections

    return db, nil
}
```

**PRAGMA Settings**:

- WAL Mode: `journal_mode=WAL` enables concurrent readers + 1 writer (faster writes, reduces "database is locked" errors)
- Busy Timeout: `busy_timeout = 30000` (30 seconds) retries when database is locked instead of immediate failure

**Connection Pool**:

- MaxOpenConns=5: GORM transaction pattern requires separate connection from base operations
- File-based SQLite: SetConnMaxLifetime(time.Hour), in-memory: SetConnMaxLifetime(0) (keep alive)

---

## Transaction Context Pattern

**Context Injection for Repository Transparency**: Store transaction in context, repositories check context first

```go
type txKey struct{}

func WithTransaction(ctx context.Context, tx *gorm.DB) context.Context {
    return context.WithValue(ctx, txKey{}, tx)
}

func getDB(ctx context.Context, baseDB *gorm.DB) *gorm.DB {
    if tx, ok := ctx.Value(txKey{}).(*gorm.DB); ok && tx != nil {
        return tx
    }
    return baseDB
}

// Repository pattern
type UserRepository struct {
    db *gorm.DB
}

func (r *UserRepository) Create(ctx context.Context, user *User) error {
    return getDB(ctx, r.db).WithContext(ctx).Create(user).Error
}
```

**Usage in Service Layer**:

```go
func (s *UserService) CreateUserWithProfile(ctx context.Context, user *User, profile *Profile) error {
    tx := s.db.Begin()
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()

    txCtx := WithTransaction(ctx, tx)

    if err := s.userRepo.Create(txCtx, user); err != nil {
        tx.Rollback()
        return err
    }

    if err := s.profileRepo.Create(txCtx, profile); err != nil {
        tx.Rollback()
        return err
    }

    return tx.Commit().Error
}
```

---

## In-Memory Shared Cache

**Problem**: Each connection gets separate in-memory database by default

**Solution**: Use shared cache mode

```go
if dsn == ":memory:" {
    dsn = "file::memory:?cache=shared"
}
```

**Why**: GORM with MaxOpenConns=5 creates up to 5 connections. Without shared cache, each connection sees different database state. Shared cache ensures all connections see same in-memory data.

**URI Parameters**: `file::memory:` (in-memory database with file URI syntax), `?cache=shared` (enable shared cache across all connections)

---

## Troubleshooting Guide

**"go-sqlite3 requires cgo"**: Using mattn/go-sqlite3 driver with CGO_ENABLED=0. Solution: Use modernc.org/sqlite driver (`import _ "modernc.org/sqlite"`).

**Tests Hang with No Error**: MaxOpenConns=1 + GORM transactions = deadlock. Solution: Set MaxOpenConns=5. Debugging: Add logging (`gormConfig.Logger = logger.Default.LogMode(logger.Info)`), check stack traces (`GOTRACEBACK=all go test -v ./...`).

**"database is locked"**: Root Causes:

1. Repositories not using `getDB(ctx, r.db)` pattern (bypass transaction context)
2. Missing WAL mode (still using DELETE journal mode)
3. Missing busy_timeout (immediate failure on lock contention)

Solutions: Fix repository pattern (`return getDB(ctx, r.db).WithContext(ctx).Create(user).Error`), verify WAL mode enabled (`sqlDB.Exec("PRAGMA journal_mode=WAL;")`), set busy timeout (`sqlDB.Exec("PRAGMA busy_timeout = 30000;")`).

**"SQLite doesn't support read-only transactions"**: SQLite does NOT implement read-only transaction isolation level. Solution: Use standard transactions (`tx := db.Begin()`) or direct queries without transaction (`result := db.Find(&models)`).

**Cross-Database Compatibility**: See `database.md` for PostgreSQL vs SQLite patterns

---

## Key Takeaways

1. MaxOpenConns=5 for GORM (transaction wrapper needs separate connection)
2. modernc.org/sqlite (CGO-free driver for static builds)
3. WAL mode + busy_timeout (enable concurrent operations, prevent "database is locked")
4. Shared cache for :memory: (`file::memory:?cache=shared` ensures all connections see same data)
5. Transaction context pattern (`getDB(ctx, r.db)` for repository transparency)
6. No read-only transactions (SQLite limitation, use standard transactions or direct queries)
