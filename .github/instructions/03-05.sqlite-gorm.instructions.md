---
description: "Instructions for SQLite configuration with GORM, transaction patterns, and concurrent operations"
applyTo: "**"
---
# SQLite Configuration with GORM - Tactical Guidance

**Reference**: See `.specify/memory/sqlite-gorm.md` for complete specifications (PRAGMA settings, connection pool configuration, transaction patterns, troubleshooting)

**This file contains ONLY tactical implementation patterns**

## Quick Reference: Connection Pool

| Config | KMS (database/sql) | Identity (GORM) | Reason |
|--------|-------------------|-----------------|---------|
| MaxOpenConns | 1 | 5 | GORM tx needs separate connection |
| Journal Mode | WAL | WAL | Concurrent reads + 1 writer |
| Busy Timeout | 30s | 30s | Retry on lock contention |

## Required Pattern

```go
// 1. Open with modernc driver (CGO-free)
sqlDB, _ := sql.Open("sqlite", dsn)
sqlDB.Exec("PRAGMA journal_mode=WAL;")
sqlDB.Exec("PRAGMA busy_timeout = 30000;")

// 2. Pass to GORM with auto-transactions disabled
dialector := sqlite.Dialector{Conn: sqlDB}
db, _ := gorm.Open(dialector, &gorm.Config{SkipDefaultTransaction: true})

// 3. Configure connection pool for GORM transactions
sqlDB, _ = db.DB()
sqlDB.SetMaxOpenConns(cryptoutilMagic.SQLiteMaxOpenConnections)  // 5
sqlDB.SetMaxIdleConns(cryptoutilMagic.SQLiteMaxOpenConnections)  // 5
sqlDB.SetConnMaxLifetime(0)  // In-memory: never close
```

## Transaction Context Pattern

```go
func getDB(ctx context.Context, baseDB *gorm.DB) *gorm.DB {
    if tx, ok := ctx.Value(txKey).(*gorm.DB); ok { return tx }
    return baseDB
}
// Repositories: return getDB(ctx, r.db).WithContext(ctx).Create(user).Error
```

## Common Issues

- **"go-sqlite3 requires cgo"**: Use `sql.Open("sqlite")` not `sqlite.Open(dsn)`
- **Tests hang**: MaxOpenConns=1 + GORM tx = deadlock. Set MaxOpenConns=5
- **"database is locked"**: Missing WAL mode or repositories not using `getDB(ctx, r.db)` pattern
- **"SQLite doesn't support read-only transactions"**: Use standard `db.Begin()` (not `sql.TxOptions{ReadOnly: true}`)
