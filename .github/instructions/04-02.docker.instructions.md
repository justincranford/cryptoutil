---
description: "Instructions for Docker and Docker Compose configuration"
applyTo: "**"
---
# Docker Configuration Instructions

## Core Rules

- Use `docker compose` (not `docker-compose`)
- NEVER use absolute paths in compose.yml - breaks cross-platform compatibility
- ALWAYS use relative paths: `file: ./postgres/postgres_username.secret`

## Multi-Stage Builds

- Global ARGs at top of Dockerfile for visibility
- Redeclare ARGs in stages using them for LABELs
- WORKDIR: `/src` for builder, `/app` for runtime
- All LABELs on final published image only
- Enforce required ARGs (VCS_REF, BUILD_DATE) via validation stage

## Docker Secrets - CRITICAL

- NEVER modify Docker Compose secrets - breaks cryptographic key hierarchy
- ALL cryptoutil instances MUST use SAME unseal secrets for interoperability
- Use secrets directly with file:// URLs, not environment variables
- **MANDATORY: Docker secrets MUST have 440 permissions (r--r-----)**

```yaml
secrets:
  - database_url_secret
command: ["app", "--database-url=file:///run/secrets/database_url_secret"]
```

### Docker Secrets File Permissions

**MANDATORY: All secrets files MUST have 440 permissions (read-only for owner+group)**:

```bash
# Correct permissions
chmod 440 deployments/compose/*/secrets/*.secret
ls -la deployments/compose/*/secrets/
# Should show: -r--r----- for all .secret files
```

**Rationale**: Prevents unauthorized access to secrets while allowing group read (Docker daemon group).

### Dockerfile Secrets Validation Job - MANDATORY

**ALL Dockerfiles MUST include validation stage to verify secrets exist with correct permissions**

**Pattern** (from KMS Dockerfile):

```dockerfile
# Validation stage - verify secrets exist with correct permissions
FROM alpine:3.19 AS validator
WORKDIR /validation

# Copy secrets from builder stage (if applicable) or expect at runtime
COPY --from=builder /run/secrets/ /run/secrets/ 2>/dev/null || true

# Validate secrets existence and permissions
RUN echo "üîç Validating Docker secrets..." && \
    ls -la /run/secrets/ || echo "‚ö†Ô∏è No secrets found (OK for build-time, required at runtime)" && \
    if [ -d /run/secrets/ ]; then \
        echo "‚úÖ Secrets directory exists"; \
        for secret in database_url_secret unseal_key_secret tls_cert_secret tls_key_secret; do \
            if [ -f "/run/secrets/$secret" ]; then \
                echo "‚úÖ Secret $secret exists"; \
                chmod 440 "/run/secrets/$secret" 2>/dev/null || true; \
            fi; \
        done; \
    fi

# Final runtime stage
FROM alpine:3.19 AS runtime
# ... copy from validator, not builder
```

**Enforcement**: CI/CD workflows SHOULD validate Dockerfile includes secrets validation job.

---

## Networking

- ALWAYS use `127.0.0.1` in containers (not `localhost` - resolves to IPv6 `::1` in Alpine)
- Use `wget` for healthchecks (available in Alpine), not `curl`

```yaml
healthcheck:
  test: ["CMD", "wget", "--no-check-certificate", "-q", "-O", "/dev/null", "https://127.0.0.1:9090/admin/v1/livez"]
```

## Sidecar Health Checks

For containers without shell/utilities (e.g., otel-collector-contrib):

```yaml
minimal-service-health-check:
  image: alpine:latest
  command: ["wget", "--quiet", "--tries=1", "--spider", "http://minimal-service:13133/"]
  depends_on:
    minimal-service:
      condition: service_started
```

## Docker Compose Latency Hiding Strategies - CRITICAL

**MANDATORY optimizations to minimize service startup time:**

### 1. Single Build, Shared Image

```yaml
services:
  builder:
    build: ./
    image: cryptoutil:local

  cryptoutil-postgres-1:
    image: cryptoutil:local  # Reuses built image
    depends_on:
      builder:
        condition: service_completed_successfully

  cryptoutil-postgres-2:
    image: cryptoutil:local  # Reuses built image
    depends_on:
      builder:
        condition: service_completed_successfully
```

**Why**: Build once, all instances use same image. Prevents 3√ó build time.

### 2. Schema Initialization by First Instance

```yaml
  cryptoutil-postgres-1:
    depends_on:
      postgres:
        condition: service_healthy

  cryptoutil-postgres-2:
    depends_on:
      cryptoutil-postgres-1:
        condition: service_healthy  # Waits for schema init

  cryptoutil-postgres-3:
    depends_on:
      cryptoutil-postgres-1:
        condition: service_healthy  # Waits for schema init
```

**Why**: First instance initializes DB schema, others wait. Prevents contention.

### 3. Health Check Dependencies

```yaml
  cryptoutil-sqlite:
    healthcheck:
      test: ["CMD", "wget", "--no-check-certificate", "-q", "-O", "/dev/null", "https://127.0.0.1:9090/admin/v1/livez"]
      start_period: 10s
      interval: 5s
      retries: 5

  otel-collector:
    depends_on:
      cryptoutil-sqlite:
        condition: service_healthy
```

**Why**: Services start only after dependencies are healthy, not just started.

### 4. Expected Startup Times

| Service | Expected Time | Strategy |
|---------|--------------|----------|
| builder | 30-60s | One-time build, cached for all instances |
| postgres | 5-30s | start_period=5s + (5s√ó5 retries) = max 30s |
| cryptoutil (first) | 10-35s | start_period=10s + (5s√ó5 retries) + unseal |
| cryptoutil (others) | 5-15s | Schema already initialized, just unseal |
| otel-collector | 10-40s | Waits for cryptoutil, 10s sleep + 15 retries |

**Total Expected**: 60-150s for full stack in optimal conditions
**GitHub Actions**: Add 50-100% margin for shared CPU, network latency, cold starts

### 5. Diagnostic Logging for Bottlenecks

Add timing to Dockerfile and healthchecks:

```dockerfile
RUN echo "üèóÔ∏è Build started: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" && \
    go build -o /app/cryptoutil ./cmd/cryptoutil && \
    echo "‚úÖ Build completed: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
```

```yaml
healthcheck:
  test: |
    wget --no-check-certificate -q -O /dev/null https://127.0.0.1:9090/admin/v1/livez && \
    echo "‚úÖ Health check passed: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
```

**Why**: Identify slow stages (build, schema init, network, health checks) for optimization.
  depends_on:
    minimal-service:
      condition: service_started

```

## Service Ports Quick Reference

| Service | Public API | Admin API | Backend |
|---------|-----------|-----------|---------|
| cryptoutil-sqlite | 8080 | 9090 | SQLite in-memory |
| cryptoutil-postgres-1 | 8081 | 9090 | PostgreSQL |
| cryptoutil-postgres-2 | 8082 | 9090 | PostgreSQL |
| postgres | 5432 | - | - |
| otel-collector | 4317 (gRPC), 4318 (HTTP) | 13133 | - |
| grafana-otel-lgtm | 3000 | - | Loki/Tempo/Prometheus |

## Config Files

- `cryptoutil-common.yml`: Shared settings (TLS, unseal, security) - affects ALL instances
- `cryptoutil-sqlite.yml`, `cryptoutil-postgresql-{1,2}.yml`: Instance-specific (CORS, OTLP service/hostname)
- Instance config values MUST be unique and match service name in compose.yml
