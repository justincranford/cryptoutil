---
description: "Docker and Docker Compose configuration"
applyTo: "**"
---
# Docker

# Docker Configuration Instructions - Tactical Guidance

## Core Rules Quick Reference

- Use `docker compose` (NOT `docker-compose`)
- ALWAYS use relative paths in compose.yml (NEVER absolute paths)
- Docker secrets MUST have 440 permissions (r--r-----)
- ALWAYS use `127.0.0.1` in containers (NOT `localhost`)
- Use `wget` for healthchecks (available in Alpine)

## Multi-Stage Build Pattern

```dockerfile
# Global ARGs at top
ARG GO_VERSION=1.25.5
ARG VCS_REF
ARG BUILD_DATE

# Builder stage
FROM golang:${GO_VERSION}-alpine AS builder
WORKDIR /src
# Build logic...

# Validator stage (secrets validation MANDATORY)
FROM alpine:3.19 AS validator
WORKDIR /validation
RUN echo "ðŸ” Validating Docker secrets..." && \
    # Validation logic for secrets existence and permissions

# Runtime stage
FROM alpine:3.19 AS runtime
WORKDIR /app
ARG VCS_REF
ARG BUILD_DATE
LABEL org.opencontainers.image.revision="${VCS_REF}"
COPY --from=validator /app/cryptoutil /app/cryptoutil
```

## Docker Compose Latency Optimization

**Single Build, Shared Image**:

```yaml
builder:
  build: ./
  image: cryptoutil:local

cryptoutil-postgres-1:
  image: cryptoutil:local  # Reuses built image (prevents 3Ã— build time)
```

**Schema Init by First Instance**:

```yaml
cryptoutil-postgres-2:
  depends_on:
    cryptoutil-postgres-1:
      condition: service_healthy  # Waits for schema init
```

## Service Ports

kms-sm: 8080-8082 (public), 9090 (admin) | PostgreSQL: 5432 | otel-collector: 4317/4318 | grafana-otel-lgtm: 3000

## Config Files

- `cryptoutil-common.yml`: Shared settings (TLS, unseal, security) - affects ALL instances
- `cryptoutil-sqlite.yml`, `cryptoutil-postgresql-{1,2}.yml`: Instance-specific (CORS, OTLP service/hostname)
- Instance config values MUST be unique and match service name in compose.yml

## Core Docker Compose Rules

**Command**: Use `docker compose` (NOT `docker-compose` v1)
**Paths**: ALWAYS relative (NOT absolute), breaks cross-platform

---

## Multi-Stage Dockerfile Patterns

**Global ARGs**: Declare at top (GO_VERSION, VCS_REF, BUILD_DATE)
**Stage Redeclaration**: Redeclare ARGs in each stage using them
**WORKDIR**: Builder=`/src`, Runtime=`/app`
**LABELs**: Final published image only (NOT builder/validator)
**Copy**: Use validator stage, not builder (`COPY --from=validator`)

## Docker Secrets Management - CRITICAL

**MANDATORY: ALL credentials MUST use Docker secrets, NEVER inline environment variables**

**Interoperability**: NEVER modify unseal secrets (breaks HKDF deterministic key derivation)
**Permissions**: chmod 440 (r--r-----) on all .secret files
**Usage**: ALWAYS `file:///run/secrets/secret_name`, NOT env vars
**Validation**: ALL Dockerfiles MUST include secrets validation stage

### Docker Secrets Pattern - MANDATORY

**Principle**: All sensitive data (passwords, tokens, keys) MUST be stored in Docker secrets, mounted at `/run/secrets/`

**Top-Level Secrets Section** (compose.yml):

```yaml
secrets:
  postgres_username.secret:
    file: ./secrets/postgres_username.secret
  postgres_password.secret:
    file: ./secrets/postgres_password.secret
  postgres_db.secret:
    file: ./secrets/postgres_db.secret
```

**Service-Level Secrets Mounting**:

```yaml
services:
  myapp-postgres:
    image: postgres:18
    secrets:
      - postgres_username.secret
      - postgres_password.secret
      - postgres_db.secret
    environment:
      POSTGRES_USER_FILE: /run/secrets/postgres_username.secret
      POSTGRES_PASSWORD_FILE: /run/secrets/postgres_password.secret
      POSTGRES_DB_FILE: /run/secrets/postgres_db.secret
```

### PostgreSQL Credentials Pattern

**Official PostgreSQL Image** (POSTGRES_*_FILE pattern):

```yaml
identity-postgres:
  image: postgres:18
  secrets:
    - postgres_user
    - postgres_password
    - postgres_db
  environment:
    POSTGRES_USER_FILE: /run/secrets/postgres_user
    POSTGRES_PASSWORD_FILE: /run/secrets/postgres_password
    POSTGRES_DB_FILE: /run/secrets/postgres_db
```

**Application Database URL** (Two Patterns):

**Pattern A - File Reference** (KMS, Cipher-IM):
```yaml
cryptoutil-kms:
  secrets:
    - postgres_url.secret
  command:
    - -u
    - file:///run/secrets/postgres_url.secret
```

**Pattern B - Command Interpolation** (Identity):
```yaml
identity-authz:
  secrets:
    - postgres_user
    - postgres_password
    - postgres_db
  command:
    - --db-url=postgres://$(cat /run/secrets/postgres_user):$(cat /run/secrets/postgres_password)@identity-postgres:5432/$(cat /run/secrets/postgres_db)?sslmode=disable
```

**Both patterns are equally secure** - choose based on application requirements.

### Unseal Keys Pattern

```yaml
cryptoutil-kms-postgres-1:
  secrets:
    - postgres_url.secret
    - unseal_1of5.secret
    - unseal_2of5.secret
    - unseal_3of5.secret
    - unseal_4of5.secret
    - unseal_5of5.secret
  command:
    - -u
    - file:///run/secrets/postgres_url.secret
    - --unseal-key
    - file:///run/secrets/unseal_1of5.secret
    - --unseal-key
    - file:///run/secrets/unseal_2of5.secret
    # ... (repeat for all 5 keys)
```

### Anti-Pattern - FORBIDDEN

**NEVER use inline environment variables for credentials**:

```yaml
# âŒ WRONG - inline credentials (FORBIDDEN)
services:
  myapp-postgres:
    environment:
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword  # SECURITY VIOLATION
      POSTGRES_DB: mydb
```

**CORRECT - Docker secrets**:

```yaml
# âœ… CORRECT - Docker secrets
services:
  myapp-postgres:
    secrets:
      - postgres_user
      - postgres_password
      - postgres_db
    environment:
      POSTGRES_USER_FILE: /run/secrets/postgres_user
      POSTGRES_PASSWORD_FILE: /run/secrets/postgres_password
      POSTGRES_DB_FILE: /run/secrets/postgres_db

secrets:
  postgres_user:
    file: ./secrets/postgres_user.secret
  postgres_password:
    file: ./secrets/postgres_password.secret
  postgres_db:
    file: ./secrets/postgres_db.secret
```

### Validation Commands

**Detect inline credentials** (should return ZERO matches):

```bash
grep -E "PASSWORD|SECRET|TOKEN|PASSPHRASE|PRIVATE_KEY" compose.yml \
  | grep -v "# " \
  | grep -v "secrets:" \
  | grep -v "_FILE:" \
  | grep -v "run/secrets"
```

**Expected result**: Empty output (no inline credentials)

**Validate syntax**:

```bash
docker compose -f compose.yml config > /dev/null
```

**Expected result**: `âœ… Valid` (no errors)

### Reference Implementations

**See these compose files for complete examples**:
- `deployments/ca/compose.yml` - PostgreSQL with Docker secrets
- `deployments/kms/compose.yml` - PostgreSQL + unseal keys with Docker secrets
- `deployments/cipher/compose.yml` - PostgreSQL with Docker secrets (after Task 7.1 fix)
- `deployments/identity/compose.advanced.yml` - PostgreSQL with command interpolation pattern

### Rationale

**Security**: Credentials never in version control, never in environment variables (visible in `docker inspect`)
**Auditability**: Secret file changes tracked separately from code
**Rotation**: Update secret files without changing compose.yml
**Compliance**: Follows Docker security best practices and .github/instructions/03-06.security.instructions.md requirements

## Networking Configuration

**Localhost**: ALWAYS `127.0.0.1` in containers (NOT `localhost`, Alpine resolves to IPv6)
**Healthcheck**: Use `wget --no-check-certificate -q -O /dev/null https://127.0.0.1:PORT/path`
**Why wget**: Pre-installed in Alpine, lighter than curl

## Healthcheck Configuration

**Correct setting names** (all use hyphens): `interval`, `timeout`, `retries`, `start-period`

**NEVER use**: `start_period` (underscore) - Docker silently ignores it

**Verification**: `docker inspect <container_id> | jq '.[0].State.Health'`

## .dockerignore Optimization - MANDATORY

**ALWAYS exclude** development/test artifacts from Docker build context (42+ patterns recommended)

**Verification**:
```bash
docker build --no-cache -t test-size .
# Look for "Sending build context" - should be <10MB, not 200MB+
```

## Sidecar Health Checks

**For minimal containers** (no shell/wget): Separate Alpine sidecar performs checks

---

## Docker Desktop Startup - Platform-Specific

**Windows** (PowerShell):
```powershell
Start-Process -FilePath "C:\Program Files\Docker\Docker\Docker Desktop.exe"
```

**Linux** (systemd):
```bash
systemctl --user start docker-desktop
```

**Detection**: If Docker commands fail with "Cannot connect to the Docker daemon", start Docker Desktop and wait 30-60 seconds for initialization.

**Verification**: Run `docker ps` to confirm Docker daemon is running.

---

## Docker Compose Latency Hiding Strategies - CRITICAL

**Strategy 1**: Single build, shared image (prevents 3Ã— build time)
**Strategy 2**: First instance initializes DB, others wait
**Strategy 3**: Health check dependencies (service_healthy, not service_started)
**Strategy 4**: Expected startup times (builder 30-60s, postgres 5-30s, cryptoutil 10-35s)
**Strategy 5**: Diagnostic logging with timestamps for bottleneck identification

## Docker Compose Port Conflicts - CRITICAL

**Problem**: Multiple services including same telemetry compose file cause host port conflicts.

**Rules**:

- âŒ NEVER expose container ports to host if multiple instances may run
- âœ… ALWAYS use container-to-container networking (no host port mappings)
- âœ… Services communicate via container names (e.g., `opentelemetry-collector-contrib:4317`)

**Detection**: "bind: address already in use" or "port is already allocated"

**Diagnosis**:

```bash
# Check what's using the port
netstat -ano | findstr "4317"  # Windows
lsof -i :4317                  # Linux/Mac

# Check included compose files
grep -r "ports:" deployments/*/compose.yml
```

**Fix**:

1. Remove host port mappings from shared compose files
2. Use container-to-container networking only
3. Update application configs to use container names
4. Test all E2E workflows in sequence to verify no conflicts

## Service Ports Quick Reference

| Service | Public API | Admin API | Backend |
|---------|-----------|-----------|---------|
| kms-sm-sqlite | 8080 | 9090 | SQLite in-memory |
| kms-sm-postgres-1/2 | 8081/8082 | 9090 | PostgreSQL |
| otel-collector | 4317/4318 | 13133 | - |
| grafana-otel-lgtm | 3000 | - | Loki/Tempo/Prometheus |

## Configuration Files Organization

**Shared** (`cryptoutil-common.yml`): TLS certs, unseal secrets, security policies (affects ALL instances)
**Instance-Specific** (`cryptoutil-{backend}-{N}.yml`): CORS, OTLP service_name/hostname, bind addresses/ports (MUST match compose service name)
