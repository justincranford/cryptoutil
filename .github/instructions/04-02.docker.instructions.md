---
description: "Docker and Docker Compose configuration"
applyTo: "**"
---
# Docker

# Docker Configuration Instructions - Tactical Guidance

## Core Rules Quick Reference

- Use `docker compose` (NOT `docker-compose`)
- ALWAYS use relative paths in compose.yml (NEVER absolute paths)
- Docker secrets MUST have 440 permissions (r--r-----)
- ALWAYS use `127.0.0.1` in containers (NOT `localhost`)
- Use `wget` for healthchecks (available in Alpine)

## Multi-Stage Build Pattern

```dockerfile
# Global ARGs at top
ARG GO_VERSION=1.25.5
ARG VCS_REF
ARG BUILD_DATE

# Builder stage
FROM golang:${GO_VERSION}-alpine AS builder
WORKDIR /src
# Build logic...

# Validator stage (secrets validation MANDATORY)
FROM alpine:3.19 AS validator
WORKDIR /validation
RUN echo "üîç Validating Docker secrets..." && \
    # Validation logic for secrets existence and permissions

# Runtime stage
FROM alpine:3.19 AS runtime
WORKDIR /app
ARG VCS_REF
ARG BUILD_DATE
LABEL org.opencontainers.image.revision="${VCS_REF}"
COPY --from=validator /app/cryptoutil /app/cryptoutil
```

## Docker Compose Latency Optimization

**Single Build, Shared Image**:

```yaml
builder:
  build: ./
  image: cryptoutil:local

cryptoutil-postgres-1:
  image: cryptoutil:local  # Reuses built image (prevents 3√ó build time)
```

**Schema Init by First Instance**:

```yaml
cryptoutil-postgres-2:
  depends_on:
    cryptoutil-postgres-1:
      condition: service_healthy  # Waits for schema init
```

## Service Ports

kms-sm: 8080-8082 (public), 9090 (admin) | PostgreSQL: 5432 | otel-collector: 4317/4318 | grafana-otel-lgtm: 3000

## Config Files

- `cryptoutil-common.yml`: Shared settings (TLS, unseal, security) - affects ALL instances
- `cryptoutil-sqlite.yml`, `cryptoutil-postgresql-{1,2}.yml`: Instance-specific (CORS, OTLP service/hostname)
- Instance config values MUST be unique and match service name in compose.yml

## Core Docker Compose Rules

**Command**: Use `docker compose` (NOT `docker-compose` v1)
**Paths**: ALWAYS relative (NOT absolute), breaks cross-platform

---

## Multi-Stage Dockerfile Patterns

**Global ARGs**: Declare at top (GO_VERSION, VCS_REF, BUILD_DATE)
**Stage Redeclaration**: Redeclare ARGs in each stage using them
**WORKDIR**: Builder=`/src`, Runtime=`/app`
**LABELs**: Final published image only (NOT builder/validator)
**Copy**: Use validator stage, not builder (`COPY --from=validator`)

## Docker Secrets Management - CRITICAL

**Interoperability**: NEVER modify unseal secrets (breaks HKDF deterministic key derivation)
**Permissions**: chmod 440 (r--r-----) on all .secret files
**Usage**: ALWAYS `file:///run/secrets/secret_name`, NOT env vars
**Validation**: ALL Dockerfiles MUST include secrets validation stage

## Networking Configuration

**Localhost**: ALWAYS `127.0.0.1` in containers (NOT `localhost`, Alpine resolves to IPv6)
**Healthcheck**: Use `wget --no-check-certificate -q -O /dev/null https://127.0.0.1:PORT/path`
**Why wget**: Pre-installed in Alpine, lighter than curl

## Sidecar Health Checks

**For minimal containers** (no shell/wget): Separate Alpine sidecar performs checks

---

## Docker Desktop Startup - Platform-Specific

**Windows** (PowerShell):
```powershell
Start-Process -FilePath "C:\Program Files\Docker\Docker\Docker Desktop.exe"
```

**Linux** (systemd):
```bash
systemctl --user start docker-desktop
```

**Detection**: If Docker commands fail with "Cannot connect to the Docker daemon", start Docker Desktop and wait 30-60 seconds for initialization.

**Verification**: Run `docker ps` to confirm Docker daemon is running.

---

## Docker Compose Latency Hiding Strategies - CRITICAL

**Strategy 1**: Single build, shared image (prevents 3√ó build time)
**Strategy 2**: First instance initializes DB, others wait
**Strategy 3**: Health check dependencies (service_healthy, not service_started)
**Strategy 4**: Expected startup times (builder 30-60s, postgres 5-30s, cryptoutil 10-35s)
**Strategy 5**: Diagnostic logging with timestamps for bottleneck identification

## Docker Compose Port Conflicts - CRITICAL

**Problem**: Multiple services including same telemetry compose file cause host port conflicts.

**Rules**:

- ‚ùå NEVER expose container ports to host if multiple instances may run
- ‚úÖ ALWAYS use container-to-container networking (no host port mappings)
- ‚úÖ Services communicate via container names (e.g., `opentelemetry-collector-contrib:4317`)

**Detection**: "bind: address already in use" or "port is already allocated"

**Diagnosis**:

```bash
# Check what's using the port
netstat -ano | findstr "4317"  # Windows
lsof -i :4317                  # Linux/Mac

# Check included compose files
grep -r "ports:" deployments/*/compose.yml
```

**Fix**:

1. Remove host port mappings from shared compose files
2. Use container-to-container networking only
3. Update application configs to use container names
4. Test all E2E workflows in sequence to verify no conflicts

## Service Ports Quick Reference

| Service | Public API | Admin API | Backend |
|---------|-----------|-----------|---------|
| kms-sm-sqlite | 8080 | 9090 | SQLite in-memory |
| kms-sm-postgres-1/2 | 8081/8082 | 9090 | PostgreSQL |
| otel-collector | 4317/4318 | 13133 | - |
| grafana-otel-lgtm | 3000 | - | Loki/Tempo/Prometheus |

## Configuration Files Organization

**Shared** (`cryptoutil-common.yml`): TLS certs, unseal secrets, security policies (affects ALL instances)
**Instance-Specific** (`cryptoutil-{backend}-{N}.yml`): CORS, OTLP service_name/hostname, bind addresses/ports (MUST match compose service name)
