---
description: "HTTPS ports, bind addresses, TLS configuration, and request paths for public and admin endpoints"
applyTo: "**"
---
# HTTPS Ports and Endpoints - CRITICAL

**MANDATORY: Public HTTPS endpoints MUST be documented as `<configurable_address>:<configurable_port>` - NEVER hardcode `0.0.0.0`**

## Why This Matters

- **Container deployments**: Use `0.0.0.0` bind address (enables external access)
- **Test/dev environments**: Use `127.0.0.1` bind address (prevents Windows Firewall prompts)
- **Configuration-driven**: Bind address MUST be configurable, not hardcoded to `0.0.0.0`

## Pattern Recognition

- ❌ WRONG: "Public API (0.0.0.0:configurable)" - hardcodes container-only pattern
- ❌ WRONG: "Public API (0.0.0.0:8080)" - hardcodes both address and port
- ✅ CORRECT: "Public API (<configurable_address>:<configurable_port>)" - fully configurable
- ✅ CORRECT: In code: `bindAddress := config.PublicBindAddress` (NEVER hardcode "0.0.0.0")

## Why `0.0.0.0` is Wrong in Documentation

- Implies public endpoints ALWAYS bind to all interfaces (not true for tests/dev)
- Contradicts constitution.md requirement: "Public endpoints MAY use configurable IPv4 or IPv6 bind address"
- Prevents Windows development: `0.0.0.0` triggers Firewall prompts, blocks automation
- Misleads implementers: Suggests hardcoding instead of configuration

## Correct Documentation Pattern

```markdown
**Dual HTTPS Servers**: Public API (<configurable_address>:<configurable_port>) + Admin API (127.0.0.1:9090)
```

## Correct Implementation Pattern

```go
// Configuration structure
type ServerConfig struct {
    PublicBindAddress string // Default: "127.0.0.1" (tests/dev), "0.0.0.0" (containers)
    PublicPort        int    // Configurable port
    AdminBindAddress  string // ALWAYS "127.0.0.1" (never configurable)
    AdminPort         int    // ALWAYS 9090 (never configurable)
}

// Server binding
publicAddr := fmt.Sprintf("%s:%d", config.PublicBindAddress, config.PublicPort)
adminAddr := "127.0.0.1:9090" // Admin NEVER configurable
```

## Where This Pattern Appears

- constitution.md Section V (Service Architecture)
- spec.md (Service Template Extraction, Dual HTTPS Pattern)
- PLAN.md (Core Requirements)
- 02-01.architecture.instructions.md (Two Endpoint HTTPS Architecture Pattern)

## Enforcement

When writing documentation about public HTTPS endpoints, ALWAYS use `<configurable_address>:<configurable_port>` pattern. When implementing, ALWAYS read bind address from configuration.

## Deployment Environments

**Production Deployments**:
- Public endpoints MUST use 0.0.0.0 IPv4 bind address inside containers (enables external access)
- Public endpoints MAY use configurable IPv4 or IPv6 bind address outside containers (defaults to 127.0.0.1)
- Private endpoints MUST use 127.0.0.1:9090 inside containers (not mapped outside)
- No IPv6 inside containers due to dual-stack limitations in container runtimes

**Development/Test Environments**:
- Public and private endpoints MUST use 127.0.0.1 IPv4 bind address (prevents Windows Firewall prompts)
- Public and private endpoints MUST use port 0 (dynamic allocation) to avoid port collisions
- Rationale: 0.0.0.0 triggers Windows Firewall prompts; static ports cause collisions during parallel test automation

## TLS Certificate Configuration

All services MUST support separate configuration for two HTTPS endpoints, including TLS Server and TLS Client certificates.

**Configuration Options** (POV of HTTPS Issuing CA certificate chain):
1. All Externally - Production: Issuing CA chain provided without private key, Server cert chain provided with private key
2. Mixed External and Auto-Generated - Development: Issuing CA with private key, Server cert generated and signed by Issuing CA
3. All Auto-Generated - Testing: Server cert chain and private key generated by service instance (not production)

**Static TLS Certificates** (Externally Provided):
- Private keys stored in Docker Secrets (production and development)
- Certificate chains provided via file paths or PEM-encoded data in configuration files
- Trusted CA certificates configurable for client verification

## Private HTTPS Endpoint (Admin Server)

**Purpose**: Administration, health checks, graceful shutdown

**Configuration**:
- Production port: 127.0.0.1:9090 (static binding)
- Test port: 0 (dynamic allocation)
- Bind address: ALWAYS 127.0.0.1 (IPv4 loopback only)
- TLS: HTTPS MANDATORY (never HTTP)
- External access: NEVER (127.0.0.1-only)

**Endpoints**: `/admin/v1/livez`, `/admin/v1/readyz`, `/admin/v1/shutdown`

**Health Check Semantics**:
- **livez**: Fast (~1ms) - process alive, TLS server responding
- **readyz**: Slow (~100ms+) - database connectivity, downstream services, resource availability

**Consumers**: Docker health checks, Kubernetes probes, monitoring systems, orchestration tools

## Public HTTPS Endpoint (Public Server)

**Purpose**: Business APIs, browser UIs, external client access

**Configuration**:
- Production ports: Service-specific ranges (8080-8089 for KMS, 8180-8189 for Identity, etc.)
- Bind address: 127.0.0.1 (production containers can set 0.0.0.0 via configuration), 127.0.0.1 (tests/development)
- TLS: HTTPS MANDATORY (never HTTP)
- External access: YES (exposed to clients)

## Request Path Prefixes and Middlewares

For public HTTPS endpoint, all services implement TWO security middleware stacks:

**Service-to-Service APIs** (`/service/**` prefix):
- Access: Service clients ONLY (browsers blocked by middleware)
- Middleware: IP allowlist, rate limiting, request logging

**Browser-to-Service APIs/UI** (`/browser/**` prefix):
- Access: Browser clients ONLY (service clients blocked by middleware)
- Middleware: CSRF protection, CORS policies, CSP headers, IP allowlist, rate limiting
- Additional content: HTML pages, JavaScript, CSS, images, fonts

**API Consistency**:
- SAME OpenAPI specification served at both `/service/**` and `/browser/**` paths
- Middleware enforces mutual exclusivity (service tokens can't access browser paths, vice versa)
- Prevents unauthorized cross-client access patterns
