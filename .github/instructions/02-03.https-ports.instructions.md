---
description: "HTTPS ports, bind addresses, TLS addresses, CORS Origins, TLS configuration, and request paths for public and admin endpoints"
applyTo: "**"
---
# Two HTTPS Endpoints - CRITICAL

## Overview

### Binding Parameters

1. Public HTTP Endpoint: Defaults are protocol "https", address "127.0.0.1", and port "8080"
2. Private HTTP Endpoint: Default are protocol "https", address "127.0.0.1", and port "9090"

The Private HTTP Endpoint is also known as (AKA) the "Administration" or "Admin" endpoint.

**MANDATORY: HTTPS Endpoint binding MUST be documented as `<configurable_protocol>://<configurable_address>:<configurable_port>`**

### External TLS Subject Alt Names

1. Public HTTP Endpoint: dnsName: ["localhost"], ipAddress: ["127.0.0.1", "::1", "::ffff:127.0.0.1"]
2. Private HTTP Endpoint: dnsName: ["localhost"], ipAddress: ["127.0.0.1", "::1", "::ffff:127.0.0.1"]

If TLS Server certification chains are generated automatically, these values will be used to populate the Subject Alt Name extension of the TLS Server leaf certificates.

### External CORS Origins

1. Public HTTP Endpoint (/browser paths only): ["http://localhost:8080", "http://127.0.0.1:8080", "http://[::1]:8080", "https://localhost:8080", "https://127.0.0.1:8080", "https://[::1]:8080"]
2. Private HTTP Endpoint: Not applicable because it doesn't have a UI

The Public HTTP Endpoint supports /browser and /service paths. CORS settings only apply to /browser paths, because that is where a UI is located.

## Correct Implementation Pattern

```go
type ServerConfig struct {
 BindPublicProtocol          string // configurable: "https" (default), "https" (tests/dev), "https" (containers)
 BindPublicAddress           string // configurable: "127.0.0.1" (default), "127.0.0.1" (tests/dev), "0.0.0.0" (containers)
 BindPublicPort              uint16 // configurable: 8080 (default), 0 (tests/dev), 8080 (containers)
 BindPrivateProtocol         string // configurable: "https" (default), "https" (tests/dev), "https" (containers)
 BindPrivateAddress          string // configurable: "127.0.0.1" (default), "127.0.0.1 (tests/dev), "127.0.0.1" (containers)
 BindPrivatePort             uint16 // configurable: 9090 (default), 0 (tests/dev), 9090 (containers)
 TLSPublicDNSNames           []string // configurable: []string{"localhost"} (default)
 TLSPublicIPAddresses        []string // configurable: []string{"127.0.0.1", "::1", IPv4MappedI"::ffff:127.0.0.1"} (default)
 TLSPrivateDNSNames          []string // configurable: []string{"localhost"} (default)
 TLSPrivateIPAddresses       []string // configurable: []string{"127.0.0.1", "::1", IPv4MappedI"::ffff:127.0.0.1"} (default)
 CORSAllowedOrigins          []string // configurable: []string{"http://localhost:8080", "http://127.0.0.1:8080", "http://[::1]:8080", "https://localhost:8080", "https://127.0.0.1:8080", "https://[::1]:8080"} (default)
}
```

### Why This Matters

Care must be taken with the binding address for the HTTP Public Port for two reasons.

#### Windows Firewall Warning Prompts

- **Container deployments**: Use `0.0.0.0` bind address inside containers (required for mapping external port to internal port)
- **Test/dev environments**: Use `127.0.0.1` bind address outside containers for testing (prevents Windows Firewall warning prompts)
- **Configuration-driven**: Bind address MUST be configurable, NEVER hardcoded to `0.0.0.0`

#### IPv4 vs IPv6 dual-stack limitations in Container Runtimes

Some container runtimes (e.g., Docker Desktop for Windows) have dual-stack limitations. For example, if HTTP Public Endpoint is bound to an IPv6 address, the container runtime might not be able to route traffic from an `external IPv4 address:port` to the `internal IPv6 address:port`.

## Deployment Environments

## TLS Certificate Configuration

All services MUST support two sets of HTTPS configurations, one set for Public Port and one set for Private Port Bindings.

Each configuration set must support TLS Server certificate chain, TLS Server private key, and TLS Client Trusted certificates.

For TLS Client Trusted certificates, these are usually CA certificates; self-signed TLS client certificates are strongly discouraged, and may not be properly supported by the underlying TLS implementation.

**Configuration Options**:

1. Production (All certs passed to container):
    - Static cert chain for Root CA to Issuing CA is provided
    - Static private key for Issuing CA is NOT provided
    - Static cert for TLS Server is provided
    - Static private key for TLS Server is provided
    - Outcome: TLS Server cert chain and private key are used as provided
2. E2E Dev Tests (Mixed static & auto-Generated):
    - Static cert chain for Root CA to Issuing CA is provided
    - Static private key for Issuing CA is provided
    - Outcome: TLS Server TBSCertificate is generated, and signed with Issuer private key to issue TLS Server cert
3. Unit/Integration Dev Tests (All Auto-Generated):
    - Auto-create all certs from Root CA to TLS Server cert
    - Retain the TLS Server private key, discard all of the CA private keys
    - Outcome: TLS Server cert chain is generated and used as-is

**Configuration Settings**:

- Certificate chains for Root CA through to Issuing CA are specified in configuration, using either file paths or embedded PEM-encoded values
- Certificate for TLS Server is specified in configuration, using either file paths or embedded PEM-encoded values
- Private key for TLS Server is specified in a Docker Secret (Production)
- Private key for Issuing CA is specified in a Docker Secret (E2E Dev+Test)
- Trusted CA certificates for TLS Clients are specified in configuration, using either file paths or embedded PEM-encoded values

## Private HTTPS Endpoint (Admin Server)

**Purpose**: Administration, health checks, graceful shutdown

**Configuration**:

- Test ports: 0 (dynamic allocation)
- Production ports: 9090 is recommended for all situations, unless there is an exceptional use case (e.g. port conflict with another service)
- Bind address: Recommendation is to use 127.0.0.1 (IPv4 loopback only) for all situations (Prod, E2E, Unit/Integration), unless there is an exceptional use case
- TLS: Recommendation is to always use HTTPS (never HTTP) for all situations, unless there is an exceptional use case (e.g. clear text local HTTP debugging)
- External access: NOT RECOMMENDED, because authentication is optional (TLS client) and authorization is not supported

**Private HTTP APIs

- `/admin/v1/livez` - Liveness health probe (lightweight check: service running, process alive)
- `/admin/v1/readyz` - Readiness health probe (heavyweight check: dependencies healthy, ready for traffic)
- `/admin/v1/shutdown` - Graceful shutdown trigger

**Why Two Separate Health Endpoints** (Kubernetes standard):

- Liveness: Process alive but stuck? Restart container
- Readiness: Process alive but dependencies down? Remove from load balancer, don't restart
- Combined health endpoint can't distinguish these two failure modes

**Implementation Source**: KMS uses gofiber middleware which provides livez/readyz pattern out-of-box

**Consumers**: Docker health checks, Kubernetes probes, monitoring systems, orchestration tools

## Public HTTPS Endpoint (Public Server)

**Purpose**: Business APIs, browser UIs, external client access

**Configuration**:

- Test ports: 0 (dynamic allocation)
- Production ports: Service-specific ranges (8080-8089 for KMS, 8180-8189 for Identity, etc.)
- Bind address: Recommendation is 0.0.0.0 inside containers, 127.0.0.1 outside containers (testing), and configurable outside containers (production)
- TLS: Recommendation is to always use HTTPS (never HTTP) for all situations, unless there is an exceptional use case (e.g. clear text local HTTP debugging)
- External access: YES, because this is how browser clients access UIs and UI-specific APIs, and how headless clients will access service-to-service APIs

## Request Path Prefixes and Middlewares

For Public HTTP endpoint, all services MUST implement TWO security middleware stacks:

**Service-to-Service APIs** (`/service/**` prefix):

- Access: Service clients ONLY; browser clients MUST be blocked by authorization checks in middleware
- Middleware: IP allowlist, rate limiting, request logging

**Browser-to-Service APIs/UI** (`/browser/**` prefix):

- Access: Browser clients ONLY; service clients MUST be blocked by authorization checks in middleware
- Middleware: CSRF protection, CORS policies, CSP headers, IP allowlist, rate limiting
- Additional content: HTML pages, JavaScript, CSS, images, fonts

**API Consistency**:

- SAME OpenAPI specification served at both `/service/api/v1/**` and `/browser/api/v1/**` paths
- Middleware enforces authorization mutual exclusivity
  - clients that authenticate as headless clients are identified as headless clients, and are only authorized to access /service/** paths
  - clients that authenticate as browser clients are identified as browser clients, and are only authorized to access /browser/** paths
- Cross-client access patterns are prevented by middleware, because security requirements are very different
  - browser clients MUST be subjected to CORS, CSRF, XSS, etc protections to block browser-based attack vectors; those don't apply to headless clients
  - headless clients MUST be subjected to different authentication requirements to block DDOS bot-based attack vectors; not all of them not apply to browser clients
