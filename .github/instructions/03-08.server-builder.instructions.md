---
description: "Server builder pattern and merged migrations"
applyTo: "**"
---
# Server Builder

# Server Builder Pattern - Tactical Guidance

## Quick Reference

**Builder eliminates 260+ lines per service**: TLS setup, admin/public servers, database, migrations, sessions, barrier
**Merged migrations**: Combines template (1001-1004) + domain (2001+) for golang-migrate validation
**Usage**: `NewServerBuilder(ctx, cfg).WithDomainMigrations(...).WithPublicRouteRegistration(...).Build()`

## Core Pattern

```go
// Create builder with template config
builder := cryptoutilTemplateBuilder.NewServerBuilder(ctx, cfg.ServiceTemplateServerSettings)

// Register domain migrations (2001+)
builder.WithDomainMigrations(repository.MigrationsFS, "migrations")

// Register domain-specific routes
builder.WithPublicRouteRegistration(func(
    base *cryptoutilTemplateServer.PublicServerBase,
    res *cryptoutilTemplateBuilder.ServiceResources,
) error {
    // Create domain repositories
    // Create domain public server
    // Register routes
    return nil
})

// Build complete infrastructure
resources, err := builder.Build()
```

## Refactoring Note - Bootstrap Logic

**Current State**: `server_builder.go` contains mixed concerns - HTTPS configuration AND business logic initialization.

**Future Refactoring** (Phase W): Move internal service/repository bootstrap from `server_builder.go` to `ApplicationCore.StartApplicationCore()`:
- Database connection setup
- Repository initialization (barrier, realm, session, tenant, user, joinRequest)
- Service initialization (barrier, realm, session, registration, rotation, status)
- UnsealKeysService population

**Goal**: ServerBuilder focuses ONLY on HTTPS listeners and route registration. ApplicationCore handles all business logic bootstrap.

## BREAKING CHANGE: WithDefaultTenant Removed

**The `WithDefaultTenant()` method has been REMOVED from ServerBuilder.**

### Rationale

- Default tenant creation violated proper multi-tenancy isolation.
- All tenants MUST be created through the explicit registration flow.
- Services start "cold" without any default tenant/realm.

### Migration Pattern

**BEFORE (deprecated)**:
```go
// ❌ This pattern is REMOVED
builder.WithDefaultTenant(
    cryptoutilMagic.DefaultTenantID,
    cryptoutilMagic.DefaultRealmID,
)
```

**AFTER (required)**:
```go
// ✅ Services start without default tenant
resources, err := builder.Build()

// ✅ Clients register through /auth/register endpoint
// POST /service/api/v1/auth/register
// {
//   "username": "admin",
//   "password": "secure",
//   "create_tenant": true
// }
```

## Registration Flow Pattern - REQUIRED

All services using the builder pattern MUST support the registration flow:

```go
// 1. Client calls register endpoint
// POST /service/api/v1/auth/register
// Returns: { tenant_id, realm_id, session_token }

// 2. Client uses session token for subsequent requests
// Authorization: Bearer <session_token>

// 3. All API calls include tenant isolation via session context
```

## TestMain Pattern - REQUIRED

Tests MUST use TestMain to set up server with proper registration:

```go
var (
    testServer     *server.JoseServer
    testTenantID   googleUuid.UUID
    testRealmID    googleUuid.UUID
    testSessionToken string
)

func TestMain(m *testing.M) {
    ctx := context.Background()

    // Create server with test configuration
    cfg := config.NewTestSettings()
    testServer, _ = server.NewFromConfig(ctx, cfg)

    // Start server
    go testServer.Start()
    defer testServer.Shutdown(ctx)

    // Wait for ready
    testServer.WaitForReady(ctx, 10*time.Second)

    // Register test tenant through API
    resp := registerTestUser(testServer.PublicBaseURL())
    testTenantID = resp.TenantID
    testRealmID = resp.RealmID
    testSessionToken = resp.SessionToken

    // Run tests
    os.Exit(m.Run())
}

func TestSomething(t *testing.T) {
    // Use testServer, testTenantID, testRealmID, testSessionToken
    // All tests share the same registered tenant
}
```

## Merged Migrations Pattern - CRITICAL

**Problem**: golang-migrate validates ALL database versions against source filesystem
- Template migrations create 1001-1004 in schema_migrations table
- Domain migrations FS only contains 2001+
- Validation fails: "no migration found for version 1004"

**Solution**: Implement `mergedMigrations` type with `fs.FS` interface

```go
type mergedMigrations struct {
    templateFS   fs.FS    // 1001-1004: tenants, sessions, barrier, realms
    templatePath string
    domainFS     fs.FS    // 2001+: application-specific tables
    domainPath   string
}

// Implement fs.FS interface
func (m *mergedMigrations) Open(name) (fs.File, error)
func (m *mergedMigrations) ReadDir(name) ([]fs.DirEntry, error)
func (m *mergedMigrations) ReadFile(name) ([]byte, error)
func (m *mergedMigrations) Stat(name) (fs.FileInfo, error)
```

**Pattern**: Try domain FS first, fallback to template FS. golang-migrate sees unified migration stream.

## ServiceResources

Builder returns initialized infrastructure:

```go
type ServiceResources struct {
    DB               *gorm.DB
    TelemetryService *cryptoutilTelemetry.TelemetryService
    JWKGenService    *cryptoutilJose.JWKGenService
    BarrierService   *cryptoutilBarrier.BarrierService
    UnsealKeysService *cryptoutilBarrier.UnsealKeysService  // CRITICAL: Added to expose unseal keys management
    SessionManager   *cryptoutilTemplateBusinessLogic.SessionManagerService
    RealmService     cryptoutilTemplateService.RealmService
    RealmRepository  cryptoutilTemplateRepository.TenantRealmRepository
    Application      *cryptoutilTemplateServer.Application
    ShutdownCore     func()
    ShutdownContainer func()
}
```

**Note**: UnsealKeysService was added to ServiceResources to expose unseal keys management functionality. This service should be populated during ApplicationCore.StartApplicationCore() and made available for route registration.

## Test Compatibility

Services using builder MUST provide accessor methods for tests:

```go
func (s *Server) JWKGen() *cryptoutilJose.JWKGenService { return s.jwkGenService }
func (s *Server) Telemetry() *cryptoutilTelemetry.TelemetryService { return s.telemetryService }
func (s *Server) PublicPort() int { return s.app.PublicPort() }
func (s *Server) AdminPort() int { return s.app.AdminPort() }
func (s *Server) SetReady(ready bool) { s.app.SetReady(ready) }
func (s *Server) PublicBaseURL() string { return s.app.PublicBaseURL() }
func (s *Server) AdminBaseURL() string { return s.app.AdminBaseURL() }
```

## E2E Testing Helpers

**E2E Test Orchestration**: Use `internal/apps/template/testing/e2e/compose.go` for Docker Compose lifecycle management in E2E tests. `ComposeManager` handles startup, health checks, TLS-enabled HTTP client, and teardown.

## Migration Versioning

**Template migrations**: 1001-1004 (shared infrastructure)
- 1001: Sessions tables
- 1002: Barrier encryption keys
- 1003: Realm tables
- 1004: Multi-tenancy (tenants, tenant_realms)

**Domain migrations**: 2001+ (application-specific)
- cipher-im: 2001 (messages, message_recipients, message_recipient_jwks)
- jose-ja: 2001+ (JWK storage tables)
- pki-ca: 2001+ (certificate storage tables)

## Incomplete Service Implementation Anti-Pattern - CRITICAL

**Problem**: Missing public HTTP servers cause cascading configuration errors that mask root cause.

### ALWAYS DO (Code Archaeology FIRST)

✅ **Compare with working service before debugging configuration issues**
✅ **Verify all required files exist** (server.go, application.go, admin.go, public.go)
✅ **Check Application.Start() initializes both public + admin servers**
✅ **Compare container log byte counts across fix attempts**

### NEVER DO (Configuration Debugging Without Verification)

❌ **Keep applying configuration fixes when symptoms don't change**
❌ **Assume container crash is always a configuration problem**
❌ **Debug configuration before verifying complete architecture exists**

### Detection Pattern

**Indicators of Missing Implementation**:

1. **Byte count pattern**: Same bytes across multiple fix rounds = no symptom change
2. **Error message pattern**: Early rounds show specific errors, later rounds show generic startup then silence
3. **File structure pattern**: Compare with working service - notice missing files

### Time Wasted Pattern

- Configuration Debugging: 40-60 minutes (4-6 rounds × 10 minutes each)
- Code Archaeology Upfront: 9 minutes (download logs + compare architecture)

**Lesson**: Code archaeology should be FIRST step, NOT last resort

## Troubleshooting Guide

### Common ServerBuilder Issues

**Issue: "no migration found for version X"**
- **Cause**: Domain migrations FS doesn't include template migrations
- **Solution**: Use `WithDomainMigrations()` which creates merged FS internally
- **Verification**: Check schema_migrations table has both 1001-1004 AND 2001+ entries

**Issue: "database is locked" (SQLite)**
- **Cause**: MaxOpenConns=1 with GORM transactions causes deadlock
- **Solution**: Set MaxOpenConns=5 for GORM services (see 03-05.sqlite-gorm.instructions.md)
- **Verification**: Check connection pool settings after GORM initialization

**Issue: Server starts but health checks fail**
- **Cause**: Application.SetReady(true) not called after initialization
- **Solution**: Ensure ApplicationCore.StartApplicationCore() calls SetReady(true)
- **Verification**: Check `/admin/api/v1/readyz` returns 200

**Issue: Tests fail with "connection refused"**
- **Cause**: Test not waiting for server ready state
- **Solution**: Use `testServer.WaitForReady(ctx, 10*time.Second)` after Start()
- **Verification**: Check server logs for "ready" message before tests run

**Issue: Registration endpoint returns 500**
- **Cause**: Missing barrier/session/realm services in route registration
- **Solution**: Verify ServiceResources contains all required services
- **Verification**: Check server logs for initialization errors

### E2E Testing Helpers

**E2E Test Orchestration**: Use `internal/apps/template/testing/e2e/compose.go` for Docker Compose lifecycle management in E2E tests. `ComposeManager` handles startup, health checks, TLS-enabled HTTP client, and teardown.

## Key Takeaways

1. **Builder Pattern**: Eliminates 260+ lines of boilerplate per service
2. **Merged Migrations**: Solves golang-migrate validation for template + domain migrations
3. **ServiceResources**: Provides all initialized infrastructure to domain code
4. **Test Accessors**: Required delegation methods for test compatibility
5. **Migration Numbering**: Template 1001-1004, domain 2001+ (avoids conflicts)
6. **fs.FS Interface**: mergedMigrations implements Open/ReadDir/ReadFile/Stat for unified view
7. **No Default Tenant**: WithDefaultTenant() REMOVED - use registration flow
8. **TestMain Pattern**: Tests MUST use TestMain with registration for proper multi-tenancy
9. **Code Archaeology First**: Always compare with working service before debugging configuration
