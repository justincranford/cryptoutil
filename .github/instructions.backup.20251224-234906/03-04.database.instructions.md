---
description: "Instructions for database operations and ORM patterns"
applyTo: "**"
---
# Database and ORM Patterns - Tactical Guidance

**Reference**: See `.specify/memory/database.md` for complete specifications (GORM patterns, cross-DB compatibility, error mapping, migrations)

**This file contains ONLY tactical implementation patterns**

## Quick Reference: Cross-DB Compatibility

| Feature | PostgreSQL | SQLite | Solution |
|---------|-----------|---------|----------|
| UUID Type | uuid, text | text only | Use `type:text` |
| Nullable UUIDs | *UUID, NullableUUID | NullableUUID only | Use NullableUUID |
| JSON Arrays | json, text | text only | Use `serializer:json` |
| Read-Only Tx | Supported | NOT supported | Use standard tx |

## Core Patterns

**UUID Fields** (cross-DB compatible):

```go
ID googleUuid.UUID `gorm:"type:text;primaryKey"`  // ✅ Works everywhere
```

**Nullable UUIDs** (avoid pointer UUIDs):

```go
ClientProfileID NullableUUID `gorm:"type:text;index"`  // ✅ Custom type
```

**JSON Arrays/Objects** (cross-DB compatible):

```go
AllowedScopes []string `gorm:"serializer:json"`  // ✅ Works everywhere
```

**Database DSN**:

```go
dsn := "postgres://user:pass@localhost:5432/dbname?sslmode=disable"
```

## Cross-Database Compatibility - CRITICAL

### UUID Type Handling

✅ `gorm:"type:text"` (works on PostgreSQL + SQLite)
❌ `gorm:"type:uuid"` (breaks SQLite - no native UUID type)

### Nullable UUID Foreign Keys

✅ `NullableUUID` type (implements sql.Scanner + driver.Valuer)
❌ `*googleUuid.UUID` (causes "row value misused" in SQLite)

### JSON Array/Object Fields

✅ `gorm:"serializer:json"` (works on PostgreSQL + SQLite)
❌ `gorm:"type:json"` (breaks SQLite - no native JSON type)

## SQLite Concurrent Write Operations - CRITICAL

**ALWAYS configure these SQLite settings to handle concurrent writes and parallel testing:**

### Required PRAGMA Settings

```go
// Enable WAL mode for better concurrency (allows multiple readers + 1 writer)
if _, err := sqlDB.Exec("PRAGMA journal_mode=WAL;"); err != nil {
    return fmt.Errorf("failed to enable WAL mode: %w", err)
}

// Set busy timeout for handling concurrent write operations (30 seconds)
if _, err := sqlDB.Exec("PRAGMA busy_timeout = 30000;"); err != nil {
    return fmt.Errorf("failed to set busy timeout: %w", err)
}
```

### Connection Pool Configuration

```go
// For SQLite, limit connection pool to prevent write contention
// SQLite only supports 1 concurrent writer (even in WAL mode)
sqlDB.SetMaxOpenConns(1)  // Use magic constant: cryptoutilMagic.SQLiteMaxOpenConnections
sqlDB.SetMaxIdleConns(1)
```

### Why This Matters

- **WAL mode** (Write-Ahead Logging) allows multiple concurrent readers and one writer
- **busy_timeout** makes SQLite retry when database is locked instead of immediately failing
- **MaxOpenConns=1** prevents connection pool from trying concurrent writes (which would fail)
- **Without these settings**, parallel Go tests using `t.Parallel()` will fail with database locking errors

### Reference Implementation

See `internal/server/repository/sqlrepository/sql_provider.go` lines 201-213 for the canonical SQLite configuration pattern used in the KMS server code.

### Magic Constants

Use these constants from `internal/common/magic/magic_database.go`:

- `cryptoutilMagic.DBSQLiteBusyTimeout` = 30 seconds
- `cryptoutilMagic.SQLiteMaxOpenConnections` = 1

## SQLite Read-Only Transactions - CRITICAL

**SQLite does NOT support read-only transactions - NEVER use them:**

```go
// WRONG - fails on SQLite with "cannot start a transaction within a transaction" or similar errors
tx := db.Begin(&sql.TxOptions{ReadOnly: true})

// CORRECT for SQLite - use default transaction or avoid transactions for read-only operations
tx := db.Begin()  // Standard read-write transaction
// OR
result := db.Find(&models)  // Direct query without explicit transaction
```

**Why:**

- SQLite does not support the `READ ONLY` transaction isolation level
- PostgreSQL supports `SET TRANSACTION READ ONLY` but SQLite ignores/errors on this
- Tests using read-only transactions will fail on SQLite: "SQLite doesn't support read-only transactions"
- **Solution**: Use standard transactions or direct queries for read operations

**Cross-DB Pattern for Read-Heavy Operations:**

```go
// Use this pattern for cross-database compatibility
func (r *Repository) GetMany(ctx context.Context) ([]Model, error) {
    var results []Model
    // Don't use Begin() for simple reads - direct query is sufficient
    if err := r.db.WithContext(ctx).Find(&results).Error; err != nil {
        return nil, fmt.Errorf("failed to query: %w", err)
    }
    return results, nil
}
```

## Multi-Tenancy - MANDATORY

**Schema-Level Isolation ONLY**:

- Each tenant gets separate schema: `tenant_<uuid>.users`, `tenant_<uuid>.sessions`
- NEVER use row-level multi-tenancy (single schema, tenant_id column)
- Reason: Data isolation, compliance, performance (per-tenant indexes)
- Pattern: Set `search_path` on connection: `SET search_path TO tenant_abc123`

## Read Replicas - NOT SUPPORTED

**Read replicas are NOT supported in cryptoutil**:

- All traffic goes to primary database (write + read)
- Reason: Session consistency, ACID guarantees, operational simplicity
- Future: May add read replicas in Phase 4 (multi-region scale)

## Connection Pool Configuration - MANDATORY

**Hot-Reload Pattern**:

- Connection pool settings MUST be reconfigurable without restart
- Pattern: Watch config file, call `sqlDB.SetMaxOpenConns()` on change
- Settings: `max_open_conns`, `max_idle_conns`, `conn_max_lifetime`
- Validation: MUST validate settings before applying (prevent invalid configs)

## Database DSN Usage

**Database DSN (Use localhost):**

```go
dsn := "postgres://user:pass@localhost:5432/dbname?sslmode=disable"
```
