# LLM Agent Continuous Work Directive - ABSOLUTE ENFORCEMENT

**This file contains ONLY tactical implementation patterns**

**CRITICAL: NEVER STOP WORKING UNTIL USER EXPLICITLY CLICKS "STOP" button in Copilot Chat**

## Time and Token Management

- **NO TIME PRESSURE**: Work can span hours or days - this is expected and acceptable
- **NO TOKEN PRESSURE**: Large tasks requiring many tool calls are normal - use as many tokens as needed
- **DECOMPOSE COMPLEX TASKS**: Break hard/long/complete issues into smaller, manageable subtasks
- **DOCUMENT TASKS AND PROGRESS**: Document decomposed tasks and progress continuously
- **CORRECTNESS > SPEED**: Always prioritize doing things correctly and completely over rushing
- **ALWAYS COMMIT CHANGES IMMEDIATELY WHEN WORK IS COMPLETE**

## Prohibited Stop Behaviors - ABSOLUTE

❌ **NEVER** stop to give status summaries ("Here's what we've done...")
❌ **NEVER** stop to suggest "next steps" ("Would you like me to...")
❌ **NEVER** stop to justify time/tokens ("This will take a while...")
❌ **NEVER** stop to ask permission ("Should I proceed with...")
❌ **NEVER** leave uncommitted changes (ALWAYS commit immediately when work complete)
❌ **NEVER** claim completion prematurely ("All done! Summary:...")
❌ **NEVER** stop after completing one file/task when more work remains
❌ **NEVER** stop after creating review documents - FIX THE ISSUES FOUND

## Continuous Work Pattern

Complete task → Immediately start next task → Repeat
**NO text between tool calls** | **Progress is NOT a stop condition** | **Blockers on Task A → switch to Task B**

## Execution Rules

✅ Execute tool → Execute next tool (zero text between)
✅ IF making progress: Keep going
✅ IF stuck on Task A: Switch to Task B (never stop to ask)
✅ IF committing: Commit then read_file next task location
✅ **ONLY valid stop**: User types "STOP" or "PAUSE"

## Handling Blockers and Issues

**CRITICAL: Blockers on one task NEVER justify stopping all work**

- **When blocked on Task A**: Immediately switch to Task B, C, D... (continue all other work)
- **Keep working**: Return to blocked task only when blocker is resolved
- **NO stopping to ask**: If user input needed, document requirement and continue other work
- **NO waiting**: Never do idle waiting for external dependencies - work on everything else meanwhile

## When All Current Tasks Are Complete or Blocked

**CRITICAL: "No immediate work" does NOT mean stop - find more work**

1. Check latest plan for incomplete phases
2. Check latest tasks for incomplete tasks
3. Look for quality improvements (coverage gaps, test speed, linting issues, TODOs in code)
4. Scan for technical debt (grep for TODO/FIXME/HACK comments, address them)
5. Review recent commits (check for incomplete work, missing tests, documentation gaps)
6. Verify CI/CD health (check workflow files, fix any disabled/failing checks)
7. Code quality sweep (run golangci-lint, fix warnings, improve test coverage & gremlins)
8. Performance analysis (identify slow tests >15s, apply probabilistic execution)
9. Mutation testing (run gremlins on packages below 98% mutation score)
10. ONLY if literally nothing exists: Ask user for next work direction

**Pattern when phase complete**:

- ❌ WRONG: "Phase 3 complete! Here's what we did..." (STOPPING)
- ✅ CORRECT: `read_file task_documentation` → find Phase 4/5/6 tasks → immediately start first task
