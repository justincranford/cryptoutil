name: CI - End-to-End Testing
# CROSS-PLATFORM COMPATIBILITY: All file references in this workflow MUST use relative paths
# to support both GitHub Actions Ubuntu runners and Windows `act` local runner testing.
# Absolute paths (e.g., C:\...) break cross-platform compatibility.
# Example: Use './deployments/compose/compose.yml'

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - '.github/copilot-instructions.md'
      - '.github/instructions/**'
      - 'workflow-reports/**'
      - 'nohup.out'
      - 'LICENSE'
      - '.editorconfig'
      - '.gitignore'
      - '.gitattributes'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/pull_request_template.md'
      - '.github/dependabot.yml'
      - '**/*.log'
      - '**/*.sarif'
  pull_request:
    branches: [ main, develop ]
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - '.github/copilot-instructions.md'
      - '.github/instructions/**'
      - 'workflow-reports/**'
      - 'nohup.out'
      - 'LICENSE'
      - '.editorconfig'
      - '.gitignore'
      - '.gitattributes'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/pull_request_template.md'
      - '.github/dependabot.yml'
      - '**/*.log'
      - '**/*.sarif'
  workflow_dispatch:

env:
  GO_VERSION: '1.25.3'

jobs:
  # End-to-End Testing - Full system validation with Docker Compose
  e2e:
    name: End-to-End Tests
    runs-on: ubuntu-latest

    steps:
      - name: Workflow Start - CI - End-to-End Testing (ci-e2e.yml)
        run: |
          echo "=========================================="
          echo "Workflow: ${{ github.workflow }}"
          echo "File: .github/workflows/ci-e2e.yml"
          echo "Job: e2e"
          echo "Triggered by: ${{ github.event_name }}"
          echo "=========================================="

      - name: Checkout code
        uses: actions/checkout@v5.0.0
        with:
          sparse-checkout-cone-mode: false

      - name: Set up Go
        uses: actions/setup-go@v6.0.0
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Pre-pull Docker images (parallel)
        uses: ./.github/actions/docker-image-prepull
        with:
          verify-docker-environment: true

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: |
          echo "üîç Verifying Go dependencies..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          go mod verify
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è Dependency verification completed in: ${DURATION}s"

      - name: Clean and verify module files
        run: |
          echo "üßπ Cleaning and verifying Go module files..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          go mod tidy
          git diff --exit-code go.mod go.sum
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è Module file verification completed in: ${DURATION}s"

      - name: Run E2E tests
        run: |
          echo "üß™ Running end-to-end tests..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          # Set environment variable to help with debugging
          export E2E_DEBUG=1

          # Run the tests and capture output
          if go test -tags=e2e -v -timeout=30m ./internal/test/e2e/ 2>&1; then
            echo "‚úÖ E2E tests completed successfully"
          else
            echo "‚ùå E2E tests failed"
            exit 1
          fi
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è E2E tests completed in: ${DURATION}s"

      - name: Display container logs
        if: always()
        run: |
          echo "üìã Displaying captured container logs..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          LOG_DIR="./workflow-reports/e2e"

          # Check if directory exists
          if [ ! -d "$LOG_DIR" ]; then
            echo "‚ùå Log directory $LOG_DIR does not exist"
            echo "üìã Checking if workflow-reports directory exists..."
            if [ -d "./workflow-reports" ]; then
              echo "‚úÖ workflow-reports directory exists"
              ls -la ./workflow-reports/
            else
              echo "‚ùå workflow-reports directory does not exist"
            fi
            exit 1
          fi

          echo "‚úÖ Found log directory: $LOG_DIR"

          # List all files in the directory with full details
          echo "üìÅ Directory contents (detailed):"
          ls -la "$LOG_DIR/" || echo "‚ùå Failed to list directory contents"

          # Check for zip files specifically
          echo "üîç Looking for zip files..."
          ZIP_COUNT=$(find "$LOG_DIR" -name "*.zip" 2>/dev/null | wc -l)
          echo "Found $ZIP_COUNT zip files"

          if [ "$ZIP_COUNT" -eq 0 ]; then
            echo "‚ùå No container log archives found in $LOG_DIR"
            echo "üìã Checking for any log files directly..."
            LOG_FILES=$(find "$LOG_DIR" -name "*.log" 2>/dev/null || true)
            if [ -n "$LOG_FILES" ]; then
              echo "üìÑ Found log files:"
              echo "$LOG_FILES"
              echo "üìñ Displaying log file contents (first 20 lines each):"
              for log_file in $LOG_FILES; do
                echo "üîç Contents of: $(basename "$log_file")"
                echo "----------------------------------------"
                head -20 "$log_file" || echo "‚ùå Failed to read $log_file"
                echo "----------------------------------------"
                echo ""
              done
            else
              echo "‚ùå No log files found either"
              echo "üîç Checking for any files at all..."
              ANY_FILES=$(find "$LOG_DIR" -type f 2>/dev/null | wc -l)
              echo "Found $ANY_FILES files total in $LOG_DIR"
              if [ "$ANY_FILES" -gt 0 ]; then
                echo "üìÑ All files in directory:"
                find "$LOG_DIR" -type f -exec ls -la {} \;
              fi
            fi
            exit 1
          fi

          echo "‚úÖ Container log archives found"

          # Get the most recent zip file
          LATEST_ZIP=$(find "$LOG_DIR" -name "*.zip" -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
          if [ -z "$LATEST_ZIP" ]; then
            LATEST_ZIP=$(ls -t ${LOG_DIR}/*.zip 2>/dev/null | head -1)
          fi

          if [ -z "$LATEST_ZIP" ] || [ ! -f "$LATEST_ZIP" ]; then
            echo "‚ùå Could not determine latest zip file"
            exit 1
          fi

          echo "üì¶ Processing archive: $LATEST_ZIP"
          echo "üìä Archive size: $(stat -c%s "$LATEST_ZIP" 2>/dev/null || echo "unknown") bytes"

          # Check if unzip is available
          if ! command -v unzip &> /dev/null; then
            echo "‚ùå unzip command not available"

            # Try using python to extract zip
            if command -v python3 &> /dev/null; then
              echo "üêç Using Python to extract zip file..."
              python3 -c "
              import zipfile
              import os
              import sys

              zip_path = '$LATEST_ZIP'
              extract_dir = '/tmp/container_logs_' + str(os.getpid())

              print(f'Extracting {zip_path} to {extract_dir}')

              try:
                os.makedirs(extract_dir, exist_ok=True)
                with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                  file_list = zip_ref.namelist()
                  print(f'Archive contains {len(file_list)} files:')
                  for file in file_list[:10]:  # Show first 10 files
                    print(f'  {file}')
                  if len(file_list) > 10:
                    print(f'  ... and {len(file_list) - 10} more files')

                  zip_ref.extractall(extract_dir)
                  print(f'‚úÖ Successfully extracted to {extract_dir}')

                  # Display log files
                  log_count = 0
                  for root, dirs, files in os.walk(extract_dir):
                    for file in files:
                      if file.endswith('.log'):
                        log_count += 1
                        file_path = os.path.join(root, file)
                        print(f'ÔøΩ Logs for service: {file[:-4]}')  # Remove .log extension
                        print('----------------------------------------')
                        with open(file_path, 'r') as f:
                          content = f.read()
                          # Show first 2000 chars to avoid too much output
                          if len(content) > 2000:
                            print(content[:2000] + '...')
                            print(f'(truncated, {len(content)} total characters)')
                          else:
                            print(content)
                        print('----------------------------------------')
                        print('')

                  if log_count == 0:
                    print('‚ö†Ô∏è No .log files found in archive')
                    print('All files in archive:')
                    for root, dirs, files in os.walk(extract_dir):
                      for file in files:
                        file_path = os.path.join(root, file)
                        print(f'  {os.path.relpath(file_path, extract_dir)}')

              except Exception as e:
                print(f'‚ùå Failed to extract with Python: {e}')
                import traceback
                traceback.print_exc()
                sys.exit(1)
              "
            else
              echo "‚ùå Neither unzip nor python3 available for extraction"
              exit 1
            fi
          else
            echo "‚úÖ unzip command available"

            # Create temp directory for extraction
            TEMP_DIR=$(mktemp -d)
            echo "üìÅ Extracting to: $TEMP_DIR"

            # Extract the zip file with verbose output
            echo "üîÑ Extracting zip file..."
            if unzip -l "$LATEST_ZIP"; then
              echo "‚úÖ Zip file listing successful"

              if unzip -q "$LATEST_ZIP" -d "$TEMP_DIR"; then
                echo "‚úÖ Successfully extracted zip file"

                # List extracted files
                echo "üìÑ Extracted files:"
                find "$TEMP_DIR" -type f | head -20

                # Display logs for each service
                LOG_COUNT=0
                while IFS= read -r -d '' log_file; do
                  LOG_COUNT=$((LOG_COUNT + 1))
                  SERVICE_NAME=$(basename "$log_file" .log)
                  echo "üîç Logs for service: $SERVICE_NAME"
                  echo "----------------------------------------"

                  # Show first 50 lines to avoid too much output
                  head -50 "$log_file"

                  # If file is longer, indicate truncation
                  LINE_COUNT=$(wc -l < "$log_file" 2>/dev/null || echo 0)
                  if [ "$LINE_COUNT" -gt 50 ]; then
                    echo "... (truncated, $LINE_COUNT total lines)"
                  fi

                  echo "----------------------------------------"
                  echo ""
                done < <(find "$TEMP_DIR" -name "*.log" -print0)

                if [ "$LOG_COUNT" -eq 0 ]; then
                  echo "‚ö†Ô∏è No .log files found in extracted archive"
                  echo "üìÑ All extracted files:"
                  find "$TEMP_DIR" -type f -exec ls -la {} \;
                else
                  echo "‚úÖ Displayed logs for $LOG_COUNT services"
                fi

              else
                echo "‚ùå Failed to extract zip file"
                unzip -v "$LATEST_ZIP" || echo "‚ùå Could not get zip file info"
                exit 1
              fi
            else
              echo "‚ùå Failed to list zip file contents"
              exit 1
            fi

            # Clean up temp directory
            rm -rf "$TEMP_DIR"
          fi
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è Container log display completed in: ${DURATION}s"

      - name: Upload container logs
        if: always()
        uses: actions/upload-artifact@v5.0.0
        with:
          name: e2e-container-logs-${{ github.run_id }}
          path: ./workflow-reports/e2e/
          if-no-files-found: ignore
          retention-days: 30

      - name: E2E test summary
        if: always()
        run: |
          echo "## üß™ End-to-End Testing Results" >> $GITHUB_STEP_SUMMARY
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          if [ ${{ job.status }} == 'success' ]; then
            echo "‚úÖ End-to-end tests completed successfully." >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå End-to-end tests failed." >> $GITHUB_STEP_SUMMARY
          fi
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è E2E test summary completed in: ${DURATION}s"

      - name: Stop services
        if: always()
        run: |
          echo "üßπ Stopping services..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          docker compose -f ./deployments/compose/compose.yml down -v
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è Service cleanup completed in: ${DURATION}s"
