name: DAST Security Testing
# IMPORTANT: Test locally with act (NO TIMEOUT - workflows take 3-25 minutes):
#   [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
#   act workflow_dispatch -W .github/workflows/dast.yml --input scan_profile=quick --artifact-server-path ./dast-reports 2>&1 | Out-File -FilePath .\dast-reports\act-dast.log -Encoding utf8
#   act workflow_dispatch -W .github/workflows/dast.yml --input scan_profile=full --artifact-server-path ./dast-reports 2>&1 | Out-File -FilePath .\dast-reports\act-dast.log -Encoding utf8
#   act workflow_dispatch -W .github/workflows/dast.yml --input scan_profile=deep --artifact-server-path ./dast-reports 2>&1 | Out-File -FilePath .\dast-reports\act-dast.log -Encoding utf8
# MONITORING: Auto-monitor progress in separate terminal: .\scripts\monitor-act-dast.ps1
# MANUAL CHECK: Get-Content .\dast-reports\act-dast.log -Tail 100
# TIMING: Quick=3-5min, Full=10-15min, Deep=20-25min
# OUTPUT CONVENTION: All scan outputs and reports must be written to ./dast-reports/ directory

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.github/copilot-instructions.md'
      - '.github/instructions/**'
      - 'dast-reports/**'
      - 'nohup.out'
      - 'LICENSE'
      - '.editorconfig'
      - '.gitignore'
      - '.gitattributes'
      - '.golangci.yml'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/pull_request_template.md'
      - '.github/dependabot.yml'
      - 'scripts/**'
      - '**/*.log'
      - '**/*.sarif'
  pull_request:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.github/copilot-instructions.md'
      - '.github/instructions/**'
      - 'dast-reports/**'
      - 'nohup.out'
      - 'LICENSE'
      - '.editorconfig'
      - '.gitignore'
      - '.gitattributes'
      - '.golangci.yml'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/pull_request_template.md'
      - '.github/dependabot.yml'
      - 'scripts/**'
      - '**/*.log'
      - '**/*.sarif'
  schedule:
    # Run DAST weekly on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      target_url:
        description: 'Target URL for DAST scanning (default: https://127.0.0.1:8080)'
        required: false
        default: 'https://127.0.0.1:8080'
      scan_profile:
        description: 'Scan profile for performance optimization'
        required: false
        default: 'full'
        type: choice
        options:
          - quick
          - full
          - deep

env:
  GO_VERSION: '1.25.1'

  SCAN_PROFILE: ${{ github.event.inputs.scan_profile || 'full' }}

  # HTTP endpoints use 127.0.0.1 (not localhost) for predictable IPv4 behavior and TLS certificate compatibility
  APP_PUBLIC_TARGET_URL: ${{ github.event.inputs.target_url || 'https://127.0.0.1:8080' }}
  APP_PRIVATE_TARGET_URL: ${{ github.event.inputs.target_url || 'http://127.0.0.1:9090' }}

  # Nuclei runs inside GitHub Actions runner/act container - can use 127.0.0.1 directly
  NUCLEI_PUBLIC_TARGET_URL: ${{ github.event.inputs.target_url || 'https://127.0.0.1:8080' }}

  # ZAP runs in separate Docker container - must use host.docker.internal to reach host network
  ZAP_PUBLIC_TARGET_URL: ${{ github.event.inputs.target_url || 'https://host.docker.internal:8080' }}

  APP_BIND_PUBLIC_PROTOCOL: https
  APP_BIND_PUBLIC_ADDRESS: 0.0.0.0
  APP_BIND_PUBLIC_PORT: 8080

  APP_BIND_PRIVATE_PROTOCOL: http
  APP_BIND_PRIVATE_ADDRESS: 127.0.0.1
  APP_BIND_PRIVATE_PORT: 9090

  # Database uses localhost (not 127.0.0.1) for PostgreSQL client library optimization
  DB_HOST: localhost
  DB_PORT: 5432
  DB_NAME: DB
  DB_USER: USR
  DB_PASSWORD: PWD

jobs:
  dast-security-scan:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_DB: ${{ env.DB_NAME }}
          POSTGRES_PASSWORD: ${{ env.DB_PASSWORD }}
          POSTGRES_USER: ${{ env.DB_USER }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432 # env context is not available in the services.ports section

    permissions:
      contents: read
      security-events: write
      actions: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup directories and Nuclei templates version
      id: nuclei-version
      run: |
        # Create required directories
        mkdir -p ./dast-reports configs/test
        # Ephemeral mode: always use latest nuclei templates
        echo "templates_version=LATEST" >> $GITHUB_OUTPUT

    - name: Cache Nuclei Templates
      id: cache-nuclei-templates
      uses: actions/cache@v4
      with:
        path: /root/nuclei-templates
        key: nuclei-templates-${{ runner.os }}-${{ steps.nuclei-version.outputs.templates_version }}
        restore-keys: |
          nuclei-templates-${{ runner.os }}-

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true

    - name: Install dependencies
      run: go mod download

    - name: Build application
      run: go build -o cryptoutil ./cmd/cryptoutil

    - name: Adjust ZAP target for local act runs
      if: ${{ github.actor == 'nektos/act' }}
      run: |
        echo "Running under act - selecting ZAP_PUBLIC_TARGET_URL for local scans"
        # For local 'act' runs prefer host.docker.internal (Docker Desktop on Windows) so the ZAP container
        # can reach services running on the host. If that isn't reachable the diagnostic step will try
        # additional fallbacks (127.0.0.1 and the private HTTP endpoint) and pick the first reachable one.
        echo "ZAP_PUBLIC_TARGET_URL=https://host.docker.internal:8080" >> $GITHUB_ENV
        echo "Note: diagnostic_connectivity will verify reachability and override this value if needed."

    # See internal\common\config\config.go for configuration options
    - name: Start application for DAST testing
      run: |
        # Create unseal secret and config files
        echo "dast-simple-unseal-secret-value-1" > ./configs/test/dast-simple-unseal-secret-value-1.secret
        cat > ./configs/test/config.yml <<EOF
        bind-public-protocol: "${APP_BIND_PUBLIC_PROTOCOL}"
        bind-public-address: "${APP_BIND_PUBLIC_ADDRESS}"
        bind-public-port: ${APP_BIND_PUBLIC_PORT}
        bind-private-protocol: "${APP_BIND_PRIVATE_PROTOCOL}"
        bind-private-address: "${APP_BIND_PRIVATE_ADDRESS}"
        bind-private-port: ${APP_BIND_PRIVATE_PORT}
        database-url: "postgres://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}?sslmode=disable"
        unseal-mode: "1-of-1"
        unseal-files:
          - ./configs/test/dast-simple-unseal-secret-value-1.secret
        EOF

        # Start application in background, capture PID for cleanup; use nohup to avoid termination on shell exit
        nohup ./cryptoutil server start --config configs/test/config.yml &
        APP_PID=$!
        echo "APP_PID=$APP_PID" >> $GITHUB_ENV

        # Enhanced readiness probe with retry/backoff logic
        echo "Waiting for application to be ready..."
        MAX_ATTEMPTS=30
        ATTEMPT=0
        BACKOFF=1
        READY=false

        # Progressive health check: private health endpoints first, then public Swagger
        HEALTH_ENDPOINTS=(
          "${{ env.APP_PRIVATE_TARGET_URL }}/readyz"
          "${{ env.APP_PRIVATE_TARGET_URL }}/livez"
          "${{ env.APP_PUBLIC_TARGET_URL }}/ui/swagger/doc.json"
        )

        while [ $ATTEMPT -lt $MAX_ATTEMPTS ] && [ "$READY" != "true" ]; do
          ATTEMPT=$((ATTEMPT + 1))
          echo "Attempt $ATTEMPT/$MAX_ATTEMPTS (backoff: ${BACKOFF}s)"

          for endpoint in "${HEALTH_ENDPOINTS[@]}"; do
            echo "Testing: $endpoint"
            # Use slightly generous timeouts for containerized environments
            if curl -k -f --connect-timeout 10 --max-time 15 "$endpoint" >/dev/null 2>&1; then
              echo "âœ“ Application ready at: $endpoint"
              READY=true
              break
            else
              echo "âœ— Not ready: $endpoint"
            fi
          done

          if [ "$READY" != "true" ]; then
            sleep $BACKOFF
            # Exponential backoff with max 5 seconds
            BACKOFF=$((BACKOFF < 5 ? BACKOFF + 1 : 5))
          fi
        done

        if [ "$READY" != "true" ]; then
          echo "âŒ Application failed to become ready within timeout"
          exit 1
        fi

        echo "âœ… Application is ready and responsive"

    - name: Diagnostic - Verify connectivity from runner and Docker contexts
      id: diagnostic_connectivity
      if: always()
      run: |
        # Diagnostic connectivity checks: quick reachability tests that return concise status codes.
        # Use consistent timeouts for all diagnostic curl calls.
        CURL_CONNECT_TIMEOUT=10
        CURL_MAX_TIMEOUT=15

        echo ""
        echo "ğŸ” Testing connectivity from runner..."
        echo ""

        echo "1. Testing ${{ env.APP_PRIVATE_TARGET_URL }}/readyz (readiness probe)"
        if curl -skf --connect-timeout $CURL_CONNECT_TIMEOUT --max-time $CURL_MAX_TIMEOUT ${{ env.APP_PRIVATE_TARGET_URL }}/readyz -o /dev/null -w "HTTP %{http_code}\n" 2>&1; then
          echo "  âœ… ${{ env.APP_PRIVATE_TARGET_URL }} reachable from runner"
        else
          echo "  âŒ ${{ env.APP_PRIVATE_TARGET_URL }} NOT reachable from runner (exit code: $?)"
        fi

        echo "2. Testing ${{ env.APP_PUBLIC_TARGET_URL }}/ui/swagger"
        if curl -skf --connect-timeout $CURL_CONNECT_TIMEOUT --max-time $CURL_MAX_TIMEOUT ${{ env.APP_PUBLIC_TARGET_URL }}/ui/swagger -o /dev/null -w "HTTP %{http_code}\n" 2>&1; then
          echo "  âœ… ${{ env.APP_PUBLIC_TARGET_URL }} reachable from runner"
        else
          echo "  âŒ ${{ env.APP_PUBLIC_TARGET_URL }} NOT reachable from runner (exit code: $?)"
        fi

        echo "3. Testing Nuclei target ${{ env.NUCLEI_PUBLIC_TARGET_URL }}/ui/swagger"
        # Nuclei runs inside the runner/act container, so test reachability from runner and record result
        if curl -skf --connect-timeout $CURL_CONNECT_TIMEOUT --max-time $CURL_MAX_TIMEOUT ${{ env.NUCLEI_PUBLIC_TARGET_URL }}/ui/swagger -o /dev/null -w "HTTP %{http_code}\n" 2>&1; then
          echo "  âœ… Nuclei target reachable from runner"
          echo "NUCLEI_REACHABLE=true" >> $GITHUB_ENV
          echo "NUCLEI_REACHABLE=true" >> $GITHUB_OUTPUT
        else
          echo "  âŒ Nuclei target NOT reachable from runner (exit code: $?)"
          echo "NUCLEI_REACHABLE=false" >> $GITHUB_ENV
          echo "NUCLEI_REACHABLE=false" >> $GITHUB_OUTPUT
        fi

        echo ""
        echo "ğŸ” Testing connectivity from Docker container..."
        echo ""

        echo "4. Testing ${{ env.ZAP_PUBLIC_TARGET_URL }}/ui/swagger"
        # Run the same timed check from inside a Docker container (ZAP context) and record result.
        # If the configured ZAP_PUBLIC_TARGET_URL is not reachable, try common fallbacks so local 'act' and GitHub runners work.
        # Prefer host.docker.internal for Docker Desktop / Windows hosts. The diagnostic will still
        # try additional fallbacks if this isn't reachable.
        ZAP_TRY_URLS=(
          "https://host.docker.internal:8080"
          "${{ env.ZAP_PUBLIC_TARGET_URL }}"
          "https://127.0.0.1:8080"
          "http://127.0.0.1:9090"
        )

        ZAP_REACHABLE=false
        for try_url in "${ZAP_TRY_URLS[@]}"; do
          echo "  -> Trying from Docker: $try_url/ui/swagger"
          if docker run --rm --network=host curlimages/curl:latest \
            curl -skf --connect-timeout $CURL_CONNECT_TIMEOUT --max-time $CURL_MAX_TIMEOUT "$try_url/ui/swagger" -o /dev/null -w "HTTP %{http_code}\n" 2>&1; then
            echo "    âœ… $try_url reachable from Docker container"
            echo "ZAP_PUBLIC_TARGET_URL=$try_url" >> $GITHUB_ENV
            echo "ZAP_PUBLIC_TARGET_URL=$try_url" >> $GITHUB_OUTPUT
            echo "ZAP_REACHABLE=true" >> $GITHUB_ENV
            echo "ZAP_REACHABLE=true" >> $GITHUB_OUTPUT
            ZAP_REACHABLE=true
            break
          else
            echo "    âŒ $try_url NOT reachable from Docker container (exit code: $?)"
          fi
        done

        # Debug: show final chosen ZAP_PUBLIC_TARGET_URL to help troubleshooting in logs
        echo "DEBUG: Final ZAP_PUBLIC_TARGET_URL=${ZAP_PUBLIC_TARGET_URL:-${{ env.ZAP_PUBLIC_TARGET_URL }}}"

        if [ "$ZAP_REACHABLE" != "true" ]; then
          echo "  âŒ No reachable ZAP target from Docker container; setting ZAP_REACHABLE=false"
          echo "ZAP_REACHABLE=false" >> $GITHUB_ENV
          echo "ZAP_REACHABLE=false" >> $GITHUB_OUTPUT
        fi

        echo "5. Testing ${{ env.APP_PUBLIC_TARGET_URL }} from Docker (should fail - for comparison):"
        if docker run --rm --network=host curlimages/curl:latest \
          curl -skf --connect-timeout $CURL_CONNECT_TIMEOUT --max-time $CURL_MAX_TIMEOUT ${{ env.APP_PUBLIC_TARGET_URL }}/ui/swagger -o /dev/null -w "HTTP %{http_code}\n" 2>&1; then
          echo "  âœ… ${{ env.APP_PUBLIC_TARGET_URL }} reachable from Docker (unexpected)"
        else
          echo "  âŒ ${{ env.APP_PUBLIC_TARGET_URL }} NOT reachable from Docker (expected behavior)"
        fi

        echo ""
        echo "=== Summary ==="
        echo "- ACT public target URL should use: ${{ env.APP_PUBLIC_TARGET_URL }}"
        echo "- ACT private target URL should use: ${{ env.APP_PRIVATE_TARGET_URL }}"
        echo "- Nuclei public target URL should use: ${{ env.NUCLEI_PUBLIC_TARGET_URL }}"
        echo "- ZAP public target URL should use: ${{ env.ZAP_PUBLIC_TARGET_URL }}"

    - name: Capture baseline response headers (immediate)
      if: always()
      run: |
        # Capture headers from key API endpoints (app is ready per health check)
        echo "ğŸ” Starting header capture from ${{ env.APP_PUBLIC_TARGET_URL }}..."
        echo "ğŸ“‚ Current directory: $(pwd)"
        echo "ğŸ“ Contents of dast-reports before capture:"
        ls -la dast-reports/ || echo "dast-reports directory not found"

        echo "ğŸ“ Creating header baseline file..."
        {
          echo "# Header Baseline ($(date -u))"
          echo "## Private - readyz"
          curl -skI ${{ env.APP_PRIVATE_TARGET_URL }}/readyz 2>/dev/null || echo "(failed)"
          echo -e "\n## Private - livez"
          curl -skI ${{ env.APP_PRIVATE_TARGET_URL }}/livez 2>/dev/null || echo "(failed)"
          echo "## Swagger UI (main page)"
          curl -skI ${{ env.APP_PUBLIC_TARGET_URL }}/ui/swagger/ 2>/dev/null || echo "(failed)"
          echo -e "\n## Swagger API spec (doc.json)"
          curl -skI ${{ env.APP_PUBLIC_TARGET_URL }}/ui/swagger/doc.json 2>/dev/null || echo "(failed)"
          echo -e "\n## Browser API - CSRF token endpoint"
          curl -skI ${{ env.APP_PUBLIC_TARGET_URL }}/browser/api/v1/csrf-token 2>/dev/null || echo "(failed)"
          echo -e "\n## Browser API - Elastic Keys endpoint"
          curl -skI ${{ env.APP_PUBLIC_TARGET_URL }}/browser/api/v1/elastickeys 2>/dev/null || echo "(failed)"
          echo -e "\n## Service API - Elastic Keys endpoint"
          curl -skI ${{ env.APP_PUBLIC_TARGET_URL }}/service/api/v1/elastickeys 2>/dev/null || echo "(failed)"
        } > dast-reports/response-headers.txt

        echo "ğŸ“„ Verifying file creation:"
        if [ -f "dast-reports/response-headers.txt" ]; then
          echo "âœ… File created successfully: dast-reports/response-headers.txt"
          echo "ğŸ“ File size: $(wc -c < dast-reports/response-headers.txt) bytes"
          echo "ğŸ“‹ File contents preview (first 10 lines):"
          head -10 dast-reports/response-headers.txt
        else
          echo "âŒ File NOT created: dast-reports/response-headers.txt"
        fi

        echo "ğŸ“ Contents of dast-reports after capture:"
        ls -la dast-reports/ || echo "dast-reports directory not found"

        echo "âœ… Header capture process completed"

    # IMPORTANT: ZAP runs in a separate Docker container (not inside act/runner)
    # This is different from Nuclei which runs via projectdiscovery/nuclei-action inside the runner.
    # ZAP must use host.docker.internal to reach the application on the host network.

    # Options doc: https://www.zaproxy.org/docs/docker/full-scan/
    - name: Run OWASP ZAP DAST Scan
      if: ${{ steps.diagnostic_connectivity.outputs.ZAP_REACHABLE == 'true' }}
      uses: zaproxy/action-full-scan@v0.12.0
      with:
        target: ${{ env.ZAP_PUBLIC_TARGET_URL }}
        rules_file_name: '.zap/rules.tsv'
        # Cookie ignore list trimmed: only _csrf is used by cryptoutil.
        # JSESSIONID / csrftoken are from other stacks; keeping them caused confusion.
        cmd_options: '-a -j -m 10 -T 60 -z "-config rules.cookie.ignorelist=_csrf"'
        allow_issue_writing: false
        artifact_name: 'zap-report'
        # Note: ZAP action outputs will be moved to dast-reports/ in collect step

    - name: Run OWASP ZAP API Scan
      if: ${{ steps.diagnostic_connectivity.outputs.ZAP_REACHABLE == 'true' }}
      uses: zaproxy/action-api-scan@v0.9.0
      with:
        target: '${{ env.ZAP_PUBLIC_TARGET_URL }}/ui/swagger/doc.json'
        format: openapi
        cmd_options: '-a -j -T 60'
        allow_issue_writing: false
        artifact_name: 'zap-api-report'
        # Note: ZAP action outputs will be moved to dast-reports/ in collect step

    # Doc: https://github.com/projectdiscovery/nuclei-action
    # NOTE: Nuclei runs via composite action inside the GitHub Actions runner/act container,
    # so it can access 127.0.0.1:8080 directly without Docker networking complications.
    - name: Set Nuclei scan configuration based on profile
      id: nuclei_config
      run: |
        case "$SCAN_PROFILE" in
          "quick")
            echo "timeout=60" >> $GITHUB_OUTPUT
            echo "concurrency=12" >> $GITHUB_OUTPUT
            echo "rate_limit=100" >> $GITHUB_OUTPUT
            echo "templates=cves/2023/,cves/2024/,vulnerabilities/,security-misconfiguration/generic/" >> $GITHUB_OUTPUT
            echo "description=Quick scan (PRs): ~2-3 minutes, recent CVEs and basic misconfigurations" >> $GITHUB_OUTPUT
            ;;
          "deep")
            echo "timeout=1200" >> $GITHUB_OUTPUT
            echo "concurrency=32" >> $GITHUB_OUTPUT
            echo "rate_limit=300" >> $GITHUB_OUTPUT
            echo "templates=" >> $GITHUB_OUTPUT
            echo "description=Deep scan (scheduled): ~15-20 minutes, all templates" >> $GITHUB_OUTPUT
            ;;
          *) # full (default)
            echo "timeout=600" >> $GITHUB_OUTPUT
            echo "concurrency=24" >> $GITHUB_OUTPUT
            echo "rate_limit=200" >> $GITHUB_OUTPUT
            echo "templates=cves/,vulnerabilities/,security-misconfiguration/,default-logins/,exposed-panels/" >> $GITHUB_OUTPUT
            echo "description=Full scan (main push): ~8-10 minutes, comprehensive coverage" >> $GITHUB_OUTPUT
            ;;
        esac
        echo "Profile: $SCAN_PROFILE"
        echo "Configuration set for profile: $SCAN_PROFILE"

    - name: Nuclei - Vulnerability Scan (${{ steps.nuclei_config.outputs.description }})
      if: ${{ steps.diagnostic_connectivity.outputs.NUCLEI_REACHABLE == 'true' }}
      id: nuclei_scan
      uses: projectdiscovery/nuclei-action@main
      with:
        target: ${{ env.NUCLEI_PUBLIC_TARGET_URL }}
        user-agent: "User-Agent:'Nuclei - Vulnerability Scan (Have a nice day)'"
        # Exclude tcp/javascript protocol templates to avoid scanning infrastructure services (SSH:22, PostgreSQL:5432, RPC:111)
        # See: https://github.com/orgs/projectdiscovery/discussions/5159
        flags: "-c ${{ steps.nuclei_config.outputs.concurrency }} -rl ${{ steps.nuclei_config.outputs.rate_limit }} -timeout ${{ steps.nuclei_config.outputs.timeout }} -stats -ept tcp,javascript${{ steps.nuclei_config.outputs.templates && format(' -t {0}', steps.nuclei_config.outputs.templates) || '' }}"

    - name: Set dummy token for local act runs
      if: ${{ github.actor == 'nektos/act' }}
      run: |
        if [ -n "${GITHUB_TOKEN}" ]; then
          echo "GITHUB_TOKEN already set; leaving existing token in place";
        else
          echo "Setting dummy GITHUB_TOKEN for act local run to avoid upload-sarif failure";
          echo "GITHUB_TOKEN=act-dummy-token" >> $GITHUB_ENV;
        fi

    - name: Collect scan artifacts
      if: always()
      run: |
        # Move artifacts to dast-reports (suppressed verbose logging)
        [ -f "nuclei.log" ] && mv nuclei.log ./dast-reports/ || true
        [ -f "nuclei.sarif" ] && mv nuclei.sarif ./dast-reports/ || true

        # Move ZAP artifacts if present
        for artifact in zap-report.{html,json,xml} zap-api-report.{html,json}; do
          [ -f "$artifact" ] && mv "$artifact" ./dast-reports/ || true
        done

        # For GitHub runs, copy SARIF back to root for upload-sarif action
        if [ "${{ github.actor }}" != "nektos/act" ] && [ -f "./dast-reports/nuclei.sarif" ]; then
          cp ./dast-reports/nuclei.sarif nuclei.sarif
        fi

        echo "Artifact collection complete"

    - name: GitHub Workflow artifacts
      if: ${{ github.actor != 'nektos/act' }}
      uses: actions/upload-artifact@v4
      with:
        name: dast-reports
        path: |
          dast-reports/nuclei.log
          dast-reports/nuclei.sarif
          dast-reports/response-headers.txt

    - name: GitHub Security Dashboard Alerts update
      uses: github/codeql-action/upload-sarif@v3
      # Skip entirely when running under act; also ensure SARIF file actually exists
      if: ${{ github.actor != 'nektos/act' && hashFiles('nuclei.sarif') != '' }}
      with:
        sarif_file: nuclei.sarif
      env:
        # Use real token in GitHub hosted runner
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Generate Security Summary
      if: always()
      run: |
        {
          echo "# DAST Security Scan Results"
          echo ""
          echo "**Profile:** ${{ env.SCAN_PROFILE }} (${{ steps.nuclei_config.outputs.description }})"
          echo "**Nuclei Target:** ${{ env.NUCLEI_PUBLIC_TARGET_URL }} | **ZAP Target:** ${{ env.ZAP_PUBLIC_TARGET_URL }}"
          echo "**Date:** $(date -u)"
          echo ""
          echo "## Scan Coverage"
          [ -f "dast-reports/nuclei.log" ] && echo "- âœ… **Nuclei Scan**" || echo "- â­ **Nuclei Scan:** Skipped"
          ls zap-*-report.html >/dev/null 2>&1 && echo "- âœ… **OWASP ZAP Scans**" || echo "- â­ **OWASP ZAP Scans:** Disabled"
          echo ""
          echo "## Generated Reports"
          [ -f dast-reports/nuclei.log ] && echo "- Nuclei Log/SARIF" || true
          [ -f dast-reports/response-headers.txt ] && echo "- Security Headers" || true
          ls zap-*-report.html >/dev/null 2>&1 && echo "- ZAP Reports" || true
        } >> $GITHUB_STEP_SUMMARY

    - name: Cleanup
      if: always()
      run: |
        # Stop application
        [ -n "${APP_PID:-}" ] && { kill "$APP_PID" 2>/dev/null || true; sleep 1; kill -9 "$APP_PID" 2>/dev/null || true; }
