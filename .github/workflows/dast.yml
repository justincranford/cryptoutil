name: DAST Security Testing
# IMPORTANT: Test locally with `act --bind -j dast-security-scan > ./dast-reports/act-dast.log 2>&1`
# OUTPUT CONVENTION: All scan outputs and reports must be written to ./dast-reports/ directory

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.github/copilot-instructions.md'
      - '.github/instructions/**'
      - 'dast-reports/**'
      - 'nohup.out'
      - 'LICENSE'
      - '.editorconfig'
      - '.gitignore'
      - '.gitattributes'
      - '.golangci.yml'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/pull_request_template.md'
      - '.github/dependabot.yml'
      - 'scripts/**'
      - '**/*.log'
      - '**/*.sarif'
  pull_request:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.github/copilot-instructions.md'
      - '.github/instructions/**'
      - 'dast-reports/**'
      - 'nohup.out'
      - 'LICENSE'
      - '.editorconfig'
      - '.gitignore'
      - '.gitattributes'
      - '.golangci.yml'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/pull_request_template.md'
      - '.github/dependabot.yml'
      - 'scripts/**'
      - '**/*.log'
      - '**/*.sarif'
  schedule:
    # Run DAST weekly on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      target_url:
        description: 'Target URL for DAST scanning (default: https://localhost:8080)'
        required: false
        default: 'https://localhost:8080'

env:
  GO_VERSION: '1.25.1'

  TARGET_URL: ${{ github.event.inputs.target_url || 'https://localhost:8080' }}

  APP_BIND_PUBLIC_PROTOCOL: https
  APP_BIND_PUBLIC_ADDRESS: 0.0.0.0
  APP_BIND_PUBLIC_PORT: 8080

  APP_BIND_PRIVATE_PROTOCOL: http
  APP_BIND_PRIVATE_ADDRESS: 127.0.0.1
  APP_BIND_PRIVATE_PORT: 9090

  DB_HOST: localhost
  DB_PORT: 5432
  DB_NAME: DB
  DB_USER: USR
  DB_PASSWORD: PWD

jobs:
  dast-security-scan:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_DB: ${{ env.DB_NAME }}
          POSTGRES_PASSWORD: ${{ env.DB_PASSWORD }}
          POSTGRES_USER: ${{ env.DB_USER }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432 # env context is not available in the services.ports section

    permissions:
      contents: read
      security-events: write
      actions: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create DAST reports directory
      if: always()
      run: mkdir -p ./dast-reports

    - name: Establish Nuclei Templates Version
      id: nuclei-version
      run: |
        # Define or update the desired nuclei templates reference version/tag
        # For reproducibility, you can pin to a specific release tag (e.g., v9.9.9) later.
        echo "LATEST" > nuclei-templates.version
        echo "templates_version=$(cat nuclei-templates.version)" >> $GITHUB_OUTPUT
        echo "Using nuclei templates version: $(cat nuclei-templates.version)"

    - name: Cache Nuclei Templates
      id: cache-nuclei-templates
      uses: actions/cache@v4
      with:
        path: ~/.nuclei-templates
        key: nuclei-templates-${{ runner.os }}-${{ steps.nuclei-version.outputs.templates_version }}
        restore-keys: |
          nuclei-templates-${{ runner.os }}-

    - name: Nuclei Template Cache Diagnostics
      run: |
        echo "Cache hit: ${{ steps.cache-nuclei-templates.outputs.cache-hit }}"
        if [ -d "$HOME/.nuclei-templates" ]; then
          echo "Template directory exists";
          find "$HOME/.nuclei-templates" -maxdepth 2 -type f 2>/dev/null | head -n 5 || true
        else
          echo "Template directory missing (will be populated by nuclei if needed)";
        fi

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true

    - name: Install dependencies
      run: go mod download

    - name: Build application
      run: go build -o cryptoutil ./cmd/cryptoutil

    # See internal\common\config\config.go for configuration options
    - name: Start application for DAST testing
      run: |
        # Create test configuration
        mkdir -p configs/test

        # Create unseal secret file
        cat > ./configs/test/dast-simple-unseal-secret-value-1.secret <<EOF
        dast-simple-unseal-secret-value-1
        EOF

        # Create config file
        cat > ./configs/test/config.yml <<EOF
        bind-public-protocol: "${APP_BIND_PUBLIC_PROTOCOL}"
        bind-public-address: "${APP_BIND_PUBLIC_ADDRESS}"
        bind-public-port: ${APP_BIND_PUBLIC_PORT}
        bind-private-protocol: "${APP_BIND_PRIVATE_PROTOCOL}"
        bind-private-address: "${APP_BIND_PRIVATE_ADDRESS}"
        bind-private-port: ${APP_BIND_PRIVATE_PORT}
        database-url: "postgres://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}?sslmode=disable"
        unseal-mode: "1-of-1"
        unseal-files:
          - ./configs/test/dast-simple-unseal-secret-value-1.secret
        EOF

        # Start application in background, capture PID for cleanup; use nohup to avoid termination on shell exit
        nohup ./cryptoutil server start --config configs/test/config.yml &
        APP_PID=$!
        echo "APP_PID=$APP_PID" >> $GITHUB_ENV

        # Wait for application to be ready
        timeout 20 bash -c '
          until curl -k -f ${APP_BIND_PUBLIC_PROTOCOL}://${APP_BIND_PUBLIC_ADDRESS}:${APP_BIND_PUBLIC_PORT}/ui/swagger/doc.json; do
            sleep 1
          done
        '

        curl -f -k https://localhost:8080/ui/swagger/doc.json > /dev/null 2>&1
        echo "Application listening on https://localhost:8080"

    - name: Test application curl connectivity
      run: |
        curl -f -k https://localhost:8080/ui/swagger/doc.json > /dev/null 2>&1
        echo "Application listening on https://localhost:8080"

    # # Options doc: https://www.zaproxy.org/docs/docker/full-scan/
  # - name: Run OWASP ZAP DAST Scan
  #   uses: zaproxy/action-full-scan@v0.12.0
  #   with:
  #     target: ${{ env.TARGET_URL }}
  #     rules_file_name: '.zap/rules.tsv'
  #     # Cookie ignore list trimmed: only _csrf is used by cryptoutil.
  #     # JSESSIONID / csrftoken are from other stacks; keeping them caused confusion.
  #     cmd_options: '-a -j -m 10 -T 60 -z "-config rules.cookie.ignorelist=_csrf"'
  #     allow_issue_writing: false
  #     artifact_name: 'zap-report'
  #     # Note: ZAP action outputs will be moved to dast-reports/ when re-enabled

    # - name: Run OWASP ZAP API Scan
    #   uses: zaproxy/action-api-scan@v0.9.0
    #   with:
    #     target: '${{ env.TARGET_URL }}/ui/swagger/doc.json'
    #     format: openapi
    #     cmd_options: '-a -j -T 60'
    #     allow_issue_writing: false
    #     artifact_name: 'zap-api-report'
    #     # Note: ZAP action outputs will be moved to dast-reports/ when re-enabled

    # Doc: https://github.com/projectdiscovery/nuclei-action
    - name: Nuclei - Vulnerability Scan
      id: nuclei_scan
      uses: projectdiscovery/nuclei-action@main
      with:
        target: ${{ env.TARGET_URL }}
        user-agent: "User-Agent:'Nuclei - Vulnerability Scan (Have a nice day)'"
        # Exclude tcp/javascript protocol templates to avoid scanning infrastructure services (SSH:22, PostgreSQL:5432, RPC:111)
        # See: https://github.com/orgs/projectdiscovery/discussions/5159
        # IMPORTANT: -timeout 5 is too short for comprehensive scans (~10 minutes needed). Consider increasing to 600 for full testing.
        # Current setting optimized for quick PR checks. For thorough scans, use: -timeout 600
        flags: "-c 24 -rl 200 -timeout 600 -stats -ept tcp,javascript"

    - name: Capture baseline response headers
      if: always()
      run: |
        set -e
        echo "# Header Baseline ($(date -u))" > dast-reports/response-headers.txt
        echo "## Swagger UI" >> dast-reports/response-headers.txt
        curl -skI https://localhost:8080/ui/swagger/ >> dast-reports/response-headers.txt || echo "(failed)" >> dast-reports/response-headers.txt
        echo "\n## Browser API root (/browser/api/v1)" >> dast-reports/response-headers.txt
        curl -skI https://localhost:8080/browser/api/v1/ >> dast-reports/response-headers.txt || echo "(failed)" >> dast-reports/response-headers.txt
        echo "\n## Service API root (/service/api/v1)" >> dast-reports/response-headers.txt
        curl -skI https://localhost:8080/service/api/v1/ >> dast-reports/response-headers.txt || echo "(failed)" >> dast-reports/response-headers.txt
        echo "Saved dast-reports/response-headers.txt"

    - name: Debug - Show environment and output variables
      run: |
        echo "GitHub actor: ${{ github.actor }}"
        echo "ACT environment var (raw): ${ACT:-unset}"
        echo "SARIF exists: ${{ steps.nuclei_scan.outputs.sarif_exists }}"
        echo "Event name: ${{ github.event_name }}"
        echo "Runner OS: ${{ runner.os }}"

    - name: Set dummy token for local act runs
      if: ${{ github.actor == 'nektos/act' }}
      run: |
        if [ -n "${GITHUB_TOKEN}" ]; then
          echo "GITHUB_TOKEN already set; leaving existing token in place";
        else
          echo "Setting dummy GITHUB_TOKEN for act local run to avoid upload-sarif failure";
          echo "GITHUB_TOKEN=act-dummy-token" >> $GITHUB_ENV;
        fi

    - name: Save artifacts locally (act only)
      if: ${{ github.actor == 'nektos/act' }}
      run: |
        mv nuclei.log ./dast-reports/ || true
        mv nuclei.sarif ./dast-reports/ || true
        echo "Nuclei artifacts moved to ./dast-reports/"

    - name: GitHub Workflow artifacts
      if: ${{ github.actor != 'nektos/act' }}
      uses: actions/upload-artifact@v4
      with:
        name: dast-reports
        path: |
          dast-reports/nuclei.log
          dast-reports/nuclei.sarif
          dast-reports/response-headers.txt

    - name: GitHub Security Dashboard Alerts update
      uses: github/codeql-action/upload-sarif@v3
      # Skip entirely when running under act; also ensure SARIF file actually exists
      if: ${{ github.actor != 'nektos/act' && hashFiles('nuclei.sarif') != '' }}
      with:
        sarif_file: nuclei.sarif
      env:
        # Use real token in GitHub hosted runner
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Generate Security Summary
      if: always()
      run: |
        summaryFile="$GITHUB_STEP_SUMMARY"
        echo "# DAST Security Scan Results" >> $summaryFile
        echo "" >> $summaryFile
        echo "## Scan Configuration" >> $summaryFile
        echo "- **Target URL:** ${{ env.TARGET_URL }}" >> $summaryFile
        echo "- **Scan Date:** $(date -u)" >> $summaryFile
        echo "- **OpenAPI Spec:** Available at /ui/swagger/doc.json" >> $summaryFile
        echo "" >> $summaryFile
        echo "## Scan Coverage" >> $summaryFile
        # Detect executed scanners (ZAP disabled for now)
        if [ -f "dast-reports/nuclei.log" ]; then
          echo "- ✅ **Nuclei Scan:** Template-based vulnerability scanning" >> $summaryFile
        else
          echo "- ⏭ **Nuclei Scan:** Skipped (log missing)" >> $summaryFile
        fi
        if ls zap-*-report.html >/dev/null 2>&1; then
          echo "- ✅ **OWASP ZAP Full/API Scans:** Executed" >> $summaryFile
        else
          echo "- ⏭ **OWASP ZAP Scans:** Skipped (steps disabled)" >> $summaryFile
        fi
        echo "" >> $summaryFile
        echo "## Reports Generated" >> $summaryFile
        [ -f dast-reports/nuclei.log ] && echo "- Nuclei Log (dast-reports/nuclei.log)" >> $summaryFile || true
        [ -f dast-reports/nuclei.sarif ] && echo "- Nuclei SARIF (dast-reports/nuclei.sarif)" >> $summaryFile || true
        [ -f dast-reports/response-headers.txt ] && echo "- Header Baseline (dast-reports/response-headers.txt)" >> $summaryFile || true
        if ls zap-*-report.html >/dev/null 2>&1; then
          echo "- ZAP HTML Reports" >> $summaryFile
        fi
        echo "" >> $summaryFile
        echo "## Next Steps" >> $summaryFile
        echo "1. Review scan artifacts (focus on HIGH/CRITICAL)" >> $summaryFile
        echo "2. Validate header false negatives against header baseline" >> $summaryFile
        echo "3. Tune nuclei flags (timeouts, templates) if error count high" >> $summaryFile
        echo "4. Re-enable ZAP scans when configuration finalized" >> $summaryFile

    - name: Cleanup
      if: always()
      run: |
        if [ ! -z "$APP_PID" ]; then
          kill $APP_PID || true
          sleep 2
          kill -9 $APP_PID 2>/dev/null || true
        fi
