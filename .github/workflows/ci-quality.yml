# $schema: https://json.schemastore.org/github-workflow.json
# https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax

name: CI - Quality Testing
# CROSS-PLATFORM COMPATIBILITY: All file references in this workflow MUST use relative paths
# to support both GitHub Actions Ubuntu runners and Windows `act` local runner testing.
# Absolute paths (e.g., C:\...) break cross-platform compatibility.
# Example: Use './deployments/compose/compose.yml'

on:
  push:
    branches: [ main, develop ]
    # SHARED PATHS-IGNORE CONFIGURATION - Keep synchronized with pull_request below
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - '.github/copilot-instructions.md'
      - '.github/instructions/**'
      - 'workflow-reports/**'
      - 'nohup.out'
      - 'LICENSE'
      - '.editorconfig'
      - '.gitignore'
      - '.gitattributes'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/pull_request_template.md'
      - '.github/dependabot.yml'
      - '**/*.log'
      - '**/*.sarif'
  pull_request:
    branches: [ main, develop ]
    # SHARED PATHS-IGNORE CONFIGURATION - Keep synchronized with push above
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - '.github/copilot-instructions.md'
      - '.github/instructions/**'
      - 'workflow-reports/**'
      - 'nohup.out'
      - 'LICENSE'
      - '.editorconfig'
      - '.gitignore'
      - '.gitattributes'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/pull_request_template.md'
      - '.github/dependabot.yml'
      - '**/*.log'
      - '**/*.sarif'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Code Quality and Formatting
  code-quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v5.0.1
      with:
        sparse-checkout-cone-mode: false  # Disabled for cross-platform compatibility between GitHub Actions and act local runner

    - name: Begin Workflow Job
      id: begin-workflow-job
      uses: ./.github/actions/workflow-job-begin

    - name: Set up Go and validate dependencies
      uses: ./.github/actions/go-setup
      with:
        go-version: ${{ steps.begin-workflow-job.outputs.go-version }}
        go-mod-download: true
        go-mod-verify: true
        go-mod-tidy: true

    - name: Run golangci-lint
      uses: ./.github/actions/golangci-lint

    - name: Run custom cicd linting and validation
      uses: ./.github/actions/custom-cicd-lint

    - name: Code quality summary
      if: always()
      uses: ./.github/actions/workflow-job-end

  # Build and Container Security
  build:
    name: Build & Container Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5.0.1
        with:
          sparse-checkout-cone-mode: false  # Disabled for cross-platform compatibility between GitHub Actions and act local runner

      - name: Begin Workflow Job
        id: begin-workflow-job
        uses: ./.github/actions/workflow-job-begin

      - name: Set up Go and validate dependencies
        uses: ./.github/actions/go-setup
        with:
          go-version: ${{ steps.begin-workflow-job.outputs.go-version }}
          go-mod-download: true
          go-mod-verify: true
          go-mod-tidy: true

      - name: Build binary
        run: |
          echo "üî® Building application binary..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          # Build with static linking and minimal symbol stripping for CI/testing
          # -s: Strip symbol table for smaller binary size (keeps debug symbols for diagnostics)
          # -extldflags '-static': Force static linking for maximum portability
          # Performance and diagnostics prioritized over size; debug symbols retained for troubleshooting
          go build -v -ldflags="-s -extldflags '-static'" -o cryptoutil ./cmd/cryptoutil
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è Binary build completed in: ${DURATION}s"

      - name: Test binary
        run: |
          echo "üß™ Testing binary execution..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          # Test that the binary was built successfully
          ls -la ./cryptoutil
          file ./cryptoutil
          # Test basic execution (expect it to show usage and exit with error since no valid command given)
          ./cryptoutil || echo "Binary executed successfully (expected error due to no command)"
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è Binary test completed in: ${DURATION}s"

      - name: Set up Docker Buildx
        run: |
          echo "üê≥ Setting up Docker Buildx..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          docker buildx create --use
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è Docker Buildx setup completed in: ${DURATION}s"

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=sha-

      - name: Build Docker image
        run: |
          echo "üèóÔ∏è Building Docker image..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"

          # Build the tag arguments using process substitution to avoid subshell variable scoping issues
          TAG_ARGS=""
          while IFS= read -r tag; do
            if [ -n "$tag" ]; then
              TAG_ARGS="$TAG_ARGS --tag $tag"
            fi
          done <<< "${{ steps.meta.outputs.tags }}"

          docker buildx build \
            --load \
            $TAG_ARGS \
            --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --label "org.opencontainers.image.revision=${{ github.sha }}" \
            --label "org.opencontainers.image.version=${{ github.sha }}" \
            --build-arg APP_VERSION=${{ github.sha }} \
            --build-arg VCS_REF=${{ github.sha }} \
            --build-arg BUILD_DATE=1970-01-01T00:00:00Z \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            -f ./deployments/Dockerfile \
            .
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è Docker image build completed in: ${DURATION}s"

      - name: Get first Docker tag for Trivy scan
        id: first-tag
        run: echo "tag=$(echo '${{ steps.meta.outputs.tags }}' | head -n1)" >> $GITHUB_OUTPUT

      - name: Scan Docker image for vulnerabilities
        uses: ./.github/actions/security-scan-trivy2
        with:
          scan-name: 'docker-image'
          scan-type: 'image'
          scan-ref: ${{ steps.first-tag.outputs.tag }}
          trivy-sarif-output: 'trivy-image.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW,UNKNOWN'

      # Docker Scout vulnerability scanning
      - name: Check Docker Scout authentication
        id: scout-auth
        run: |
          echo "üîç Checking Docker Scout authentication..."
          if docker scout version >/dev/null 2>&1; then
            echo "authenticated=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Docker Scout is authenticated and available"
          else
            echo "authenticated=false" >> $GITHUB_OUTPUT
            echo "‚ùå Docker Scout authentication failed - skipping Docker Scout scans"
          fi
        continue-on-error: true

      - name: Enable Docker Scout
        uses: docker/scout-action@v1
        with:
          command: version
        if: steps.scout-auth.outputs.authenticated == 'true'

      - name: Docker Scout - Quick Overview
        uses: docker/scout-action@v1
        with:
          command: quickview
          image: ${{ steps.first-tag.outputs.tag }}
          only-severities: critical,high,medium
          write-comment: false
        if: steps.scout-auth.outputs.authenticated == 'true'

      - name: Docker Scout - CVE Analysis
        uses: docker/scout-action@v1
        with:
          command: cves
          image: ${{ steps.first-tag.outputs.tag }}
          format: sarif
          output: docker-scout-cves.sarif
          only-severities: critical,high,medium
        continue-on-error: true
        if: steps.scout-auth.outputs.authenticated == 'true'

      - name: Upload Docker Scout CVE results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'docker-scout-cves.sarif'
        if: steps.scout-auth.outputs.authenticated == 'true' && hashFiles('docker-scout-cves.sarif') != ''

      - name: Docker Scout - Security Recommendations
        uses: docker/scout-action@v1
        with:
          command: recommendations
          image: ${{ steps.first-tag.outputs.tag }}
          only-severities: critical,high,medium
        continue-on-error: true
        if: steps.scout-auth.outputs.authenticated == 'true'

      - name: Push Docker image
        if: github.event_name != 'pull_request'
        run: |
          echo "üì§ Pushing Docker image..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"

          # Build the tag arguments using process substitution to avoid subshell variable scoping issues
          TAG_ARGS=""
          while IFS= read -r tag; do
            if [ -n "$tag" ]; then
              TAG_ARGS="$TAG_ARGS --tag $tag"
            fi
          done <<< "${{ steps.meta.outputs.tags }}"

          docker buildx build \
            --push \
            $TAG_ARGS \
            --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --label "org.opencontainers.image.revision=${{ github.sha }}" \
            --label "org.opencontainers.image.version=${{ github.sha }}" \
            --build-arg APP_VERSION=${{ github.sha }} \
            --build-arg VCS_REF=${{ github.sha }} \
            --build-arg BUILD_DATE=1970-01-01T00:00:00Z \
            -f ./deployments/Dockerfile \
            .
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è Docker image push completed in: ${DURATION}s"

      - name: Build summary
        if: always()
        uses: ./.github/actions/workflow-job-end

  # SBOM Generation
  sbom:
    name: Generate SBOM
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5.0.1
        with:
          sparse-checkout-cone-mode: false  # Disabled for cross-platform compatibility between GitHub Actions and act local runner

      - name: Begin Workflow Job
        id: begin-workflow-job
        uses: ./.github/actions/workflow-job-begin

      - name: Set up Go and validate dependencies
        uses: ./.github/actions/go-setup
        with:
          go-version: ${{ steps.begin-workflow-job.outputs.go-version }}
          go-mod-download: true
          go-mod-verify: true
          go-mod-tidy: true

      - name: Install syft
        run: |
          echo "üì¶ Installing syft for SBOM generation..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"

          # Download and install syft
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è Syft installation completed in: ${DURATION}s"

      - name: Generate SBOM with syft
        run: |
          echo "üì¶ Generating SBOM with syft..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          syft packages . --output spdx-json=sbom.spdx.json
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è SBOM generation completed in: ${DURATION}s"

      - name: Upload SBOM
        uses: actions/upload-artifact@v5.0.0
        with:
          name: sbom
          path: sbom.spdx.json
          retention-days: 1

      - name: Upload SBOM to dependency graph
        uses: anchore/sbom-action@v0
        with:
          path: ./
          format: spdx-json
          output-file: sbom.spdx.json
          upload-artifact: false
          upload-release-assets: false
          dependency-snapshot: true

      - name: SBOM summary
        if: always()
        uses: ./.github/actions/workflow-job-end

  # Mutation Testing - Quality Assessment
  mutation-testing:
    name: Mutation Testing
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'  # Only on main branch
    steps:
      - name: Checkout code
        uses: actions/checkout@v5.0.1
        with:
          sparse-checkout-cone-mode: false  # Disabled for cross-platform compatibility between GitHub Actions and act local runner

      - name: Begin Workflow Job
        id: begin-workflow-job
        uses: ./.github/actions/workflow-job-begin

      - name: Set up Go and validate dependencies
        uses: ./.github/actions/go-setup
        with:
          go-version: ${{ steps.begin-workflow-job.outputs.go-version }}
          go-mod-download: true
          go-mod-verify: true
          go-mod-tidy: true

      - name: Install Gremlins
        run: |
          echo "üß¨ Installing Gremlins mutation testing tool..."
          START_TIME=$(date +%s)
          echo "üìÖ Start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          go install github.com/go-gremlins/gremlins/cmd/gremlins@latest
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "üìÖ End: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "‚è±Ô∏è Gremlins installation completed in: ${DURATION}s"

      - name: Run mutation testing on high-coverage packages
        run: |
          echo "üß™ Running mutation testing on packages with high test coverage..."
          OVERALL_START=$(date +%s)
          echo "üìÖ Mutation testing start: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"

          # Test packages with excellent coverage
          HIGH_COVERAGE_PACKAGES=(
            "./internal/common/util/datetime/"
            "./internal/common/util/thread/"
            "./internal/common/util/sysinfo/"
          )

          TOTAL_KILLED=0
          TOTAL_LIVED=0
          TOTAL_NOT_COVERED=0
          MUTATION_REPORTS=""

          for package in "${HIGH_COVERAGE_PACKAGES[@]}"; do
            echo "üéØ Testing package: $package"
            START_TIME=$(date +%s)

            # Run mutation testing with reasonable settings
            OUTPUT=$(gremlins unleash "$package" \
              --workers 2 \
              --timeout-coefficient 3 \
              --threshold-efficacy 70.0 \
              --threshold-mcover 60.0 \
              --output "mutation-$(basename "$package").json" 2>&1) || true

            END_TIME=$(date +%s)
            DURATION=$((END_TIME - START_TIME))
            echo "‚è±Ô∏è Package $package completed in: ${DURATION}s"

            echo "$OUTPUT"
            MUTATION_REPORTS="$MUTATION_REPORTS mutation-$(basename "$package").json"

            # Extract metrics from output
            KILLED=$(echo "$OUTPUT" | grep -o "Killed: [0-9]*" | grep -o "[0-9]*" || echo "0")
            LIVED=$(echo "$OUTPUT" | grep -o "Lived: [0-9]*" | grep -o "[0-9]*" || echo "0")
            NOT_COVERED=$(echo "$OUTPUT" | grep -o "Not covered: [0-9]*" | grep -o "[0-9]*" || echo "0")

            TOTAL_KILLED=$((TOTAL_KILLED + KILLED))
            TOTAL_LIVED=$((TOTAL_LIVED + LIVED))
            TOTAL_NOT_COVERED=$((TOTAL_NOT_COVERED + NOT_COVERED))

            echo "Package results - Killed: $KILLED, Lived: $LIVED, Not covered: $NOT_COVERED"
            echo ""
          done

          OVERALL_END=$(date +%s)
          TOTAL_DURATION=$((OVERALL_END - OVERALL_START))

          # Calculate overall metrics
          TOTAL_TESTED=$((TOTAL_KILLED + TOTAL_LIVED))
          if [ $TOTAL_TESTED -gt 0 ]; then
            EFFICACY=$(( (TOTAL_KILLED * 100) / TOTAL_TESTED ))
          else
            EFFICACY=0
          fi

          echo "üìä MUTATION TESTING SUMMARY"
          echo "========================="
          echo "Total Killed: $TOTAL_KILLED"
          echo "Total Lived: $TOTAL_LIVED"
          echo "Total Not Covered: $TOTAL_NOT_COVERED"
          echo "Test Efficacy: ${EFFICACY}%"
          echo "Total Duration: ${TOTAL_DURATION}s"

          # Set up summary for GitHub
          echo "## üß¨ Mutation Testing Results" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| üéØ Killed | $TOTAL_KILLED |" >> $GITHUB_STEP_SUMMARY
          echo "| üßü Lived | $TOTAL_LIVED |" >> $GITHUB_STEP_SUMMARY
          echo "| üö´ Not Covered | $TOTAL_NOT_COVERED |" >> $GITHUB_STEP_SUMMARY
          echo "| üìà Test Efficacy | ${EFFICACY}% |" >> $GITHUB_STEP_SUMMARY
          echo "| ‚è±Ô∏è Total Duration | ${TOTAL_DURATION}s |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ $TOTAL_LIVED -gt 0 ]; then
            echo "‚ö†Ô∏è **Warning**: $TOTAL_LIVED mutations survived testing" >> $GITHUB_STEP_SUMMARY
            echo "This indicates potential gaps in test coverage or assertion quality." >> $GITHUB_STEP_SUMMARY
          else
            echo "‚úÖ **Excellent**: All testable mutations were killed by the test suite!" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload mutation testing reports
        uses: actions/upload-artifact@v5.0.0
        if: always()
        with:
          name: mutation-testing-reports
          path: mutation-*.json
          retention-days: 1

      - name: Mutation testing summary
        if: always()
        uses: ./.github/actions/workflow-job-end
