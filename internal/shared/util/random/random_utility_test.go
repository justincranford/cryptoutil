// Copyright (c) 2025 Justin Cranford

package random

import (
	cryptoutilSharedMagic "cryptoutil/internal/shared/magic"
	"testing"

	testify "github.com/stretchr/testify/require"
)

// TestGenerateString tests string generation with various lengths.
func TestGenerateString(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name   string
		length int
	}{
		{"Empty string", 0},
		{"Single char", 1},
		{"Short string", cryptoutilSharedMagic.IMMinPasswordLength},
		{"Medium string", cryptoutilSharedMagic.RealmMinBearerTokenLengthBytes},
		{"Long string", cryptoutilSharedMagic.TLSSelfSignedCertSerialNumberBits},
		{"Odd length", 15},
		{"Even length", cryptoutilSharedMagic.RealmMinTokenLengthBytes},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			result, err := GenerateString(tc.length)
			testify.NoError(t, err, "GenerateString should not return error")
			testify.Len(t, result, tc.length, "String length should match requested")

			// Verify all characters are valid hex (0-9,a-f)
			for _, c := range result {
				testify.True(t, (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f'), "All characters should be valid hex: %c", c)
			}
		})
	}
}

// TestGenerateString_Uniqueness verifies different calls produce different results.
func TestGenerateString_Uniqueness(t *testing.T) {
	t.Parallel()

	const (
		length     = 32
		iterations = 100
	)

	seen := make(map[string]bool, iterations)

	for i := 0; i < iterations; i++ {
		result, err := GenerateString(length)
		testify.NoError(t, err, "GenerateString should not return error")
		testify.NotContains(t, seen, result, "Generated strings should be unique")
		seen[result] = true
	}

	testify.Len(t, seen, iterations, "Should have generated unique strings")
}

// TestGenerateBytes tests byte generation with various lengths.
func TestGenerateBytes(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		lengthBytes int
	}{
		{"Empty bytes", 0},
		{"Single byte", 1},
		{"Short bytes", cryptoutilSharedMagic.IMMinPasswordLength},
		{"Medium bytes", cryptoutilSharedMagic.RealmMinBearerTokenLengthBytes},
		{"Long bytes", cryptoutilSharedMagic.TLSSelfSignedCertSerialNumberBits},
		{"Very long bytes", cryptoutilSharedMagic.DefaultLogsBatchSize},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			result, err := GenerateBytes(tc.lengthBytes)
			testify.NoError(t, err, "GenerateBytes should not return error")
			testify.Len(t, result, tc.lengthBytes, "Byte length should match requested")
		})
	}
}

// TestGenerateBytes_Uniqueness verifies different calls produce different results.
func TestGenerateBytes_Uniqueness(t *testing.T) {
	t.Parallel()

	const (
		lengthBytes = 32
		iterations  = 100
	)

	seen := make(map[string]bool, iterations)

	for i := 0; i < iterations; i++ {
		result, err := GenerateBytes(lengthBytes)
		testify.NoError(t, err, "GenerateBytes should not return error")

		key := string(result)
		testify.NotContains(t, seen, key, "Generated byte slices should be unique")
		seen[key] = true
	}

	testify.Len(t, seen, iterations, "Should have generated unique byte slices")
}

// TestConcatBytes tests byte slice concatenation.
func TestConcatBytes(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		input    [][]byte
		expected []byte
	}{
		{
			name:     "Empty list",
			input:    [][]byte{},
			expected: nil,
		},
		{
			name:     "Single slice",
			input:    [][]byte{[]byte("hello")},
			expected: []byte("hello"),
		},
		{
			name:     "Multiple slices",
			input:    [][]byte{[]byte("hello"), []byte(" "), []byte("world")},
			expected: []byte("hello world"),
		},
		{
			name:     "Empty slices",
			input:    [][]byte{[]byte(""), []byte(""), []byte("")},
			expected: nil,
		},
		{
			name:     "Mixed empty and non-empty",
			input:    [][]byte{[]byte("a"), []byte(""), []byte("b")},
			expected: []byte("ab"),
		},
		{
			name:     "Binary data",
			input:    [][]byte{{0x00, 0x01}, {0xFF, 0xFE}},
			expected: []byte{0x00, 0x01, 0xFF, 0xFE},
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			result := ConcatBytes(tc.input)
			testify.Equal(t, tc.expected, result, "Concatenated bytes should match expected")
		})
	}
}

// TestStringsToBytes tests string to byte slice conversion.
func TestStringsToBytes(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		input    []string
		expected [][]byte
	}{
		{
			name:     "Empty input",
			input:    []string{},
			expected: [][]byte{},
		},
		{
			name:     "Single string",
			input:    []string{"hello"},
			expected: [][]byte{[]byte("hello")},
		},
		{
			name:     "Multiple strings",
			input:    []string{"hello", "world", "test"},
			expected: [][]byte{[]byte("hello"), []byte("world"), []byte("test")},
		},
		{
			name:     "Empty strings",
			input:    []string{"", "", ""},
			expected: [][]byte{[]byte(""), []byte(""), []byte("")},
		},
		{
			name:     "Mixed content",
			input:    []string{"abc", "", "123"},
			expected: [][]byte{[]byte("abc"), []byte(""), []byte("123")},
		},
		{
			name:     "Unicode strings",
			input:    []string{"hello", "ä¸–ç•Œ", "ðŸŒ"},
			expected: [][]byte{[]byte("hello"), []byte("ä¸–ç•Œ"), []byte("ðŸŒ")},
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			result := StringsToBytes(tc.input...)
			testify.Equal(t, tc.expected, result, "Converted bytes should match expected")
		})
	}
}

// TestGenerateUUIDv7_ErrorPath tests error handling for UUIDv7 generation.
func TestGenerateUUIDv7_HappyPath(t *testing.T) {
	t.Parallel()

	uuid, err := GenerateUUIDv7()
	testify.NoError(t, err, "GenerateUUIDv7 should not return error")
	testify.NotNil(t, uuid, "Generated UUID should not be nil")
	testify.Equal(t, cryptoutilSharedMagic.GitRecentActivityDays, int(uuid.Version()), "UUID version should be 7")
}

// TestGenerateUUIDv7_Uniqueness verifies different calls produce different UUIDs.
func TestGenerateUUIDv7_Uniqueness(t *testing.T) {
	t.Parallel()

	const iterations = 100

	seen := make(map[string]bool, iterations)

	for i := 0; i < iterations; i++ {
		uuid, err := GenerateUUIDv7()
		testify.NoError(t, err, "GenerateUUIDv7 should not return error")

		key := uuid.String()
		testify.NotContains(t, seen, key, "Generated UUIDs should be unique")
		seen[key] = true
	}

	testify.Len(t, seen, iterations, "Should have generated unique UUIDs")
}
