// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package client

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	externalRef0 "cryptoutil/internal/openapi/model"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// GetKekpoolParams defines parameters for GetKekpool.
type GetKekpoolParams struct {
	Filter *externalRef0.QueryParamFilter `form:"filter,omitempty" json:"filter,omitempty"`
	Sort   *externalRef0.QueryParamSort   `form:"sort,omitempty" json:"sort,omitempty"`
	Page   *externalRef0.QueryParamPage   `form:"page,omitempty" json:"page,omitempty"`
}

// GetKekpoolKekPoolIDKekParams defines parameters for GetKekpoolKekPoolIDKek.
type GetKekpoolKekPoolIDKekParams struct {
	Filter *externalRef0.QueryParamFilter `form:"filter,omitempty" json:"filter,omitempty"`
	Sort   *externalRef0.QueryParamSort   `form:"sort,omitempty" json:"sort,omitempty"`
	Page   *externalRef0.QueryParamPage   `form:"page,omitempty" json:"page,omitempty"`
}

// PostKekpoolJSONRequestBody defines body for PostKekpool for application/json ContentType.
type PostKekpoolJSONRequestBody = externalRef0.KEKPoolCreate

// PostKekpoolKekPoolIDKekJSONRequestBody defines body for PostKekpoolKekPoolIDKek for application/json ContentType.
type PostKekpoolKekPoolIDKekJSONRequestBody = externalRef0.KEKGenerate

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetKekpool request
	GetKekpool(ctx context.Context, params *GetKekpoolParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostKekpoolWithBody request with any body
	PostKekpoolWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostKekpool(ctx context.Context, body PostKekpoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKekpoolKekPoolIDKek request
	GetKekpoolKekPoolIDKek(ctx context.Context, kekPoolID string, params *GetKekpoolKekPoolIDKekParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostKekpoolKekPoolIDKekWithBody request with any body
	PostKekpoolKekPoolIDKekWithBody(ctx context.Context, kekPoolID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostKekpoolKekPoolIDKek(ctx context.Context, kekPoolID string, body PostKekpoolKekPoolIDKekJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetKekpool(ctx context.Context, params *GetKekpoolParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKekpoolRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostKekpoolWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostKekpoolRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostKekpool(ctx context.Context, body PostKekpoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostKekpoolRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKekpoolKekPoolIDKek(ctx context.Context, kekPoolID string, params *GetKekpoolKekPoolIDKekParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKekpoolKekPoolIDKekRequest(c.Server, kekPoolID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostKekpoolKekPoolIDKekWithBody(ctx context.Context, kekPoolID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostKekpoolKekPoolIDKekRequestWithBody(c.Server, kekPoolID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostKekpoolKekPoolIDKek(ctx context.Context, kekPoolID string, body PostKekpoolKekPoolIDKekJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostKekpoolKekPoolIDKekRequest(c.Server, kekPoolID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetKekpoolRequest generates requests for GetKekpool
func NewGetKekpoolRequest(server string, params *GetKekpoolParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kekpool")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostKekpoolRequest calls the generic PostKekpool builder with application/json body
func NewPostKekpoolRequest(server string, body PostKekpoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostKekpoolRequestWithBody(server, "application/json", bodyReader)
}

// NewPostKekpoolRequestWithBody generates requests for PostKekpool with any type of body
func NewPostKekpoolRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kekpool")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKekpoolKekPoolIDKekRequest generates requests for GetKekpoolKekPoolIDKek
func NewGetKekpoolKekPoolIDKekRequest(server string, kekPoolID string, params *GetKekpoolKekPoolIDKekParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "kekPoolID", runtime.ParamLocationPath, kekPoolID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kekpool/%s/kek", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostKekpoolKekPoolIDKekRequest calls the generic PostKekpoolKekPoolIDKek builder with application/json body
func NewPostKekpoolKekPoolIDKekRequest(server string, kekPoolID string, body PostKekpoolKekPoolIDKekJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostKekpoolKekPoolIDKekRequestWithBody(server, kekPoolID, "application/json", bodyReader)
}

// NewPostKekpoolKekPoolIDKekRequestWithBody generates requests for PostKekpoolKekPoolIDKek with any type of body
func NewPostKekpoolKekPoolIDKekRequestWithBody(server string, kekPoolID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "kekPoolID", runtime.ParamLocationPath, kekPoolID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kekpool/%s/kek", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetKekpoolWithResponse request
	GetKekpoolWithResponse(ctx context.Context, params *GetKekpoolParams, reqEditors ...RequestEditorFn) (*GetKekpoolResponse, error)

	// PostKekpoolWithBodyWithResponse request with any body
	PostKekpoolWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostKekpoolResponse, error)

	PostKekpoolWithResponse(ctx context.Context, body PostKekpoolJSONRequestBody, reqEditors ...RequestEditorFn) (*PostKekpoolResponse, error)

	// GetKekpoolKekPoolIDKekWithResponse request
	GetKekpoolKekPoolIDKekWithResponse(ctx context.Context, kekPoolID string, params *GetKekpoolKekPoolIDKekParams, reqEditors ...RequestEditorFn) (*GetKekpoolKekPoolIDKekResponse, error)

	// PostKekpoolKekPoolIDKekWithBodyWithResponse request with any body
	PostKekpoolKekPoolIDKekWithBodyWithResponse(ctx context.Context, kekPoolID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostKekpoolKekPoolIDKekResponse, error)

	PostKekpoolKekPoolIDKekWithResponse(ctx context.Context, kekPoolID string, body PostKekpoolKekPoolIDKekJSONRequestBody, reqEditors ...RequestEditorFn) (*PostKekpoolKekPoolIDKekResponse, error)
}

type GetKekpoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]externalRef0.KEKPool
	JSON400      *externalRef0.HTTP400BadRequest
	JSON401      *externalRef0.HTTP401Unauthorized
	JSON403      *externalRef0.HTTP403Forbidden
	JSON404      *externalRef0.HTTP404NotFound
	JSON429      *externalRef0.HTTP429TooManyRequests
	JSON500      *externalRef0.HTTP500InternalServerError
	JSON502      *externalRef0.HTTP502BadGateway
	JSON503      *externalRef0.HTTP503ServiceUnavailable
	JSON504      *externalRef0.HTTP504GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetKekpoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKekpoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostKekpoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *externalRef0.KEKPool
	JSON400      *externalRef0.HTTP400BadRequest
	JSON401      *externalRef0.HTTP401Unauthorized
	JSON403      *externalRef0.HTTP403Forbidden
	JSON404      *externalRef0.HTTP404NotFound
	JSON429      *externalRef0.HTTP429TooManyRequests
	JSON500      *externalRef0.HTTP500InternalServerError
	JSON502      *externalRef0.HTTP502BadGateway
	JSON503      *externalRef0.HTTP503ServiceUnavailable
	JSON504      *externalRef0.HTTP504GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r PostKekpoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostKekpoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKekpoolKekPoolIDKekResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]externalRef0.KEK
	JSON400      *externalRef0.HTTP400BadRequest
	JSON401      *externalRef0.HTTP401Unauthorized
	JSON403      *externalRef0.HTTP403Forbidden
	JSON404      *externalRef0.HTTP404NotFound
	JSON429      *externalRef0.HTTP429TooManyRequests
	JSON500      *externalRef0.HTTP500InternalServerError
	JSON502      *externalRef0.HTTP502BadGateway
	JSON503      *externalRef0.HTTP503ServiceUnavailable
	JSON504      *externalRef0.HTTP504GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r GetKekpoolKekPoolIDKekResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKekpoolKekPoolIDKekResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostKekpoolKekPoolIDKekResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *externalRef0.KEK
	JSON400      *externalRef0.HTTP400BadRequest
	JSON401      *externalRef0.HTTP401Unauthorized
	JSON403      *externalRef0.HTTP403Forbidden
	JSON404      *externalRef0.HTTP404NotFound
	JSON429      *externalRef0.HTTP429TooManyRequests
	JSON500      *externalRef0.HTTP500InternalServerError
	JSON502      *externalRef0.HTTP502BadGateway
	JSON503      *externalRef0.HTTP503ServiceUnavailable
	JSON504      *externalRef0.HTTP504GatewayTimeout
}

// Status returns HTTPResponse.Status
func (r PostKekpoolKekPoolIDKekResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostKekpoolKekPoolIDKekResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetKekpoolWithResponse request returning *GetKekpoolResponse
func (c *ClientWithResponses) GetKekpoolWithResponse(ctx context.Context, params *GetKekpoolParams, reqEditors ...RequestEditorFn) (*GetKekpoolResponse, error) {
	rsp, err := c.GetKekpool(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKekpoolResponse(rsp)
}

// PostKekpoolWithBodyWithResponse request with arbitrary body returning *PostKekpoolResponse
func (c *ClientWithResponses) PostKekpoolWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostKekpoolResponse, error) {
	rsp, err := c.PostKekpoolWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostKekpoolResponse(rsp)
}

func (c *ClientWithResponses) PostKekpoolWithResponse(ctx context.Context, body PostKekpoolJSONRequestBody, reqEditors ...RequestEditorFn) (*PostKekpoolResponse, error) {
	rsp, err := c.PostKekpool(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostKekpoolResponse(rsp)
}

// GetKekpoolKekPoolIDKekWithResponse request returning *GetKekpoolKekPoolIDKekResponse
func (c *ClientWithResponses) GetKekpoolKekPoolIDKekWithResponse(ctx context.Context, kekPoolID string, params *GetKekpoolKekPoolIDKekParams, reqEditors ...RequestEditorFn) (*GetKekpoolKekPoolIDKekResponse, error) {
	rsp, err := c.GetKekpoolKekPoolIDKek(ctx, kekPoolID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKekpoolKekPoolIDKekResponse(rsp)
}

// PostKekpoolKekPoolIDKekWithBodyWithResponse request with arbitrary body returning *PostKekpoolKekPoolIDKekResponse
func (c *ClientWithResponses) PostKekpoolKekPoolIDKekWithBodyWithResponse(ctx context.Context, kekPoolID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostKekpoolKekPoolIDKekResponse, error) {
	rsp, err := c.PostKekpoolKekPoolIDKekWithBody(ctx, kekPoolID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostKekpoolKekPoolIDKekResponse(rsp)
}

func (c *ClientWithResponses) PostKekpoolKekPoolIDKekWithResponse(ctx context.Context, kekPoolID string, body PostKekpoolKekPoolIDKekJSONRequestBody, reqEditors ...RequestEditorFn) (*PostKekpoolKekPoolIDKekResponse, error) {
	rsp, err := c.PostKekpoolKekPoolIDKek(ctx, kekPoolID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostKekpoolKekPoolIDKekResponse(rsp)
}

// ParseGetKekpoolResponse parses an HTTP response from a GetKekpoolWithResponse call
func ParseGetKekpoolResponse(rsp *http.Response) (*GetKekpoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKekpoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []externalRef0.KEKPool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.HTTP400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.HTTP401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.HTTP403Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.HTTP404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.HTTP429TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.HTTP500InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest externalRef0.HTTP502BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.HTTP503ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest externalRef0.HTTP504GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParsePostKekpoolResponse parses an HTTP response from a PostKekpoolWithResponse call
func ParsePostKekpoolResponse(rsp *http.Response) (*PostKekpoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostKekpoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.KEKPool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.HTTP400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.HTTP401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.HTTP403Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.HTTP404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.HTTP429TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.HTTP500InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest externalRef0.HTTP502BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.HTTP503ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest externalRef0.HTTP504GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParseGetKekpoolKekPoolIDKekResponse parses an HTTP response from a GetKekpoolKekPoolIDKekWithResponse call
func ParseGetKekpoolKekPoolIDKekResponse(rsp *http.Response) (*GetKekpoolKekPoolIDKekResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKekpoolKekPoolIDKekResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []externalRef0.KEK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.HTTP400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.HTTP401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.HTTP403Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.HTTP404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.HTTP429TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.HTTP500InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest externalRef0.HTTP502BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.HTTP503ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest externalRef0.HTTP504GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// ParsePostKekpoolKekPoolIDKekResponse parses an HTTP response from a PostKekpoolKekPoolIDKekWithResponse call
func ParsePostKekpoolKekPoolIDKekResponse(rsp *http.Response) (*PostKekpoolKekPoolIDKekResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostKekpoolKekPoolIDKekResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.KEK
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.HTTP400BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.HTTP401Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.HTTP403Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.HTTP404NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.HTTP429TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.HTTP500InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest externalRef0.HTTP502BadGateway
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.HTTP503ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 504:
		var dest externalRef0.HTTP504GatewayTimeout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON504 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "./openapi_spec_components.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
