// Package model provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package model

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ElasticKeyAlgorithm.
const (
	A128CBCHS256A128GCMKW    ElasticKeyAlgorithm = "A128CBC-HS256/A128GCMKW"
	A128CBCHS256A128KW       ElasticKeyAlgorithm = "A128CBC-HS256/A128KW"
	A128CBCHS256A192GCMKW    ElasticKeyAlgorithm = "A128CBC-HS256/A192GCMKW"
	A128CBCHS256A192KW       ElasticKeyAlgorithm = "A128CBC-HS256/A192KW"
	A128CBCHS256A256GCMKW    ElasticKeyAlgorithm = "A128CBC-HS256/A256GCMKW"
	A128CBCHS256A256KW       ElasticKeyAlgorithm = "A128CBC-HS256/A256KW"
	A128CBCHS256ECDHES       ElasticKeyAlgorithm = "A128CBC-HS256/ECDH-ES"
	A128CBCHS256ECDHESA128KW ElasticKeyAlgorithm = "A128CBC-HS256/ECDH-ES+A128KW"
	A128CBCHS256ECDHESA192KW ElasticKeyAlgorithm = "A128CBC-HS256/ECDH-ES+A192KW"
	A128CBCHS256ECDHESA256KW ElasticKeyAlgorithm = "A128CBC-HS256/ECDH-ES+A256KW"
	A128CBCHS256RSA15        ElasticKeyAlgorithm = "A128CBC-HS256/RSA1_5"
	A128CBCHS256RSAOAEP      ElasticKeyAlgorithm = "A128CBC-HS256/RSA-OAEP"
	A128CBCHS256RSAOAEP256   ElasticKeyAlgorithm = "A128CBC-HS256/RSA-OAEP-256"
	A128CBCHS256RSAOAEP384   ElasticKeyAlgorithm = "A128CBC-HS256/RSA-OAEP-384"
	A128CBCHS256RSAOAEP512   ElasticKeyAlgorithm = "A128CBC-HS256/RSA-OAEP-512"
	A128CBCHS256dir          ElasticKeyAlgorithm = "A128CBC-HS256/dir"
	A128GCMA128GCMKW         ElasticKeyAlgorithm = "A128GCM/A128GCMKW"
	A128GCMA128KW            ElasticKeyAlgorithm = "A128GCM/A128KW"
	A128GCMA192GCMKW         ElasticKeyAlgorithm = "A128GCM/A192GCMKW"
	A128GCMA192KW            ElasticKeyAlgorithm = "A128GCM/A192KW"
	A128GCMA256GCMKW         ElasticKeyAlgorithm = "A128GCM/A256GCMKW"
	A128GCMA256KW            ElasticKeyAlgorithm = "A128GCM/A256KW"
	A128GCMECDHES            ElasticKeyAlgorithm = "A128GCM/ECDH-ES"
	A128GCMECDHESA128KW      ElasticKeyAlgorithm = "A128GCM/ECDH-ES+A128KW"
	A128GCMECDHESA192KW      ElasticKeyAlgorithm = "A128GCM/ECDH-ES+A192KW"
	A128GCMECDHESA256KW      ElasticKeyAlgorithm = "A128GCM/ECDH-ES+A256KW"
	A128GCMRSA15             ElasticKeyAlgorithm = "A128GCM/RSA1_5"
	A128GCMRSAOAEP           ElasticKeyAlgorithm = "A128GCM/RSA-OAEP"
	A128GCMRSAOAEP256        ElasticKeyAlgorithm = "A128GCM/RSA-OAEP-256"
	A128GCMRSAOAEP384        ElasticKeyAlgorithm = "A128GCM/RSA-OAEP-384"
	A128GCMRSAOAEP512        ElasticKeyAlgorithm = "A128GCM/RSA-OAEP-512"
	A128GCMdir               ElasticKeyAlgorithm = "A128GCM/dir"
	A192CBCHS384A128GCMKW    ElasticKeyAlgorithm = "A192CBC-HS384/A128GCMKW"
	A192CBCHS384A128KW       ElasticKeyAlgorithm = "A192CBC-HS384/A128KW"
	A192CBCHS384A192GCMKW    ElasticKeyAlgorithm = "A192CBC-HS384/A192GCMKW"
	A192CBCHS384A192KW       ElasticKeyAlgorithm = "A192CBC-HS384/A192KW"
	A192CBCHS384A256GCMKW    ElasticKeyAlgorithm = "A192CBC-HS384/A256GCMKW"
	A192CBCHS384A256KW       ElasticKeyAlgorithm = "A192CBC-HS384/A256KW"
	A192CBCHS384ECDHES       ElasticKeyAlgorithm = "A192CBC-HS384/ECDH-ES"
	A192CBCHS384ECDHESA128KW ElasticKeyAlgorithm = "A192CBC-HS384/ECDH-ES+A128KW"
	A192CBCHS384ECDHESA192KW ElasticKeyAlgorithm = "A192CBC-HS384/ECDH-ES+A192KW"
	A192CBCHS384ECDHESA256KW ElasticKeyAlgorithm = "A192CBC-HS384/ECDH-ES+A256KW"
	A192CBCHS384RSA15        ElasticKeyAlgorithm = "A192CBC-HS384/RSA1_5"
	A192CBCHS384RSAOAEP      ElasticKeyAlgorithm = "A192CBC-HS384/RSA-OAEP"
	A192CBCHS384RSAOAEP256   ElasticKeyAlgorithm = "A192CBC-HS384/RSA-OAEP-256"
	A192CBCHS384RSAOAEP384   ElasticKeyAlgorithm = "A192CBC-HS384/RSA-OAEP-384"
	A192CBCHS384RSAOAEP512   ElasticKeyAlgorithm = "A192CBC-HS384/RSA-OAEP-512"
	A192CBCHS384dir          ElasticKeyAlgorithm = "A192CBC-HS384/dir"
	A192GCMA128GCMKW         ElasticKeyAlgorithm = "A192GCM/A128GCMKW"
	A192GCMA128KW            ElasticKeyAlgorithm = "A192GCM/A128KW"
	A192GCMA192GCMKW         ElasticKeyAlgorithm = "A192GCM/A192GCMKW"
	A192GCMA192KW            ElasticKeyAlgorithm = "A192GCM/A192KW"
	A192GCMA256GCMKW         ElasticKeyAlgorithm = "A192GCM/A256GCMKW"
	A192GCMA256KW            ElasticKeyAlgorithm = "A192GCM/A256KW"
	A192GCMECDHES            ElasticKeyAlgorithm = "A192GCM/ECDH-ES"
	A192GCMECDHESA128KW      ElasticKeyAlgorithm = "A192GCM/ECDH-ES+A128KW"
	A192GCMECDHESA192KW      ElasticKeyAlgorithm = "A192GCM/ECDH-ES+A192KW"
	A192GCMECDHESA256KW      ElasticKeyAlgorithm = "A192GCM/ECDH-ES+A256KW"
	A192GCMRSA15             ElasticKeyAlgorithm = "A192GCM/RSA1_5"
	A192GCMRSAOAEP           ElasticKeyAlgorithm = "A192GCM/RSA-OAEP"
	A192GCMRSAOAEP256        ElasticKeyAlgorithm = "A192GCM/RSA-OAEP-256"
	A192GCMRSAOAEP384        ElasticKeyAlgorithm = "A192GCM/RSA-OAEP-384"
	A192GCMRSAOAEP512        ElasticKeyAlgorithm = "A192GCM/RSA-OAEP-512"
	A192GCMdir               ElasticKeyAlgorithm = "A192GCM/dir"
	A256CBCHS512A128GCMKW    ElasticKeyAlgorithm = "A256CBC-HS512/A128GCMKW"
	A256CBCHS512A128KW       ElasticKeyAlgorithm = "A256CBC-HS512/A128KW"
	A256CBCHS512A192GCMKW    ElasticKeyAlgorithm = "A256CBC-HS512/A192GCMKW"
	A256CBCHS512A192KW       ElasticKeyAlgorithm = "A256CBC-HS512/A192KW"
	A256CBCHS512A256GCMKW    ElasticKeyAlgorithm = "A256CBC-HS512/A256GCMKW"
	A256CBCHS512A256KW       ElasticKeyAlgorithm = "A256CBC-HS512/A256KW"
	A256CBCHS512ECDHES       ElasticKeyAlgorithm = "A256CBC-HS512/ECDH-ES"
	A256CBCHS512ECDHESA128KW ElasticKeyAlgorithm = "A256CBC-HS512/ECDH-ES+A128KW"
	A256CBCHS512ECDHESA192KW ElasticKeyAlgorithm = "A256CBC-HS512/ECDH-ES+A192KW"
	A256CBCHS512ECDHESA256KW ElasticKeyAlgorithm = "A256CBC-HS512/ECDH-ES+A256KW"
	A256CBCHS512RSA15        ElasticKeyAlgorithm = "A256CBC-HS512/RSA1_5"
	A256CBCHS512RSAOAEP      ElasticKeyAlgorithm = "A256CBC-HS512/RSA-OAEP"
	A256CBCHS512RSAOAEP256   ElasticKeyAlgorithm = "A256CBC-HS512/RSA-OAEP-256"
	A256CBCHS512RSAOAEP384   ElasticKeyAlgorithm = "A256CBC-HS512/RSA-OAEP-384"
	A256CBCHS512RSAOAEP512   ElasticKeyAlgorithm = "A256CBC-HS512/RSA-OAEP-512"
	A256CBCHS512dir          ElasticKeyAlgorithm = "A256CBC-HS512/dir"
	A256GCMA128GCMKW         ElasticKeyAlgorithm = "A256GCM/A128GCMKW"
	A256GCMA128KW            ElasticKeyAlgorithm = "A256GCM/A128KW"
	A256GCMA192GCMKW         ElasticKeyAlgorithm = "A256GCM/A192GCMKW"
	A256GCMA192KW            ElasticKeyAlgorithm = "A256GCM/A192KW"
	A256GCMA256GCMKW         ElasticKeyAlgorithm = "A256GCM/A256GCMKW"
	A256GCMA256KW            ElasticKeyAlgorithm = "A256GCM/A256KW"
	A256GCMECDHES            ElasticKeyAlgorithm = "A256GCM/ECDH-ES"
	A256GCMECDHESA128KW      ElasticKeyAlgorithm = "A256GCM/ECDH-ES+A128KW"
	A256GCMECDHESA192KW      ElasticKeyAlgorithm = "A256GCM/ECDH-ES+A192KW"
	A256GCMECDHESA256KW      ElasticKeyAlgorithm = "A256GCM/ECDH-ES+A256KW"
	A256GCMRSA15             ElasticKeyAlgorithm = "A256GCM/RSA1_5"
	A256GCMRSAOAEP           ElasticKeyAlgorithm = "A256GCM/RSA-OAEP"
	A256GCMRSAOAEP256        ElasticKeyAlgorithm = "A256GCM/RSA-OAEP-256"
	A256GCMRSAOAEP384        ElasticKeyAlgorithm = "A256GCM/RSA-OAEP-384"
	A256GCMRSAOAEP512        ElasticKeyAlgorithm = "A256GCM/RSA-OAEP-512"
	A256GCMdir               ElasticKeyAlgorithm = "A256GCM/dir"
	ES256                    ElasticKeyAlgorithm = "ES256"
	ES384                    ElasticKeyAlgorithm = "ES384"
	ES512                    ElasticKeyAlgorithm = "ES512"
	EdDSA                    ElasticKeyAlgorithm = "EdDSA"
	HS256                    ElasticKeyAlgorithm = "HS256"
	HS384                    ElasticKeyAlgorithm = "HS384"
	HS512                    ElasticKeyAlgorithm = "HS512"
	PS256                    ElasticKeyAlgorithm = "PS256"
	PS384                    ElasticKeyAlgorithm = "PS384"
	PS512                    ElasticKeyAlgorithm = "PS512"
	RS256                    ElasticKeyAlgorithm = "RS256"
	RS384                    ElasticKeyAlgorithm = "RS384"
	RS512                    ElasticKeyAlgorithm = "RS512"
)

// Defines values for ElasticKeyProvider.
const (
	Internal ElasticKeyProvider = "Internal"
)

// Defines values for ElasticKeySort.
const (
	ElasticKeySortAlgorithmASC          ElasticKeySort = "algorithm:ASC"
	ElasticKeySortAlgorithmDESC         ElasticKeySort = "algorithm:DESC"
	ElasticKeySortExportAllowedASC      ElasticKeySort = "export_allowed:ASC"
	ElasticKeySortExportAllowedDESC     ElasticKeySort = "export_allowed:DESC"
	ElasticKeySortIdASC                 ElasticKeySort = "id:ASC"
	ElasticKeySortIdDESC                ElasticKeySort = "id:DESC"
	ElasticKeySortImportAllowedASC      ElasticKeySort = "import_allowed:ASC"
	ElasticKeySortImportAllowedDESC     ElasticKeySort = "import_allowed:DESC"
	ElasticKeySortNameASC               ElasticKeySort = "name:ASC"
	ElasticKeySortNameDESC              ElasticKeySort = "name:DESC"
	ElasticKeySortProviderASC           ElasticKeySort = "provider:ASC"
	ElasticKeySortProviderDESC          ElasticKeySort = "provider:DESC"
	ElasticKeySortStatusASC             ElasticKeySort = "status:ASC"
	ElasticKeySortStatusDESC            ElasticKeySort = "status:DESC"
	ElasticKeySortVersioningAllowedASC  ElasticKeySort = "versioning_allowed:ASC"
	ElasticKeySortVersioningAllowedDESC ElasticKeySort = "versioning_allowed:DESC"
)

// Defines values for ElasticKeyStatus.
const (
	Active                         ElasticKeyStatus = "active"
	Creating                       ElasticKeyStatus = "creating"
	Disabled                       ElasticKeyStatus = "disabled"
	FinishedDelete                 ElasticKeyStatus = "finished_delete"
	GenerateFailed                 ElasticKeyStatus = "generate_failed"
	ImportFailed                   ElasticKeyStatus = "import_failed"
	PendingDeleteWasActive         ElasticKeyStatus = "pending_delete_was_active"
	PendingDeleteWasDisabled       ElasticKeyStatus = "pending_delete_was_disabled"
	PendingDeleteWasGenerateFailed ElasticKeyStatus = "pending_delete_was_generate_failed"
	PendingDeleteWasImportFailed   ElasticKeyStatus = "pending_delete_was_import_failed"
	PendingDeleteWasPendingImport  ElasticKeyStatus = "pending_delete_was_pending_import"
	PendingGenerate                ElasticKeyStatus = "pending_generate"
	PendingImport                  ElasticKeyStatus = "pending_import"
	StartedDelete                  ElasticKeyStatus = "started_delete"
)

// Defines values for KeySort.
const (
	KeySortGenerateDate     KeySort = "generate_date"
	KeySortGenerateDateASC  KeySort = "generate_date:ASC"
	KeySortGenerateDateDESC KeySort = "generate_date:DESC"
	KeySortId               KeySort = "id"
	KeySortIdASC            KeySort = "id:ASC"
	KeySortIdDESC           KeySort = "id:DESC"
	KeySortPool             KeySort = "pool"
	KeySortPoolASC          KeySort = "pool:ASC"
	KeySortPoolDESC         KeySort = "pool:DESC"
)

// DecryptRequest Base64Url-encoded JSON Web Encryption (JWE) of the encrypted bytes (and non-secret cipher parameters) in compact serialized format. See RFC 7516 JSON Web Encryption (JWE) for more details. Compact serialized format is 'Header.EncryptedKey.IV.Ciphertext.AuthenticationTag'. There are five Base64Url-encoded parts and separated by '.'. Some parts can be empty depending on the 'alg' and 'enc' headers parameters. - Header: Required base64Url-encoded JSON key/values for the JWE. - EncryptedKey: Optional base64Url-encoded JWE of an encrypted symmetric key used to encrypt the payload. This is non-empty for envelope encryption (e.g. alg=a256gcmkw), or empty for direct encryption (e.g. alg=dir). - IV: Required base64Url-encoded Initialization Vector (IV) used for encryption. For AES-GCM or AES-GCM-SIV it contains a 12-bytes nonce. For AES-CBC it contains a 16-bytes IV. - Ciphertext: Required base64Url-encoded encrypted secret bytes. It is always non-empty. For AES-GCM or AES-GCM-SIV it contains same number of bytes as the plaintext. - AuthenticationTag: Required base64Url-encoded authentication tag used for encryption. For AES-GCM or AES-GCM-SIV it contains a 16-bytes authentication tag. For AES-CBC-HMAC it contains a N-bytes HMAC hash.
type DecryptRequest = string

// DecryptResponse Decrypted text. If you pre-encoded bytes to text before submitting them for encryption, remember to decode to bytes; use the same encoding scheme you chose before submission (e.g. Hexadecimal, Base64, Base64-URL, Base64-MIME, etc).
type DecryptResponse = string

// ElasticKey defines model for ElasticKey.
type ElasticKey struct {
	// Algorithm Cryptographic algorithm(s) used for Keys in the Elastic Key. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'dir', the Elastic Key Key is directly used on values. direct encryption is useful for small values. If key encryption algorithm is 'K*W', a random Content Encryption Key (CEK) is used directly on values, and the Elastic Key Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
	Algorithm *ElasticKeyAlgorithm `json:"algorithm,omitempty"`

	// Description Description for a Elastic Key.
	Description *ElasticKeyDescription `json:"description,omitempty"`

	// ExportAllowed Indicates if the Elastic Key supports export.
	ExportAllowed *ElasticKeyExportAllowed `json:"export_allowed,omitempty"`

	// Id Unique UUID for a Elastic Key.
	Id *ElasticKeyId `json:"id,omitempty"`

	// ImportAllowed Indicates if the Elastic Key supports import (BYOK).
	ImportAllowed *ElasticKeyImportAllowed `json:"import_allowed,omitempty"`

	// Name Friendly name for a Elastic Key.
	Name *ElasticKeyName `json:"name,omitempty"`

	// Provider Provider of the Elastic Key management service.
	Provider *ElasticKeyProvider `json:"provider,omitempty"`

	// Status Status of the Elastic Key.
	Status *ElasticKeyStatus `json:"status,omitempty"`

	// VersioningAllowed Indicates if the Elastic Key supports versioning.
	VersioningAllowed *ElasticKeyVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// ElasticKeyAlgorithm Cryptographic algorithm(s) used for Keys in the Elastic Key. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'dir', the Elastic Key Key is directly used on values. direct encryption is useful for small values. If key encryption algorithm is 'K*W', a random Content Encryption Key (CEK) is used directly on values, and the Elastic Key Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
type ElasticKeyAlgorithm string

// ElasticKeyCreate defines model for ElasticKeyCreate.
type ElasticKeyCreate struct {
	// Algorithm Cryptographic algorithm(s) used for Keys in the Elastic Key. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'dir', the Elastic Key Key is directly used on values. direct encryption is useful for small values. If key encryption algorithm is 'K*W', a random Content Encryption Key (CEK) is used directly on values, and the Elastic Key Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
	Algorithm *ElasticKeyAlgorithm `json:"algorithm,omitempty"`

	// Description Description for a Elastic Key.
	Description ElasticKeyDescription `json:"description"`

	// ExportAllowed Indicates if the Elastic Key supports export.
	ExportAllowed *ElasticKeyExportAllowed `json:"export_allowed,omitempty"`

	// ImportAllowed Indicates if the Elastic Key supports import (BYOK).
	ImportAllowed *ElasticKeyImportAllowed `json:"import_allowed,omitempty"`

	// Name Friendly name for a Elastic Key.
	Name ElasticKeyName `json:"name"`

	// Provider Provider of the Elastic Key management service.
	Provider *ElasticKeyProvider `json:"provider,omitempty"`

	// VersioningAllowed Indicates if the Elastic Key supports versioning.
	VersioningAllowed *ElasticKeyVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// ElasticKeyDescription Description for a Elastic Key.
type ElasticKeyDescription = string

// ElasticKeyExportAllowed Indicates if the Elastic Key supports export.
type ElasticKeyExportAllowed = bool

// ElasticKeyId Unique UUID for a Elastic Key.
type ElasticKeyId = openapi_types.UUID

// ElasticKeyImportAllowed Indicates if the Elastic Key supports import (BYOK).
type ElasticKeyImportAllowed = bool

// ElasticKeyKeysQueryParams defines model for ElasticKeyKeysQueryParams.
type ElasticKeyKeysQueryParams struct {
	Id *[]KeyId `json:"id,omitempty"`

	// MaxExpirationDate ISO 8601 UTC timestamp of Key generation.
	MaxExpirationDate *KeyExpirationDate `json:"max_expiration_date,omitempty"`

	// MaxGenerateDate ISO 8601 UTC timestamp of Key generation.
	MaxGenerateDate *KeyGenerateDate `json:"max_generate_date,omitempty"`

	// MaxImportDate ISO 8601 UTC timestamp of Key generation.
	MaxImportDate *KeyImportDate `json:"max_import_date,omitempty"`

	// MaxRevocationDate ISO 8601 UTC timestamp of Key generation.
	MaxRevocationDate *KeyRevocationDate `json:"max_revocation_date,omitempty"`

	// MinExpirationDate ISO 8601 UTC timestamp of Key generation.
	MinExpirationDate *KeyExpirationDate `json:"min_expiration_date,omitempty"`

	// MinGenerateDate ISO 8601 UTC timestamp of Key generation.
	MinGenerateDate *KeyGenerateDate `json:"min_generate_date,omitempty"`

	// MinImportDate ISO 8601 UTC timestamp of Key generation.
	MinImportDate *KeyImportDate `json:"min_import_date,omitempty"`

	// MinRevocationDate ISO 8601 UTC timestamp of Key generation.
	MinRevocationDate *KeyRevocationDate `json:"min_revocation_date,omitempty"`

	// Page Page number starting at 0.
	Page *PageNumber `json:"page,omitempty"`

	// Size Page number.
	Size *PageSize  `json:"size,omitempty"`
	Sort *[]KeySort `json:"sort,omitempty"`
}

// ElasticKeyName Friendly name for a Elastic Key.
type ElasticKeyName = string

// ElasticKeyProvider Provider of the Elastic Key management service.
type ElasticKeyProvider string

// ElasticKeySort defines model for ElasticKeySort.
type ElasticKeySort string

// ElasticKeyStatus Status of the Elastic Key.
type ElasticKeyStatus string

// ElasticKeyUpdate defines model for ElasticKeyUpdate.
type ElasticKeyUpdate struct {
	// Description Description for a Elastic Key.
	Description ElasticKeyDescription `json:"description"`

	// Name Friendly name for a Elastic Key.
	Name ElasticKeyName `json:"name"`
}

// ElasticKeyVersioningAllowed Indicates if the Elastic Key supports versioning.
type ElasticKeyVersioningAllowed = bool

// ElasticKeysQueryParams defines model for ElasticKeysQueryParams.
type ElasticKeysQueryParams struct {
	Algorithm *[]ElasticKeyAlgorithm `json:"algorithm,omitempty"`

	// ExportAllowed Indicates if the Elastic Key supports export.
	ExportAllowed *ElasticKeyExportAllowed `json:"export_allowed,omitempty"`
	Id            *[]ElasticKeyId          `json:"id,omitempty"`

	// ImportAllowed Indicates if the Elastic Key supports import (BYOK).
	ImportAllowed *ElasticKeyImportAllowed `json:"import_allowed,omitempty"`
	Name          *[]ElasticKeyName        `json:"name,omitempty"`

	// Page Page number starting at 0.
	Page     *PageNumber           `json:"page,omitempty"`
	Provider *[]ElasticKeyProvider `json:"provider,omitempty"`

	// Size Page number.
	Size   *PageSize           `json:"size,omitempty"`
	Sort   *[]ElasticKeySort   `json:"sort,omitempty"`
	Status *[]ElasticKeyStatus `json:"status,omitempty"`

	// VersioningAllowed Indicates if the Elastic Key supports versioning.
	VersioningAllowed *ElasticKeyVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// EncryptContext Base64URL-encoded context. This is non-secret data used for authentication and integrity checking during decryption (e.g. namespace, context).
type EncryptContext = string

// EncryptParams defines model for EncryptParams.
type EncryptParams struct {
	// Context Base64URL-encoded context. This is non-secret data used for authentication and integrity checking during decryption (e.g. namespace, context).
	Context *EncryptContext `json:"context,omitempty"`
}

// EncryptRequest Clear text to be encrypted. If you need to encrypt bytes, encode them first as text (e.g. Hexadecimal, Base64, Base64-URL, Base64-MIME, etc).
type EncryptRequest = string

// EncryptResponse Base64Url-encoded JSON Web Encryption (JWE) of the encrypted bytes (and non-secret cipher parameters) in compact serialized format. See RFC 7516 JSON Web Encryption (JWE) for more details. Compact serialized format is 'Header.EncryptedKey.IV.Ciphertext.AuthenticationTag'. There are five Base64Url-encoded parts and separated by '.'. Some parts can be empty depending on the 'alg' and 'enc' headers parameters. - Header: Required base64Url-encoded JSON key/values for the JWE. - EncryptedKey: Optional base64Url-encoded JWE of an encrypted symmetric key used to encrypt the payload. This is non-empty for envelope encryption (e.g. alg=a256gcmkw), or empty for direct encryption (e.g. alg=dir). - IV: Required base64Url-encoded Initialization Vector (IV) used for encryption. For AES-GCM or AES-GCM-SIV it contains a 12-bytes nonce. For AES-CBC it contains a 16-bytes IV. - Ciphertext: Required base64Url-encoded encrypted secret bytes. It is always non-empty. For AES-GCM or AES-GCM-SIV it contains same number of bytes as the plaintext. - AuthenticationTag: Required base64Url-encoded authentication tag used for encryption. For AES-GCM or AES-GCM-SIV it contains a 16-bytes authentication tag. For AES-CBC-HMAC it contains a N-bytes HMAC hash.
type EncryptResponse = string

// HTTPError defines model for HTTPError.
type HTTPError struct {
	// Error HTTP status message
	Error string `json:"error"`

	// Message Detailed error message
	Message string `json:"message"`

	// Status HTTP status code
	Status int `json:"status"`
}

// Key defines model for Key.
type Key struct {
	// Decrypted Clear private or secret key material (if ElasticKey exportAllowed=true)
	Decrypted *KeyMaterialDecrypted `json:"decrypted,omitempty"`

	// Encrypted Encrypted private or secret key material (if ElasticKey exportAllowed=true)
	Encrypted *KeyMaterialEncrypted `json:"encrypted,omitempty"`

	// ExpirationDate ISO 8601 UTC timestamp of Key generation.
	ExpirationDate *KeyExpirationDate `json:"expiration_date,omitempty"`

	// GenerateDate ISO 8601 UTC timestamp of Key generation.
	GenerateDate *KeyGenerateDate `json:"generate_date,omitempty"`

	// Id Unique UUID for a Key.
	Id KeyId `json:"id"`

	// ImportDate ISO 8601 UTC timestamp of Key generation.
	ImportDate *KeyImportDate `json:"import_date,omitempty"`

	// Pool Unique UUID for a Elastic Key.
	Pool ElasticKeyId `json:"pool"`

	// Public Clear public key material (if applicable)
	Public *KeyMaterialPublic `json:"public,omitempty"`

	// RevocationDate ISO 8601 UTC timestamp of Key generation.
	RevocationDate *KeyRevocationDate `json:"revocation_date,omitempty"`
}

// KeyExpirationDate ISO 8601 UTC timestamp of Key generation.
type KeyExpirationDate = time.Time

// KeyGenerate defines model for KeyGenerate.
type KeyGenerate = map[string]interface{}

// KeyGenerateDate ISO 8601 UTC timestamp of Key generation.
type KeyGenerateDate = time.Time

// KeyId Unique UUID for a Key.
type KeyId = openapi_types.UUID

// KeyImportDate ISO 8601 UTC timestamp of Key generation.
type KeyImportDate = time.Time

// KeyMaterialDecrypted Clear private or secret key material (if ElasticKey exportAllowed=true)
type KeyMaterialDecrypted = string

// KeyMaterialEncrypted Encrypted private or secret key material (if ElasticKey exportAllowed=true)
type KeyMaterialEncrypted = string

// KeyMaterialPublic Clear public key material (if applicable)
type KeyMaterialPublic = string

// KeyRevocationDate ISO 8601 UTC timestamp of Key generation.
type KeyRevocationDate = time.Time

// KeySort defines model for KeySort.
type KeySort string

// KeyUpdate defines model for KeyUpdate.
type KeyUpdate struct {
	// Id Unique UUID for a Key.
	Id KeyId `json:"id"`

	// Pool Unique UUID for a Elastic Key.
	Pool ElasticKeyId `json:"pool"`
}

// KeysQueryParams defines model for KeysQueryParams.
type KeysQueryParams struct {
	Id *[]KeyId `json:"id,omitempty"`

	// MaxExpirationDate ISO 8601 UTC timestamp of Key generation.
	MaxExpirationDate *KeyExpirationDate `json:"max_expiration_date,omitempty"`

	// MaxGenerateDate ISO 8601 UTC timestamp of Key generation.
	MaxGenerateDate *KeyGenerateDate `json:"max_generate_date,omitempty"`

	// MaxImportDate ISO 8601 UTC timestamp of Key generation.
	MaxImportDate *KeyImportDate `json:"max_import_date,omitempty"`

	// MaxRevocationDate ISO 8601 UTC timestamp of Key generation.
	MaxRevocationDate *KeyRevocationDate `json:"max_revocation_date,omitempty"`

	// MinExpirationDate ISO 8601 UTC timestamp of Key generation.
	MinExpirationDate *KeyExpirationDate `json:"min_expiration_date,omitempty"`

	// MinGenerateDate ISO 8601 UTC timestamp of Key generation.
	MinGenerateDate *KeyGenerateDate `json:"min_generate_date,omitempty"`

	// MinImportDate ISO 8601 UTC timestamp of Key generation.
	MinImportDate *KeyImportDate `json:"min_import_date,omitempty"`

	// MinRevocationDate ISO 8601 UTC timestamp of Key generation.
	MinRevocationDate *KeyRevocationDate `json:"min_revocation_date,omitempty"`

	// Page Page number starting at 0.
	Page *PageNumber     `json:"page,omitempty"`
	Pool *[]ElasticKeyId `json:"pool,omitempty"`

	// Size Page number.
	Size *PageSize  `json:"size,omitempty"`
	Sort *[]KeySort `json:"sort,omitempty"`
}

// PageNumber Page number starting at 0.
type PageNumber = int

// PageSize Page number.
type PageSize = int

// SignContext Base64URL-encoded context Authenticated Data (AAD). This is non-secret data used for integrity checking during verify (e.g. namespace, context).
type SignContext = string

// SignParams defines model for SignParams.
type SignParams struct {
	// Context Base64URL-encoded context Authenticated Data (AAD). This is non-secret data used for integrity checking during verify (e.g. namespace, context).
	Context *SignContext `json:"context,omitempty"`
}

// SignRequest Clear text to be signed. Can be JSON-encoded to create a JWT, or freeform to create a JWS. If you need freeform, encode as text (e.g. Base64-URL, Base64-MIME, Base64, Hexadecimal, etc).
type SignRequest = string

// SignResponse Base64Url-encoded JSON Web Signature (JWS) of the clear text in compact serialized format. See RFC 7515 JSON Web Signature (JWS) for more details. Compact serialized format is 'Header.Payload.Signature'. There are three Base64Url-encoded parts and separated by '.'. - Header: Required base64Url-encoded JSON key/values for the JWS. - Plaintext: Required base64Url-encoded clear text. It is always non-empty. Can be freeform (JWS) or JSON-encoded (JWT). - Signature: Required base64Url-encoded signature.
type SignResponse = string

// VerifyRequest Base64Url-encoded JSON Web Signature (JWS) of the clear text in compact serialized format. See RFC 7515 JSON Web Signature (JWS) for more details. Compact serialized format is 'Header.Payload.Signature'. There are three Base64Url-encoded parts and separated by '.'. - Header: Required base64Url-encoded JSON key/values for the JWS. - Plaintext: Required base64Url-encoded clear text. It is always non-empty. Can be freeform (JWS) or JSON-encoded (JWT). - Signature: Required base64Url-encoded signature.
type VerifyRequest = string

// VerifyResponse Optional message about verification result
type VerifyResponse = string

// ElasticKeyQueryParamAlgorithms defines model for ElasticKeyQueryParamAlgorithms.
type ElasticKeyQueryParamAlgorithms = []ElasticKeyAlgorithm

// ElasticKeyQueryParamExportAllowed Indicates if the Elastic Key supports export.
type ElasticKeyQueryParamExportAllowed = ElasticKeyExportAllowed

// ElasticKeyQueryParamIds defines model for ElasticKeyQueryParamIds.
type ElasticKeyQueryParamIds = []ElasticKeyId

// ElasticKeyQueryParamImportAllowed Indicates if the Elastic Key supports import (BYOK).
type ElasticKeyQueryParamImportAllowed = ElasticKeyImportAllowed

// ElasticKeyQueryParamNames defines model for ElasticKeyQueryParamNames.
type ElasticKeyQueryParamNames = []ElasticKeyName

// ElasticKeyQueryParamPageNumber Page number starting at 0.
type ElasticKeyQueryParamPageNumber = PageNumber

// ElasticKeyQueryParamPageSize Page number.
type ElasticKeyQueryParamPageSize = PageSize

// ElasticKeyQueryParamProviders defines model for ElasticKeyQueryParamProviders.
type ElasticKeyQueryParamProviders = []ElasticKeyProvider

// ElasticKeyQueryParamSorts defines model for ElasticKeyQueryParamSorts.
type ElasticKeyQueryParamSorts = []ElasticKeySort

// ElasticKeyQueryParamStatuses defines model for ElasticKeyQueryParamStatuses.
type ElasticKeyQueryParamStatuses = []ElasticKeyStatus

// ElasticKeyQueryParamVersioningAllowed Indicates if the Elastic Key supports versioning.
type ElasticKeyQueryParamVersioningAllowed = ElasticKeyVersioningAllowed

// KeyQueryParamElasticKeyIds defines model for KeyQueryParamElasticKeyIds.
type KeyQueryParamElasticKeyIds = []ElasticKeyId

// KeyQueryParamIds defines model for KeyQueryParamIds.
type KeyQueryParamIds = []KeyId

// KeyQueryParamMaximumExpirationDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMaximumExpirationDate = KeyExpirationDate

// KeyQueryParamMaximumGenerateDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMaximumGenerateDate = KeyGenerateDate

// KeyQueryParamMaximumImportDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMaximumImportDate = KeyImportDate

// KeyQueryParamMaximumRevocationDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMaximumRevocationDate = KeyRevocationDate

// KeyQueryParamMinimumExpirationDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMinimumExpirationDate = KeyExpirationDate

// KeyQueryParamMinimumGenerateDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMinimumGenerateDate = KeyGenerateDate

// KeyQueryParamMinimumImportDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMinimumImportDate = KeyImportDate

// KeyQueryParamMinimumRevocationDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMinimumRevocationDate = KeyRevocationDate

// KeyQueryParamPageNumber Page number starting at 0.
type KeyQueryParamPageNumber = PageNumber

// KeyQueryParamPageSize Page number.
type KeyQueryParamPageSize = PageSize

// KeyQueryParamSorts defines model for KeyQueryParamSorts.
type KeyQueryParamSorts = []KeySort

// HTTP400BadRequest defines model for HTTP400BadRequest.
type HTTP400BadRequest struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP401Unauthorized defines model for HTTP401Unauthorized.
type HTTP401Unauthorized struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP403Forbidden defines model for HTTP403Forbidden.
type HTTP403Forbidden struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP404NotFound defines model for HTTP404NotFound.
type HTTP404NotFound struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP429TooManyRequests defines model for HTTP429TooManyRequests.
type HTTP429TooManyRequests struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP500InternalServerError defines model for HTTP500InternalServerError.
type HTTP500InternalServerError struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP502BadGateway defines model for HTTP502BadGateway.
type HTTP502BadGateway struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP503ServiceUnavailable defines model for HTTP503ServiceUnavailable.
type HTTP503ServiceUnavailable struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP504GatewayTimeout defines model for HTTP504GatewayTimeout.
type HTTP504GatewayTimeout struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w8a3PbOJJ/BcXbKts7kiLLVm6irf3gyEqiZJL4LDup3ZlcBiJbEnZIgAOAjjVT/u9X",
	"ePABilRIyd5kr/zBZRFEN/oBNLobDf7p+SyKGQUqhTf604sxxxFI4PppEmIhif8G1v+TAF9fqJdn4ZJx",
	"IleR7hGA8DmJJWHUG3kvSCiBo/ka+XwdS7bkOF4RH+EUpud1PLiNQxaAN5I8gY5HFODvCr3X8SiOwBt5",
	"WX+v4wl/BRFWYxEJZtC/cFh4I++/nuS0PzHdxJOc5IxQ767jyXWsEXOO1+pZyHWoGhaM6/dVnE5uY8bl",
	"WRiyLxBsY/bLCuQKOAINgIhA2AApdqv4Mx0/214Ok814c0m7q2FgGmzVkVwBsmDoDazR9BwdXl9Pz48a",
	"aokE+6hnGuyql2nUUi8kaqgX03EPvbik1enlHY6glWYUeQ2Vov/toRZF266KucBLeJdEc+B64ArqYryE",
	"xmItoLvbMuKM/AF14wn1rs14GlntaJzdkMDaxjrdFfUWW4CGuku776O/lMZddThjXFbwN4vBJ4s1EoxL",
	"QpcIC/TrgkAYqPkyCggHX/X8FR1Cb9nroF8VSyMs/F+PeugSYsASZXsLWjCOoiSUJA5Bo0Qal2goJwWx",
	"j4wUjzvLR2KZiHbLV2iYpszpznuxZzDsyOAH4IIwSuiyhYW9yYAaWNm88x6WdpNMtWrd/buw17TeCJOE",
	"BE03wpix8OG3wrZbu+HkAffy3Sh/i29JlCjninCsCD/HEprwEhlA5WVZSBRgCeiQUD9MBLmBo7oZF+Hb",
	"zznYZwXWeMoZb6tI610NSy+BAscS2jK0tHCt2EmBWjPjUFnHivFj2jJi/aw2bFiPqy0TBfrqWLiEG+bv",
	"NMF4BtmKlRysNTslWjdZInTHNWMAd1ozhD7omjGUtV4zlqH2a4bQB1szhqaWa8Yy0nbNEPoga8ZQs8Oa",
	"sWzssmYIfcg187DByL8pCnkQ15wE35dj3tgjv+t4HETMqPW/X11dXZz2+89xcAm/JyCkavQZlUD1TxzH",
	"ITFz5Mm/hBLWnwXacBi+X3ijn7cTp8aYcM5UQPWnitBi4JKY8UG3qx+3OIo1oc9xgFJiMnaE5IQuFT8R",
	"CKFmnQNztQLEDQzyWRIGiDKJ5oASqoJNyViAGEdfsEAREULpWHUnHIJcdVpFG+PZYKI43Gm/3/HsVpc+",
	"mUVsnywSQiUs7Wy3TWz+L/Cld/fpTjW6s7DI+F3Hqub4muJErhgnf5g44tsqx6GmqXbOErkCKi2paIFJ",
	"CFofiQCOAgZCq2uFbwDFwLWGGBV6KSkrGYDQmsJ6FTbX0rGjpWNHS8e7asmRQKamkxeMz0kQAP32OspJ",
	"2VFBIvF9gAACNE+k1gDOO0BQpTbs+yAEkkx35yBYwn1orqoTR1UnjqpOdlVVLohMT6fvmHzBEvodLKV3",
	"TCJDyg5WDoJMyK7BWyiMzeV+6sj91JH76a5yzzlL5T54dsXYW0zX1r6Jby/+K8aQoghlJDVVwz9YYia9",
	"ACqRZAxFCo/VjECEIoyW5AYowhFLqERsgSSJmi+HwbOiWvRTphb1tJtaNjm26hn2+1MqgVMczoDfAJ+k",
	"4vq2KkqJQoYqZEAbGzWKEgq3MfhqtWj0iPl+wtVWwqg2VEIjbqqXobPvD519f7j7vl/NZqabwXMcvMQS",
	"vuD19+GcpcS0MVtG0IiDD+RGbeUUEXqDQ6LtmPZH0YKzSGsliYXkgKPW6hk46hk46hns45alLGdKOVG6",
	"Ij5cU3yDSYjnIXx75ViaUJGoHZREBNKrhMpwjRKq0KiNfYVpoH4VXO0g0W8kqLgY8zViN8BDhrVzF2El",
	"aIppcz9g6PgBQ8cPGO7uB1TJJdPkqdXtFYmAJd9B/GPpQSlBO2gwIMYfsMsNYb39hOv7XGunjqZOHU3t",
	"7DmUeVc9rBjV8OegiyIKoWp5qQp4enrNwy5QnykH9vXs/Tv0EeZoQjWocm8PX3+cHOk9eQUITLvyddcS",
	"BDrEVMmOdgX4HCTySbwCXggSj9T+rrSMfamERnCoQgEVrERY9tAMAF2+GKP/Hh4/3TK8ThMwroIbiUko",
	"emhch1MtyINXgAPgvUlK7htY96YfemNNnoRb2XOd+Cu8POihqxVwQJgDWqh5sCmfGHMpkOJZgOLRCAId",
	"9A56aMYisB18TJVzCVEs1yiAGGigYmi7ix7gcHmgkRwA9Q/QStMqipE16iLDwUh7Hzqcm1dr6zdYP7nB",
	"YQJ5APj640RhKDI/Qu+1OHFYhefjROkX04J6xTqKQHLiqwFUCBMo02Xf61FivFa2S0mNCCV0NQ0My4oQ",
	"oDcQsjibMlqX0Fv2EA6Xf8eD4dOlH/325aijjF8OZrJH1UAB4UeKsemHrWKZUiL1lDDh2QfwJePocPrh",
	"yPBhqEvx99ALxtHZZNZ9OX6L8p/d2fQDIhIp64YJFQij40HXzHrKlJXOAMfPx+WeT23P6QdFcD7tthJe",
	"kL5ZTRpHD01tJckXvC5IuTHhAkeAqM4kKjUbwrAwSgz1tnMrFZkbS2IrtdiNgiVe7iveVGibmB1Zd1+9",
	"PSsL/J0F1a9WWKx6v6h4PsZSOYveyPvfn8+6/8TdP/rdZ5+7n3745Zee0/DXckODHn+pMv6ZzTU7x6bR",
	"tR3UetJiny7QmiUo5pBJ1rCiPYVbFaUulOETyTwiUudb5Qqikpg7iEMEWsWSoQAUIvVLo/qbUoxx4NVU",
	"0MMoPHqrAD28v2ICnKF0UskuvldwiwPwSYTDjrWK6f/u9eVP2e+307eTDgLpH1VujPn5sy78c3b2vABv",
	"t3I7R8hNMZwXgO465SK5XWvjOh4J2h7Fl+rAdi3/SvPibWuvsjqgnap+coenbblIRWHGnvUYJa+pOOnO",
	"ilPMXZTj6uLRQ1HYMt7AWicrSrUb2mtAC8KFttLqrXWIi5tYhrKjN34TTPuMBikMS7dntd1WAWpLUfdS",
	"+zwB4QedjdIS9UeE3VdDu5UziozP0KvYcIlQnRZJqNkWEQ7DrPfXaHjz148HHYQRxzRgERpbSRT8OUXP",
	"4Xjy5siOE+SkZVTlQqrgpMoXGU/e9PT7LxzHJQZCzJdgEVt7tiChGmQesrmw9kpxRigKWDKXHbW5ELVx",
	"LrQRVdbz4GwwfPpy/PaJ+v/m44FGnUvmbxbE5N8XOAmlPsGiysP/2XOBvY53dvxsUGoY/Og2pCDHzwYu",
	"SN5gQbKGDGTwYwkka0hB0oYCYS/Hbzdoy9ty8rK2AoUbsE5bTucmrH63Qe0mbKHNwgaEF6DSJ9PfPtme",
	"l7Oz7vuzyUV3eDwogGw0G9hycxnJyY+nVUjS5hIS21xGMhg+rUKSNpeQ2OYSkgoEFcAu4PHnoQuWNmRA",
	"tsGCTMbnr7qT2Q8bM7fihUGx+aKMqjyjK16UUJVneP6iNNMrXpRRlWa+fbGJYxPYQmkXdDY8HrjL2TSf",
	"/HjqLmrTPBg+dZd2AUlRHAUkRWEUkBRFUURSEEQRSUEMRSQFIbjsFBejy1FxSbpMFRemy1cNtpJxcLmr",
	"w+YaCpfHOmyu0cix5aYjx5MbkBxDbkZy2ApjkiOpMCk5tgrDUoE2Ny8VaHMjU4E2NzUVaHODU4E2NzsV",
	"aHPjs4m2FmUtuipUuVFyEOWmyUGTG6gcSaWZypFVGqscaaXJqkBevVIrzVcF8uqVW2nKqpBXruRKs7aB",
	"vA5rHTqv413OjNovZ2ZWXc7MpL2w7Re2/cK2T2z7xLZPbPsr2/7Ktr9K+wfnszPvU6d4AlV2krYEkGMO",
	"tl7s/3MY+Z8cFN5/aJeWICmH2l46Kqrr09bg79xVbDknkz0Zv94J8LyOc2xAhBOV1EQkF3jNWRiicyzx",
	"HAtFbIRvfwK6lCtvNBgO9QlA+ny8dbJ/5VrglAa60kQgsti8CZLECljYq4IOMwscCshGnjMWAqbu0NOK",
	"8a4p+T0BdH09Pa+WlsnDeyMvSUiwfR1/5WZdM9ZsRevh83+8f3PUlkMV1ucVj2LTpJhkzn73E6quA7Sv",
	"aO5U1OG3LSXubBTBt6vj7VRWnrcvnu1UlnvvJJONOusdZFIqcm4tk4rK4l1kEttjyqZ1wR1T6du4wLdj",
	"Cmb3rpPdnmh7Z7ebUnkZJ0CD0Nwt/ZqZ3W4+n560sJ4XhW3MpSh9kx5uFo1LhCleQgRUnzDeEHMqn+Zz",
	"0hoU14HJWrfSM7MaSHGRYHQ2G3sd9eN8on/pq4xn+U/bnG7I9lX2aF9nvo99nz/bDptbsu1Z8cKCuC5I",
	"SqjbaLu6bo/tWmq0XU3C2HaxD/rVp+2Sy/LMpYIF3V6hxaLKfOUxKpQZ/aawVgnSnM9aC1BoSM2K1/Ey",
	"C5NBYV+SG+2EEIHnLqYAQpDw+QsWn+sGK3SpHb/QJxut4t12AjYpFxJzCYHtpDZsQolY5S3OrC4Ibotu",
	"ruOg0iG/D4d6F/d1X3+xwaXUZs5JvrYcC2euNGxzTLZ7JU6gc5/fqbjnQ7B7uZh674HQPX2ioP12XYyp",
	"7vOe/UN6AU2usaeG+d4ujv87TgZNuKbPqG7ry6Muf8oO5n1mayWKJS+2ViPAEueHhaUSBkwDpGu7OJFr",
	"5K/A/43QJQoSrv9BqdhFTVMRYx866ZA6rKmtZqisRLDs1RkQP2d7q1RdIW0TZG2d2TgEzE0xg2S6MCot",
	"dMnKHyi4IbSuW+iYUgWwBQ/6iBULg+h+CxPoV4o2HivlHivlHivlHivlHivl7q9SLq/zHtWWebtWWEHY",
	"T9ugtKb7q4mAQvF3Oekrzc1Kc9elMUJRE4UWqVN694oV38+eNbj0WgxYso/ygL3Fk9JXFbZUVtQFaaFh",
	"gyzPWyz15pAVJ+pIgLZHkFlSG0rsnd3bN7NHgsZJ230SgPqDPC2jnDiZh8RvIdwLA6Bnyr65xtJ0sx8U",
	"IkHd/Pral0Cms/fox6f9Y3R9NdbXJ4TEUaysqIqGrRbtdeQ8tzDoD4bd/kn3+PTqeDDq90f9/j+LBwiK",
	"ua7CVmVACtrWEXEQELNxXxTWgXsC4LC0/Usg34ahZuctTc9Z3Gn6nbC4aWtqAoaYkxssQW2Fdpf/TSdm",
	"DTg6JAuULyl7vmUDvr9LnsDRVwiY0FoCslcPTsRFZgQqRaDfbg5p71nNw1r8X/uwyrfRfTn3bc2O+pcm",
	"tdXPNPkcmKx4OT1e/qqO82x7u221yeUtmcsWO0d769/W/D4eUT4eUf6nHlGmq+N+vlH43Zx3up97Kp0s",
	"4mUWSOrTFv2ZJIn6jjktXoiviAjMEOlnnmoHcFAOhs4908IAg6oBZmRJ2+c/i+EvBPqMFh2enZ0fNUiM",
	"1mdBb4CTxfo+M6CKuz3Tn0UBVc4C1aF54lOQJYWgh8Ym7fV69v5dJlzJkD5qA4TR649XOtuz4ABqcy29",
	"nLl507RXli91k6S1+dA0YepkUWuTpIbTHTKkChDLhAM6fP1xliVI/Vw4jROfw3qsO+Y9L2xuLkPnJDfl",
	"ikPb7OaeCcmZwnCRJpu2IsklWJ/5sjMtm0hWBdyde4evP17phGEmhq0Di7RXy9zRD80yQx+0Jdjl2vrj",
	"VHucajtNtTqzlp0F2PQbwnOWSLNXpVlXDiIJKz48ofYLQhes7rohupzMrtDZxVRzJok0VdAX07wixxt5",
	"/V6/d6xIZTFQHBNv5J30+r0TI4yV8EY0CcO7/wsAAP//dqdp2ldjAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
