// Package model provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package model

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for KeyPoolAlgorithm.
const (
	A128CBCHS256A128GCMKW KeyPoolAlgorithm = "A128CBC-HS256/A128GCMKW"
	A128CBCHS256A128KW    KeyPoolAlgorithm = "A128CBC-HS256/A128KW"
	A128CBCHS256A192GCMKW KeyPoolAlgorithm = "A128CBC-HS256/A192GCMKW"
	A128CBCHS256A192KW    KeyPoolAlgorithm = "A128CBC-HS256/A192KW"
	A128CBCHS256A256GCMKW KeyPoolAlgorithm = "A128CBC-HS256/A256GCMKW"
	A128CBCHS256A256KW    KeyPoolAlgorithm = "A128CBC-HS256/A256KW"
	A128CBCHS256Dir       KeyPoolAlgorithm = "A128CBC-HS256/Dir"
	A128GCMA128GCMKW      KeyPoolAlgorithm = "A128GCM/A128GCMKW"
	A128GCMA128KW         KeyPoolAlgorithm = "A128GCM/A128KW"
	A128GCMA192GCMKW      KeyPoolAlgorithm = "A128GCM/A192GCMKW"
	A128GCMA192KW         KeyPoolAlgorithm = "A128GCM/A192KW"
	A128GCMA256GCMKW      KeyPoolAlgorithm = "A128GCM/A256GCMKW"
	A128GCMA256KW         KeyPoolAlgorithm = "A128GCM/A256KW"
	A128GCMDir            KeyPoolAlgorithm = "A128GCM/Dir"
	A192CBCHS384A192GCMKW KeyPoolAlgorithm = "A192CBC-HS384/A192GCMKW"
	A192CBCHS384A192KW    KeyPoolAlgorithm = "A192CBC-HS384/A192KW"
	A192CBCHS384A256GCMKW KeyPoolAlgorithm = "A192CBC-HS384/A256GCMKW"
	A192CBCHS384A256KW    KeyPoolAlgorithm = "A192CBC-HS384/A256KW"
	A192CBCHS384Dir       KeyPoolAlgorithm = "A192CBC-HS384/Dir"
	A192GCMA192GCMKW      KeyPoolAlgorithm = "A192GCM/A192GCMKW"
	A192GCMA192KW         KeyPoolAlgorithm = "A192GCM/A192KW"
	A192GCMA256GCMKW      KeyPoolAlgorithm = "A192GCM/A256GCMKW"
	A192GCMA256KW         KeyPoolAlgorithm = "A192GCM/A256KW"
	A192GCMDir            KeyPoolAlgorithm = "A192GCM/Dir"
	A256CBCHS512A256GCMKW KeyPoolAlgorithm = "A256CBC-HS512/A256GCMKW"
	A256CBCHS512A256KW    KeyPoolAlgorithm = "A256CBC-HS512/A256KW"
	A256CBCHS512Dir       KeyPoolAlgorithm = "A256CBC-HS512/Dir"
	A256GCMA256GCMKW      KeyPoolAlgorithm = "A256GCM/A256GCMKW"
	A256GCMA256KW         KeyPoolAlgorithm = "A256GCM/A256KW"
	A256GCMDir            KeyPoolAlgorithm = "A256GCM/Dir"
)

// Defines values for KeyPoolProvider.
const (
	Internal KeyPoolProvider = "Internal"
)

// Defines values for KeyPoolSort.
const (
	KeyPoolSortAlgorithmASC          KeyPoolSort = "algorithm:ASC"
	KeyPoolSortAlgorithmDESC         KeyPoolSort = "algorithm:DESC"
	KeyPoolSortExportAllowedASC      KeyPoolSort = "export_allowed:ASC"
	KeyPoolSortExportAllowedDESC     KeyPoolSort = "export_allowed:DESC"
	KeyPoolSortIdASC                 KeyPoolSort = "id:ASC"
	KeyPoolSortIdDESC                KeyPoolSort = "id:DESC"
	KeyPoolSortImportAllowedASC      KeyPoolSort = "import_allowed:ASC"
	KeyPoolSortImportAllowedDESC     KeyPoolSort = "import_allowed:DESC"
	KeyPoolSortNameASC               KeyPoolSort = "name:ASC"
	KeyPoolSortNameDESC              KeyPoolSort = "name:DESC"
	KeyPoolSortProviderASC           KeyPoolSort = "provider:ASC"
	KeyPoolSortProviderDESC          KeyPoolSort = "provider:DESC"
	KeyPoolSortStatusASC             KeyPoolSort = "status:ASC"
	KeyPoolSortStatusDESC            KeyPoolSort = "status:DESC"
	KeyPoolSortVersioningAllowedASC  KeyPoolSort = "versioning_allowed:ASC"
	KeyPoolSortVersioningAllowedDESC KeyPoolSort = "versioning_allowed:DESC"
)

// Defines values for KeyPoolStatus.
const (
	Active                         KeyPoolStatus = "active"
	Creating                       KeyPoolStatus = "creating"
	Disabled                       KeyPoolStatus = "disabled"
	FinishedDelete                 KeyPoolStatus = "finished_delete"
	GenerateFailed                 KeyPoolStatus = "generate_failed"
	ImportFailed                   KeyPoolStatus = "import_failed"
	PendingDeleteWasActive         KeyPoolStatus = "pending_delete_was_active"
	PendingDeleteWasDisabled       KeyPoolStatus = "pending_delete_was_disabled"
	PendingDeleteWasGenerateFailed KeyPoolStatus = "pending_delete_was_generate_failed"
	PendingDeleteWasImportFailed   KeyPoolStatus = "pending_delete_was_import_failed"
	PendingDeleteWasPendingImport  KeyPoolStatus = "pending_delete_was_pending_import"
	PendingGenerate                KeyPoolStatus = "pending_generate"
	PendingImport                  KeyPoolStatus = "pending_import"
	StartedDelete                  KeyPoolStatus = "started_delete"
)

// Defines values for KeySort.
const (
	KeySortGenerateDate     KeySort = "generate_date"
	KeySortGenerateDateASC  KeySort = "generate_date:ASC"
	KeySortGenerateDateDESC KeySort = "generate_date:DESC"
	KeySortId               KeySort = "id"
	KeySortIdASC            KeySort = "id:ASC"
	KeySortIdDESC           KeySort = "id:DESC"
	KeySortPool             KeySort = "pool"
	KeySortPoolASC          KeySort = "pool:ASC"
	KeySortPoolDESC         KeySort = "pool:DESC"
)

// HTTPError defines model for HTTPError.
type HTTPError struct {
	// Error HTTP status message
	Error string `json:"error"`

	// Message Detailed error message
	Message string `json:"message"`

	// Status HTTP status code
	Status int `json:"status"`
}

// Key defines model for Key.
type Key struct {
	// GenerateDate ISO 8601 UTC timestamp of Key generation.
	GenerateDate *KeyGenerateDate `json:"generate_date,omitempty"`

	// Id Unique UUID for a Key.
	Id *KeyId `json:"id,omitempty"`

	// Pool Unique UUID for a Key Pool.
	Pool *KeyPoolId `json:"pool,omitempty"`
}

// KeyGenerate defines model for KeyGenerate.
type KeyGenerate = map[string]interface{}

// KeyGenerateDate ISO 8601 UTC timestamp of Key generation.
type KeyGenerateDate = time.Time

// KeyId Unique UUID for a Key.
type KeyId = openapi_types.UUID

// KeyPool defines model for KeyPool.
type KeyPool struct {
	// Algorithm Cryptographic algorithm(s) used for Keys in the Key Pool. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'Dir', the Key Pool Key is directly used on values. Direct encryption is useful for small values. If key encryption algorithm is 'Key Wrap', a random Content Encryption Key (CEK) is used directly on values, and the Key Pool Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
	Algorithm *KeyPoolAlgorithm `json:"algorithm,omitempty"`

	// Description Description for a Key Pool.
	Description *KeyPoolDescription `json:"description,omitempty"`

	// ExportAllowed Indicates if the Key Pool supports export.
	ExportAllowed *KeyPoolExportAllowed `json:"export_allowed,omitempty"`

	// Id Unique UUID for a Key Pool.
	Id *KeyPoolId `json:"id,omitempty"`

	// ImportAllowed Indicates if the Key Pool supports import (BYOK).
	ImportAllowed *KeyPoolImportAllowed `json:"import_allowed,omitempty"`

	// Name Friendly name for a Key Pool.
	Name *KeyPoolName `json:"name,omitempty"`

	// Provider Provider of the Key Pool management service.
	Provider *KeyPoolProvider `json:"provider,omitempty"`

	// Status Status of the Key Pool.
	Status *KeyPoolStatus `json:"status,omitempty"`

	// VersioningAllowed Indicates if the Key Pool supports versioning.
	VersioningAllowed *KeyPoolVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// KeyPoolAlgorithm Cryptographic algorithm(s) used for Keys in the Key Pool. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'Dir', the Key Pool Key is directly used on values. Direct encryption is useful for small values. If key encryption algorithm is 'Key Wrap', a random Content Encryption Key (CEK) is used directly on values, and the Key Pool Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
type KeyPoolAlgorithm string

// KeyPoolCreate defines model for KeyPoolCreate.
type KeyPoolCreate struct {
	// Algorithm Cryptographic algorithm(s) used for Keys in the Key Pool. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'Dir', the Key Pool Key is directly used on values. Direct encryption is useful for small values. If key encryption algorithm is 'Key Wrap', a random Content Encryption Key (CEK) is used directly on values, and the Key Pool Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
	Algorithm *KeyPoolAlgorithm `json:"algorithm,omitempty"`

	// Description Description for a Key Pool.
	Description KeyPoolDescription `json:"description"`

	// ExportAllowed Indicates if the Key Pool supports export.
	ExportAllowed *KeyPoolExportAllowed `json:"export_allowed,omitempty"`

	// ImportAllowed Indicates if the Key Pool supports import (BYOK).
	ImportAllowed *KeyPoolImportAllowed `json:"import_allowed,omitempty"`

	// Name Friendly name for a Key Pool.
	Name KeyPoolName `json:"name"`

	// Provider Provider of the Key Pool management service.
	Provider *KeyPoolProvider `json:"provider,omitempty"`

	// VersioningAllowed Indicates if the Key Pool supports versioning.
	VersioningAllowed *KeyPoolVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// KeyPoolDescription Description for a Key Pool.
type KeyPoolDescription = string

// KeyPoolExportAllowed Indicates if the Key Pool supports export.
type KeyPoolExportAllowed = bool

// KeyPoolId Unique UUID for a Key Pool.
type KeyPoolId = openapi_types.UUID

// KeyPoolImportAllowed Indicates if the Key Pool supports import (BYOK).
type KeyPoolImportAllowed = bool

// KeyPoolKeysQueryParams defines model for KeyPoolKeysQueryParams.
type KeyPoolKeysQueryParams struct {
	Id *[]KeyId `json:"id,omitempty"`

	// MaxGenerateDate ISO 8601 UTC timestamp of Key generation.
	MaxGenerateDate *KeyGenerateDate `json:"max_generate_date,omitempty"`

	// MinGenerateDate ISO 8601 UTC timestamp of Key generation.
	MinGenerateDate *KeyGenerateDate `json:"min_generate_date,omitempty"`

	// Page Page number starting at 0.
	Page *PageNumber `json:"page,omitempty"`

	// Size Page number.
	Size *PageSize  `json:"size,omitempty"`
	Sort *[]KeySort `json:"sort,omitempty"`
}

// KeyPoolName Friendly name for a Key Pool.
type KeyPoolName = string

// KeyPoolProvider Provider of the Key Pool management service.
type KeyPoolProvider string

// KeyPoolSort defines model for KeyPoolSort.
type KeyPoolSort string

// KeyPoolStatus Status of the Key Pool.
type KeyPoolStatus string

// KeyPoolUpdate defines model for KeyPoolUpdate.
type KeyPoolUpdate struct {
	// Description Description for a Key Pool.
	Description KeyPoolDescription `json:"description"`

	// Name Friendly name for a Key Pool.
	Name KeyPoolName `json:"name"`
}

// KeyPoolVersioningAllowed Indicates if the Key Pool supports versioning.
type KeyPoolVersioningAllowed = bool

// KeyPoolsQueryParams defines model for KeyPoolsQueryParams.
type KeyPoolsQueryParams struct {
	Algorithm *[]KeyPoolAlgorithm `json:"algorithm,omitempty"`

	// ExportAllowed Indicates if the Key Pool supports export.
	ExportAllowed *KeyPoolExportAllowed `json:"export_allowed,omitempty"`
	Id            *[]KeyPoolId          `json:"id,omitempty"`

	// ImportAllowed Indicates if the Key Pool supports import (BYOK).
	ImportAllowed *KeyPoolImportAllowed `json:"import_allowed,omitempty"`
	Name          *[]KeyPoolName        `json:"name,omitempty"`

	// Page Page number starting at 0.
	Page     *PageNumber        `json:"page,omitempty"`
	Provider *[]KeyPoolProvider `json:"provider,omitempty"`

	// Size Page number.
	Size   *PageSize        `json:"size,omitempty"`
	Sort   *[]KeyPoolSort   `json:"sort,omitempty"`
	Status *[]KeyPoolStatus `json:"status,omitempty"`

	// VersioningAllowed Indicates if the Key Pool supports versioning.
	VersioningAllowed *KeyPoolVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// KeySort defines model for KeySort.
type KeySort string

// KeyUpdate defines model for KeyUpdate.
type KeyUpdate struct {
	// Id Unique UUID for a Key.
	Id KeyId `json:"id"`

	// Pool Unique UUID for a Key Pool.
	Pool KeyPoolId `json:"pool"`
}

// KeysQueryParams defines model for KeysQueryParams.
type KeysQueryParams struct {
	Id *[]KeyId `json:"id,omitempty"`

	// MaxGenerateDate ISO 8601 UTC timestamp of Key generation.
	MaxGenerateDate *KeyGenerateDate `json:"max_generate_date,omitempty"`

	// MinGenerateDate ISO 8601 UTC timestamp of Key generation.
	MinGenerateDate *KeyGenerateDate `json:"min_generate_date,omitempty"`

	// Page Page number starting at 0.
	Page *PageNumber  `json:"page,omitempty"`
	Pool *[]KeyPoolId `json:"pool,omitempty"`

	// Size Page number.
	Size *PageSize  `json:"size,omitempty"`
	Sort *[]KeySort `json:"sort,omitempty"`
}

// PageNumber Page number starting at 0.
type PageNumber = int

// PageSize Page number.
type PageSize = int

// SymmetricCipherAdditionalAuthenticatedData Base64URL-encoded Additional Authenticated Data (AAD). This is non-secret data used for authentication and integrity checking during decryption (e.g. namespace, context).
type SymmetricCipherAdditionalAuthenticatedData = string

// SymmetricCipherInitializationVector Base64URL-encoded Nonce (e.g. 12-bytes AES-GCM or AES-GCM-SIV) or Initialization Vector (e.g. 16-bytes AES-CBC). This is non-secret data used for encryption/decryption, as well as authentication and integrity checking during decryption (e.g. namespace, context).
type SymmetricCipherInitializationVector = string

// SymmetricDecryptRequest Base64Url-encoded JSON Web Encryption (JWE) of the encrypted bytes (and non-secret cipher parameters) in compact serialized format. See RFC 7516 JSON Web Encryption (JWE) for more details. Compact serialized format is 'Header.EncryptedKey.IV.Ciphertext.AuthenticationTag'. There are five Base64Url-encoded parts and separated by '.'. Some parts can be empty depending on the 'alg' and 'enc' headers parameters. - Header: Required base64Url-encoded JSON key/values for the JWE. - EncryptedKey: Optional base64Url-encoded JWE of an encrypted symmetric key used to encrypt the payload. This is non-empty for envelope encryption (e.g. alg=a256gcmkw), or empty for direct encryption (e.g. alg=dir). - IV: Required base64Url-encoded Initialization Vector (IV) used for encryption. For AES-GCM or AES-GCM-SIV it contains a 12-bytes nonce. For AES-CBC it contains a 16-bytes IV. - Ciphertext: Required base64Url-encoded encrypted secret bytes. It is always non-empty. For AES-GCM or AES-GCM-SIV it contains same number of bytes as the plaintext. - AuthenticationTag: Required base64Url-encoded authentication tag used for encryption. For AES-GCM or AES-GCM-SIV it contains a 16-bytes authentication tag. For AES-CBC-HMAC it contains a N-bytes HMAC hash.
type SymmetricDecryptRequest = string

// SymmetricDecryptResponse Encrypted text to be decrypted. If you pre-encoded bytes to text before submitting them for encryption, remember to decode to bytes; ese the same encoding scheme you chose before submission (e.g. Hexadecimal, Base64, Base64-URL, Base64-MIME, etc).
type SymmetricDecryptResponse = string

// SymmetricEncryptParams defines model for SymmetricEncryptParams.
type SymmetricEncryptParams struct {
	// Aad Base64URL-encoded Additional Authenticated Data (AAD). This is non-secret data used for authentication and integrity checking during decryption (e.g. namespace, context).
	Aad *SymmetricCipherAdditionalAuthenticatedData `json:"aad,omitempty"`

	// Iv Base64URL-encoded Nonce (e.g. 12-bytes AES-GCM or AES-GCM-SIV) or Initialization Vector (e.g. 16-bytes AES-CBC). This is non-secret data used for encryption/decryption, as well as authentication and integrity checking during decryption (e.g. namespace, context).
	Iv *SymmetricCipherInitializationVector `json:"iv,omitempty"`
}

// SymmetricEncryptRequest Clear text to be encrypted. If you need to encrypt bytes, encode them first as text (e.g. Hexadecimal, Base64, Base64-URL, Base64-MIME, etc).
type SymmetricEncryptRequest = string

// SymmetricEncryptResponse Base64Url-encoded JSON Web Encryption (JWE) of the encrypted bytes (and non-secret cipher parameters) in compact serialized format. See RFC 7516 JSON Web Encryption (JWE) for more details. Compact serialized format is 'Header.EncryptedKey.IV.Ciphertext.AuthenticationTag'. There are five Base64Url-encoded parts and separated by '.'. Some parts can be empty depending on the 'alg' and 'enc' headers parameters. - Header: Required base64Url-encoded JSON key/values for the JWE. - EncryptedKey: Optional base64Url-encoded JWE of an encrypted symmetric key used to encrypt the payload. This is non-empty for envelope encryption (e.g. alg=a256gcmkw), or empty for direct encryption (e.g. alg=dir). - IV: Required base64Url-encoded Initialization Vector (IV) used for encryption. For AES-GCM or AES-GCM-SIV it contains a 12-bytes nonce. For AES-CBC it contains a 16-bytes IV. - Ciphertext: Required base64Url-encoded encrypted secret bytes. It is always non-empty. For AES-GCM or AES-GCM-SIV it contains same number of bytes as the plaintext. - AuthenticationTag: Required base64Url-encoded authentication tag used for encryption. For AES-GCM or AES-GCM-SIV it contains a 16-bytes authentication tag. For AES-CBC-HMAC it contains a N-bytes HMAC hash.
type SymmetricEncryptResponse = string

// KeyPoolQueryParamAlgorithms defines model for KeyPoolQueryParamAlgorithms.
type KeyPoolQueryParamAlgorithms = []KeyPoolAlgorithm

// KeyPoolQueryParamExportAllowed Indicates if the Key Pool supports export.
type KeyPoolQueryParamExportAllowed = KeyPoolExportAllowed

// KeyPoolQueryParamIds defines model for KeyPoolQueryParamIds.
type KeyPoolQueryParamIds = []KeyPoolId

// KeyPoolQueryParamImportAllowed Indicates if the Key Pool supports import (BYOK).
type KeyPoolQueryParamImportAllowed = KeyPoolImportAllowed

// KeyPoolQueryParamNames defines model for KeyPoolQueryParamNames.
type KeyPoolQueryParamNames = []KeyPoolName

// KeyPoolQueryParamPageNumber Page number starting at 0.
type KeyPoolQueryParamPageNumber = PageNumber

// KeyPoolQueryParamPageSize Page number.
type KeyPoolQueryParamPageSize = PageSize

// KeyPoolQueryParamProviders defines model for KeyPoolQueryParamProviders.
type KeyPoolQueryParamProviders = []KeyPoolProvider

// KeyPoolQueryParamSorts defines model for KeyPoolQueryParamSorts.
type KeyPoolQueryParamSorts = []KeyPoolSort

// KeyPoolQueryParamStatuses defines model for KeyPoolQueryParamStatuses.
type KeyPoolQueryParamStatuses = []KeyPoolStatus

// KeyPoolQueryParamVersioningAllowed Indicates if the Key Pool supports versioning.
type KeyPoolQueryParamVersioningAllowed = KeyPoolVersioningAllowed

// KeyQueryParamIds defines model for KeyQueryParamIds.
type KeyQueryParamIds = []KeyId

// KeyQueryParamKeyPoolIds defines model for KeyQueryParamKeyPoolIds.
type KeyQueryParamKeyPoolIds = []KeyPoolId

// KeyQueryParamMaximumGenerateDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMaximumGenerateDate = KeyGenerateDate

// KeyQueryParamMinimumGenerateDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMinimumGenerateDate = KeyGenerateDate

// KeyQueryParamPageNumber Page number starting at 0.
type KeyQueryParamPageNumber = PageNumber

// KeyQueryParamPageSize Page number.
type KeyQueryParamPageSize = PageSize

// KeyQueryParamSorts defines model for KeyQueryParamSorts.
type KeyQueryParamSorts = []KeySort

// HTTP400BadRequest defines model for HTTP400BadRequest.
type HTTP400BadRequest struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP401Unauthorized defines model for HTTP401Unauthorized.
type HTTP401Unauthorized struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP403Forbidden defines model for HTTP403Forbidden.
type HTTP403Forbidden struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP404NotFound defines model for HTTP404NotFound.
type HTTP404NotFound struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP429TooManyRequests defines model for HTTP429TooManyRequests.
type HTTP429TooManyRequests struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP500InternalServerError defines model for HTTP500InternalServerError.
type HTTP500InternalServerError struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP502BadGateway defines model for HTTP502BadGateway.
type HTTP502BadGateway struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP503ServiceUnavailable defines model for HTTP503ServiceUnavailable.
type HTTP503ServiceUnavailable struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP504GatewayTimeout defines model for HTTP504GatewayTimeout.
type HTTP504GatewayTimeout struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
