// Package model provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package model

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for KeyPoolAlgorithm.
const (
	A128CBCHS256A128GCMKW    KeyPoolAlgorithm = "A128CBC-HS256/A128GCMKW"
	A128CBCHS256A128KW       KeyPoolAlgorithm = "A128CBC-HS256/A128KW"
	A128CBCHS256A192GCMKW    KeyPoolAlgorithm = "A128CBC-HS256/A192GCMKW"
	A128CBCHS256A192KW       KeyPoolAlgorithm = "A128CBC-HS256/A192KW"
	A128CBCHS256A256GCMKW    KeyPoolAlgorithm = "A128CBC-HS256/A256GCMKW"
	A128CBCHS256A256KW       KeyPoolAlgorithm = "A128CBC-HS256/A256KW"
	A128CBCHS256ECDHES       KeyPoolAlgorithm = "A128CBC-HS256/ECDH-ES"
	A128CBCHS256ECDHESA128KW KeyPoolAlgorithm = "A128CBC-HS256/ECDH-ES+A128KW"
	A128CBCHS256ECDHESA192KW KeyPoolAlgorithm = "A128CBC-HS256/ECDH-ES+A192KW"
	A128CBCHS256ECDHESA256KW KeyPoolAlgorithm = "A128CBC-HS256/ECDH-ES+A256KW"
	A128CBCHS256RSA15        KeyPoolAlgorithm = "A128CBC-HS256/RSA1_5"
	A128CBCHS256RSAOAEP      KeyPoolAlgorithm = "A128CBC-HS256/RSA-OAEP"
	A128CBCHS256RSAOAEP256   KeyPoolAlgorithm = "A128CBC-HS256/RSA-OAEP-256"
	A128CBCHS256RSAOAEP384   KeyPoolAlgorithm = "A128CBC-HS256/RSA-OAEP-384"
	A128CBCHS256RSAOAEP512   KeyPoolAlgorithm = "A128CBC-HS256/RSA-OAEP-512"
	A128CBCHS256dir          KeyPoolAlgorithm = "A128CBC-HS256/dir"
	A128GCMA128GCMKW         KeyPoolAlgorithm = "A128GCM/A128GCMKW"
	A128GCMA128KW            KeyPoolAlgorithm = "A128GCM/A128KW"
	A128GCMA192GCMKW         KeyPoolAlgorithm = "A128GCM/A192GCMKW"
	A128GCMA192KW            KeyPoolAlgorithm = "A128GCM/A192KW"
	A128GCMA256GCMKW         KeyPoolAlgorithm = "A128GCM/A256GCMKW"
	A128GCMA256KW            KeyPoolAlgorithm = "A128GCM/A256KW"
	A128GCMECDHES            KeyPoolAlgorithm = "A128GCM/ECDH-ES"
	A128GCMECDHESA128KW      KeyPoolAlgorithm = "A128GCM/ECDH-ES+A128KW"
	A128GCMECDHESA192KW      KeyPoolAlgorithm = "A128GCM/ECDH-ES+A192KW"
	A128GCMECDHESA256KW      KeyPoolAlgorithm = "A128GCM/ECDH-ES+A256KW"
	A128GCMRSA15             KeyPoolAlgorithm = "A128GCM/RSA1_5"
	A128GCMRSAOAEP           KeyPoolAlgorithm = "A128GCM/RSA-OAEP"
	A128GCMRSAOAEP256        KeyPoolAlgorithm = "A128GCM/RSA-OAEP-256"
	A128GCMRSAOAEP384        KeyPoolAlgorithm = "A128GCM/RSA-OAEP-384"
	A128GCMRSAOAEP512        KeyPoolAlgorithm = "A128GCM/RSA-OAEP-512"
	A128GCMdir               KeyPoolAlgorithm = "A128GCM/dir"
	A192CBCHS384A128GCMKW    KeyPoolAlgorithm = "A192CBC-HS384/A128GCMKW"
	A192CBCHS384A128KW       KeyPoolAlgorithm = "A192CBC-HS384/A128KW"
	A192CBCHS384A192GCMKW    KeyPoolAlgorithm = "A192CBC-HS384/A192GCMKW"
	A192CBCHS384A192KW       KeyPoolAlgorithm = "A192CBC-HS384/A192KW"
	A192CBCHS384A256GCMKW    KeyPoolAlgorithm = "A192CBC-HS384/A256GCMKW"
	A192CBCHS384A256KW       KeyPoolAlgorithm = "A192CBC-HS384/A256KW"
	A192CBCHS384ECDHES       KeyPoolAlgorithm = "A192CBC-HS384/ECDH-ES"
	A192CBCHS384ECDHESA128KW KeyPoolAlgorithm = "A192CBC-HS384/ECDH-ES+A128KW"
	A192CBCHS384ECDHESA192KW KeyPoolAlgorithm = "A192CBC-HS384/ECDH-ES+A192KW"
	A192CBCHS384ECDHESA256KW KeyPoolAlgorithm = "A192CBC-HS384/ECDH-ES+A256KW"
	A192CBCHS384RSA15        KeyPoolAlgorithm = "A192CBC-HS384/RSA1_5"
	A192CBCHS384RSAOAEP      KeyPoolAlgorithm = "A192CBC-HS384/RSA-OAEP"
	A192CBCHS384RSAOAEP256   KeyPoolAlgorithm = "A192CBC-HS384/RSA-OAEP-256"
	A192CBCHS384RSAOAEP384   KeyPoolAlgorithm = "A192CBC-HS384/RSA-OAEP-384"
	A192CBCHS384RSAOAEP512   KeyPoolAlgorithm = "A192CBC-HS384/RSA-OAEP-512"
	A192CBCHS384dir          KeyPoolAlgorithm = "A192CBC-HS384/dir"
	A192GCMA128GCMKW         KeyPoolAlgorithm = "A192GCM/A128GCMKW"
	A192GCMA128KW            KeyPoolAlgorithm = "A192GCM/A128KW"
	A192GCMA192GCMKW         KeyPoolAlgorithm = "A192GCM/A192GCMKW"
	A192GCMA192KW            KeyPoolAlgorithm = "A192GCM/A192KW"
	A192GCMA256GCMKW         KeyPoolAlgorithm = "A192GCM/A256GCMKW"
	A192GCMA256KW            KeyPoolAlgorithm = "A192GCM/A256KW"
	A192GCMECDHES            KeyPoolAlgorithm = "A192GCM/ECDH-ES"
	A192GCMECDHESA128KW      KeyPoolAlgorithm = "A192GCM/ECDH-ES+A128KW"
	A192GCMECDHESA192KW      KeyPoolAlgorithm = "A192GCM/ECDH-ES+A192KW"
	A192GCMECDHESA256KW      KeyPoolAlgorithm = "A192GCM/ECDH-ES+A256KW"
	A192GCMRSA15             KeyPoolAlgorithm = "A192GCM/RSA1_5"
	A192GCMRSAOAEP           KeyPoolAlgorithm = "A192GCM/RSA-OAEP"
	A192GCMRSAOAEP256        KeyPoolAlgorithm = "A192GCM/RSA-OAEP-256"
	A192GCMRSAOAEP384        KeyPoolAlgorithm = "A192GCM/RSA-OAEP-384"
	A192GCMRSAOAEP512        KeyPoolAlgorithm = "A192GCM/RSA-OAEP-512"
	A192GCMdir               KeyPoolAlgorithm = "A192GCM/dir"
	A256CBCHS512A128GCMKW    KeyPoolAlgorithm = "A256CBC-HS512/A128GCMKW"
	A256CBCHS512A128KW       KeyPoolAlgorithm = "A256CBC-HS512/A128KW"
	A256CBCHS512A192GCMKW    KeyPoolAlgorithm = "A256CBC-HS512/A192GCMKW"
	A256CBCHS512A192KW       KeyPoolAlgorithm = "A256CBC-HS512/A192KW"
	A256CBCHS512A256GCMKW    KeyPoolAlgorithm = "A256CBC-HS512/A256GCMKW"
	A256CBCHS512A256KW       KeyPoolAlgorithm = "A256CBC-HS512/A256KW"
	A256CBCHS512ECDHES       KeyPoolAlgorithm = "A256CBC-HS512/ECDH-ES"
	A256CBCHS512ECDHESA128KW KeyPoolAlgorithm = "A256CBC-HS512/ECDH-ES+A128KW"
	A256CBCHS512ECDHESA192KW KeyPoolAlgorithm = "A256CBC-HS512/ECDH-ES+A192KW"
	A256CBCHS512ECDHESA256KW KeyPoolAlgorithm = "A256CBC-HS512/ECDH-ES+A256KW"
	A256CBCHS512RSA15        KeyPoolAlgorithm = "A256CBC-HS512/RSA1_5"
	A256CBCHS512RSAOAEP      KeyPoolAlgorithm = "A256CBC-HS512/RSA-OAEP"
	A256CBCHS512RSAOAEP256   KeyPoolAlgorithm = "A256CBC-HS512/RSA-OAEP-256"
	A256CBCHS512RSAOAEP384   KeyPoolAlgorithm = "A256CBC-HS512/RSA-OAEP-384"
	A256CBCHS512RSAOAEP512   KeyPoolAlgorithm = "A256CBC-HS512/RSA-OAEP-512"
	A256CBCHS512dir          KeyPoolAlgorithm = "A256CBC-HS512/dir"
	A256GCMA128GCMKW         KeyPoolAlgorithm = "A256GCM/A128GCMKW"
	A256GCMA128KW            KeyPoolAlgorithm = "A256GCM/A128KW"
	A256GCMA192GCMKW         KeyPoolAlgorithm = "A256GCM/A192GCMKW"
	A256GCMA192KW            KeyPoolAlgorithm = "A256GCM/A192KW"
	A256GCMA256GCMKW         KeyPoolAlgorithm = "A256GCM/A256GCMKW"
	A256GCMA256KW            KeyPoolAlgorithm = "A256GCM/A256KW"
	A256GCMECDHES            KeyPoolAlgorithm = "A256GCM/ECDH-ES"
	A256GCMECDHESA128KW      KeyPoolAlgorithm = "A256GCM/ECDH-ES+A128KW"
	A256GCMECDHESA192KW      KeyPoolAlgorithm = "A256GCM/ECDH-ES+A192KW"
	A256GCMECDHESA256KW      KeyPoolAlgorithm = "A256GCM/ECDH-ES+A256KW"
	A256GCMRSA15             KeyPoolAlgorithm = "A256GCM/RSA1_5"
	A256GCMRSAOAEP           KeyPoolAlgorithm = "A256GCM/RSA-OAEP"
	A256GCMRSAOAEP256        KeyPoolAlgorithm = "A256GCM/RSA-OAEP-256"
	A256GCMRSAOAEP384        KeyPoolAlgorithm = "A256GCM/RSA-OAEP-384"
	A256GCMRSAOAEP512        KeyPoolAlgorithm = "A256GCM/RSA-OAEP-512"
	A256GCMdir               KeyPoolAlgorithm = "A256GCM/dir"
	ES256                    KeyPoolAlgorithm = "ES256"
	ES384                    KeyPoolAlgorithm = "ES384"
	ES512                    KeyPoolAlgorithm = "ES512"
	EdDSA                    KeyPoolAlgorithm = "EdDSA"
	HS256                    KeyPoolAlgorithm = "HS256"
	HS384                    KeyPoolAlgorithm = "HS384"
	HS512                    KeyPoolAlgorithm = "HS512"
	PS256                    KeyPoolAlgorithm = "PS256"
	PS384                    KeyPoolAlgorithm = "PS384"
	PS512                    KeyPoolAlgorithm = "PS512"
	RS256                    KeyPoolAlgorithm = "RS256"
	RS384                    KeyPoolAlgorithm = "RS384"
	RS512                    KeyPoolAlgorithm = "RS512"
)

// Defines values for KeyPoolProvider.
const (
	Internal KeyPoolProvider = "Internal"
)

// Defines values for KeyPoolSort.
const (
	KeyPoolSortAlgorithmASC          KeyPoolSort = "algorithm:ASC"
	KeyPoolSortAlgorithmDESC         KeyPoolSort = "algorithm:DESC"
	KeyPoolSortExportAllowedASC      KeyPoolSort = "export_allowed:ASC"
	KeyPoolSortExportAllowedDESC     KeyPoolSort = "export_allowed:DESC"
	KeyPoolSortIdASC                 KeyPoolSort = "id:ASC"
	KeyPoolSortIdDESC                KeyPoolSort = "id:DESC"
	KeyPoolSortImportAllowedASC      KeyPoolSort = "import_allowed:ASC"
	KeyPoolSortImportAllowedDESC     KeyPoolSort = "import_allowed:DESC"
	KeyPoolSortNameASC               KeyPoolSort = "name:ASC"
	KeyPoolSortNameDESC              KeyPoolSort = "name:DESC"
	KeyPoolSortProviderASC           KeyPoolSort = "provider:ASC"
	KeyPoolSortProviderDESC          KeyPoolSort = "provider:DESC"
	KeyPoolSortStatusASC             KeyPoolSort = "status:ASC"
	KeyPoolSortStatusDESC            KeyPoolSort = "status:DESC"
	KeyPoolSortVersioningAllowedASC  KeyPoolSort = "versioning_allowed:ASC"
	KeyPoolSortVersioningAllowedDESC KeyPoolSort = "versioning_allowed:DESC"
)

// Defines values for KeyPoolStatus.
const (
	Active                         KeyPoolStatus = "active"
	Creating                       KeyPoolStatus = "creating"
	Disabled                       KeyPoolStatus = "disabled"
	FinishedDelete                 KeyPoolStatus = "finished_delete"
	GenerateFailed                 KeyPoolStatus = "generate_failed"
	ImportFailed                   KeyPoolStatus = "import_failed"
	PendingDeleteWasActive         KeyPoolStatus = "pending_delete_was_active"
	PendingDeleteWasDisabled       KeyPoolStatus = "pending_delete_was_disabled"
	PendingDeleteWasGenerateFailed KeyPoolStatus = "pending_delete_was_generate_failed"
	PendingDeleteWasImportFailed   KeyPoolStatus = "pending_delete_was_import_failed"
	PendingDeleteWasPendingImport  KeyPoolStatus = "pending_delete_was_pending_import"
	PendingGenerate                KeyPoolStatus = "pending_generate"
	PendingImport                  KeyPoolStatus = "pending_import"
	StartedDelete                  KeyPoolStatus = "started_delete"
)

// Defines values for KeySort.
const (
	KeySortGenerateDate     KeySort = "generate_date"
	KeySortGenerateDateASC  KeySort = "generate_date:ASC"
	KeySortGenerateDateDESC KeySort = "generate_date:DESC"
	KeySortId               KeySort = "id"
	KeySortIdASC            KeySort = "id:ASC"
	KeySortIdDESC           KeySort = "id:DESC"
	KeySortPool             KeySort = "pool"
	KeySortPoolASC          KeySort = "pool:ASC"
	KeySortPoolDESC         KeySort = "pool:DESC"
)

// DecryptRequest Base64Url-encoded JSON Web Encryption (JWE) of the encrypted bytes (and non-secret cipher parameters) in compact serialized format. See RFC 7516 JSON Web Encryption (JWE) for more details. Compact serialized format is 'Header.EncryptedKey.IV.Ciphertext.AuthenticationTag'. There are five Base64Url-encoded parts and separated by '.'. Some parts can be empty depending on the 'alg' and 'enc' headers parameters. - Header: Required base64Url-encoded JSON key/values for the JWE. - EncryptedKey: Optional base64Url-encoded JWE of an encrypted symmetric key used to encrypt the payload. This is non-empty for envelope encryption (e.g. alg=a256gcmkw), or empty for direct encryption (e.g. alg=dir). - IV: Required base64Url-encoded Initialization Vector (IV) used for encryption. For AES-GCM or AES-GCM-SIV it contains a 12-bytes nonce. For AES-CBC it contains a 16-bytes IV. - Ciphertext: Required base64Url-encoded encrypted secret bytes. It is always non-empty. For AES-GCM or AES-GCM-SIV it contains same number of bytes as the plaintext. - AuthenticationTag: Required base64Url-encoded authentication tag used for encryption. For AES-GCM or AES-GCM-SIV it contains a 16-bytes authentication tag. For AES-CBC-HMAC it contains a N-bytes HMAC hash.
type DecryptRequest = string

// DecryptResponse Decrypted text. If you pre-encoded bytes to text before submitting them for encryption, remember to decode to bytes; use the same encoding scheme you chose before submission (e.g. Hexadecimal, Base64, Base64-URL, Base64-MIME, etc).
type DecryptResponse = string

// EncryptContext Base64URL-encoded context. This is non-secret data used for authentication and integrity checking during decryption (e.g. namespace, context).
type EncryptContext = string

// EncryptParams defines model for EncryptParams.
type EncryptParams struct {
	// Context Base64URL-encoded context. This is non-secret data used for authentication and integrity checking during decryption (e.g. namespace, context).
	Context *EncryptContext `json:"context,omitempty"`
}

// EncryptRequest Clear text to be encrypted. If you need to encrypt bytes, encode them first as text (e.g. Hexadecimal, Base64, Base64-URL, Base64-MIME, etc).
type EncryptRequest = string

// EncryptResponse Base64Url-encoded JSON Web Encryption (JWE) of the encrypted bytes (and non-secret cipher parameters) in compact serialized format. See RFC 7516 JSON Web Encryption (JWE) for more details. Compact serialized format is 'Header.EncryptedKey.IV.Ciphertext.AuthenticationTag'. There are five Base64Url-encoded parts and separated by '.'. Some parts can be empty depending on the 'alg' and 'enc' headers parameters. - Header: Required base64Url-encoded JSON key/values for the JWE. - EncryptedKey: Optional base64Url-encoded JWE of an encrypted symmetric key used to encrypt the payload. This is non-empty for envelope encryption (e.g. alg=a256gcmkw), or empty for direct encryption (e.g. alg=dir). - IV: Required base64Url-encoded Initialization Vector (IV) used for encryption. For AES-GCM or AES-GCM-SIV it contains a 12-bytes nonce. For AES-CBC it contains a 16-bytes IV. - Ciphertext: Required base64Url-encoded encrypted secret bytes. It is always non-empty. For AES-GCM or AES-GCM-SIV it contains same number of bytes as the plaintext. - AuthenticationTag: Required base64Url-encoded authentication tag used for encryption. For AES-GCM or AES-GCM-SIV it contains a 16-bytes authentication tag. For AES-CBC-HMAC it contains a N-bytes HMAC hash.
type EncryptResponse = string

// HTTPError defines model for HTTPError.
type HTTPError struct {
	// Error HTTP status message
	Error string `json:"error"`

	// Message Detailed error message
	Message string `json:"message"`

	// Status HTTP status code
	Status int `json:"status"`
}

// Key defines model for Key.
type Key struct {
	// GenerateDate ISO 8601 UTC timestamp of Key generation.
	GenerateDate *KeyGenerateDate `json:"generate_date,omitempty"`

	// Id Unique UUID for a Key.
	Id *KeyId `json:"id,omitempty"`

	// Pool Unique UUID for a Key Pool.
	Pool *KeyPoolId `json:"pool,omitempty"`
}

// KeyGenerate defines model for KeyGenerate.
type KeyGenerate = map[string]interface{}

// KeyGenerateDate ISO 8601 UTC timestamp of Key generation.
type KeyGenerateDate = time.Time

// KeyId Unique UUID for a Key.
type KeyId = openapi_types.UUID

// KeyPool defines model for KeyPool.
type KeyPool struct {
	// Algorithm Cryptographic algorithm(s) used for Keys in the Key Pool. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'dir', the Key Pool Key is directly used on values. direct encryption is useful for small values. If key encryption algorithm is 'K*W', a random Content Encryption Key (CEK) is used directly on values, and the Key Pool Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
	Algorithm *KeyPoolAlgorithm `json:"algorithm,omitempty"`

	// Description Description for a Key Pool.
	Description *KeyPoolDescription `json:"description,omitempty"`

	// ExportAllowed Indicates if the Key Pool supports export.
	ExportAllowed *KeyPoolExportAllowed `json:"export_allowed,omitempty"`

	// Id Unique UUID for a Key Pool.
	Id *KeyPoolId `json:"id,omitempty"`

	// ImportAllowed Indicates if the Key Pool supports import (BYOK).
	ImportAllowed *KeyPoolImportAllowed `json:"import_allowed,omitempty"`

	// Name Friendly name for a Key Pool.
	Name *KeyPoolName `json:"name,omitempty"`

	// Provider Provider of the Key Pool management service.
	Provider *KeyPoolProvider `json:"provider,omitempty"`

	// Status Status of the Key Pool.
	Status *KeyPoolStatus `json:"status,omitempty"`

	// VersioningAllowed Indicates if the Key Pool supports versioning.
	VersioningAllowed *KeyPoolVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// KeyPoolAlgorithm Cryptographic algorithm(s) used for Keys in the Key Pool. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'dir', the Key Pool Key is directly used on values. direct encryption is useful for small values. If key encryption algorithm is 'K*W', a random Content Encryption Key (CEK) is used directly on values, and the Key Pool Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
type KeyPoolAlgorithm string

// KeyPoolCreate defines model for KeyPoolCreate.
type KeyPoolCreate struct {
	// Algorithm Cryptographic algorithm(s) used for Keys in the Key Pool. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'dir', the Key Pool Key is directly used on values. direct encryption is useful for small values. If key encryption algorithm is 'K*W', a random Content Encryption Key (CEK) is used directly on values, and the Key Pool Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
	Algorithm *KeyPoolAlgorithm `json:"algorithm,omitempty"`

	// Description Description for a Key Pool.
	Description KeyPoolDescription `json:"description"`

	// ExportAllowed Indicates if the Key Pool supports export.
	ExportAllowed *KeyPoolExportAllowed `json:"export_allowed,omitempty"`

	// ImportAllowed Indicates if the Key Pool supports import (BYOK).
	ImportAllowed *KeyPoolImportAllowed `json:"import_allowed,omitempty"`

	// Name Friendly name for a Key Pool.
	Name KeyPoolName `json:"name"`

	// Provider Provider of the Key Pool management service.
	Provider *KeyPoolProvider `json:"provider,omitempty"`

	// VersioningAllowed Indicates if the Key Pool supports versioning.
	VersioningAllowed *KeyPoolVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// KeyPoolDescription Description for a Key Pool.
type KeyPoolDescription = string

// KeyPoolExportAllowed Indicates if the Key Pool supports export.
type KeyPoolExportAllowed = bool

// KeyPoolId Unique UUID for a Key Pool.
type KeyPoolId = openapi_types.UUID

// KeyPoolImportAllowed Indicates if the Key Pool supports import (BYOK).
type KeyPoolImportAllowed = bool

// KeyPoolKeysQueryParams defines model for KeyPoolKeysQueryParams.
type KeyPoolKeysQueryParams struct {
	Id *[]KeyId `json:"id,omitempty"`

	// MaxGenerateDate ISO 8601 UTC timestamp of Key generation.
	MaxGenerateDate *KeyGenerateDate `json:"max_generate_date,omitempty"`

	// MinGenerateDate ISO 8601 UTC timestamp of Key generation.
	MinGenerateDate *KeyGenerateDate `json:"min_generate_date,omitempty"`

	// Page Page number starting at 0.
	Page *PageNumber `json:"page,omitempty"`

	// Size Page number.
	Size *PageSize  `json:"size,omitempty"`
	Sort *[]KeySort `json:"sort,omitempty"`
}

// KeyPoolName Friendly name for a Key Pool.
type KeyPoolName = string

// KeyPoolProvider Provider of the Key Pool management service.
type KeyPoolProvider string

// KeyPoolSort defines model for KeyPoolSort.
type KeyPoolSort string

// KeyPoolStatus Status of the Key Pool.
type KeyPoolStatus string

// KeyPoolUpdate defines model for KeyPoolUpdate.
type KeyPoolUpdate struct {
	// Description Description for a Key Pool.
	Description KeyPoolDescription `json:"description"`

	// Name Friendly name for a Key Pool.
	Name KeyPoolName `json:"name"`
}

// KeyPoolVersioningAllowed Indicates if the Key Pool supports versioning.
type KeyPoolVersioningAllowed = bool

// KeyPoolsQueryParams defines model for KeyPoolsQueryParams.
type KeyPoolsQueryParams struct {
	Algorithm *[]KeyPoolAlgorithm `json:"algorithm,omitempty"`

	// ExportAllowed Indicates if the Key Pool supports export.
	ExportAllowed *KeyPoolExportAllowed `json:"export_allowed,omitempty"`
	Id            *[]KeyPoolId          `json:"id,omitempty"`

	// ImportAllowed Indicates if the Key Pool supports import (BYOK).
	ImportAllowed *KeyPoolImportAllowed `json:"import_allowed,omitempty"`
	Name          *[]KeyPoolName        `json:"name,omitempty"`

	// Page Page number starting at 0.
	Page     *PageNumber        `json:"page,omitempty"`
	Provider *[]KeyPoolProvider `json:"provider,omitempty"`

	// Size Page number.
	Size   *PageSize        `json:"size,omitempty"`
	Sort   *[]KeyPoolSort   `json:"sort,omitempty"`
	Status *[]KeyPoolStatus `json:"status,omitempty"`

	// VersioningAllowed Indicates if the Key Pool supports versioning.
	VersioningAllowed *KeyPoolVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// KeySort defines model for KeySort.
type KeySort string

// KeyUpdate defines model for KeyUpdate.
type KeyUpdate struct {
	// Id Unique UUID for a Key.
	Id KeyId `json:"id"`

	// Pool Unique UUID for a Key Pool.
	Pool KeyPoolId `json:"pool"`
}

// KeysQueryParams defines model for KeysQueryParams.
type KeysQueryParams struct {
	Id *[]KeyId `json:"id,omitempty"`

	// MaxGenerateDate ISO 8601 UTC timestamp of Key generation.
	MaxGenerateDate *KeyGenerateDate `json:"max_generate_date,omitempty"`

	// MinGenerateDate ISO 8601 UTC timestamp of Key generation.
	MinGenerateDate *KeyGenerateDate `json:"min_generate_date,omitempty"`

	// Page Page number starting at 0.
	Page *PageNumber  `json:"page,omitempty"`
	Pool *[]KeyPoolId `json:"pool,omitempty"`

	// Size Page number.
	Size *PageSize  `json:"size,omitempty"`
	Sort *[]KeySort `json:"sort,omitempty"`
}

// PageNumber Page number starting at 0.
type PageNumber = int

// PageSize Page number.
type PageSize = int

// SignContext Base64URL-encoded context Authenticated Data (AAD). This is non-secret data used for integrity checking during verify (e.g. namespace, context).
type SignContext = string

// SignParams defines model for SignParams.
type SignParams struct {
	// Context Base64URL-encoded context Authenticated Data (AAD). This is non-secret data used for integrity checking during verify (e.g. namespace, context).
	Context *SignContext `json:"context,omitempty"`
}

// SignRequest Clear text to be signed. Can be JSON-encoded to create a JWT, or freeform to create a JWS. If you need freeform, encode as text (e.g. Base64-URL, Base64-MIME, Base64, Hexadecimal, etc).
type SignRequest = string

// SignResponse Base64Url-encoded JSON Web Signature (JWS) of the clear text in compact serialized format. See RFC 7515 JSON Web Signature (JWS) for more details. Compact serialized format is 'Header.Payload.Signature'. There are three Base64Url-encoded parts and separated by '.'. - Header: Required base64Url-encoded JSON key/values for the JWS. - Plaintext: Required base64Url-encoded clear text. It is always non-empty. Can be freeform (JWS) or JSON-encoded (JWT). - Signature: Required base64Url-encoded signature.
type SignResponse = string

// VerifyRequest Base64Url-encoded JSON Web Signature (JWS) of the clear text in compact serialized format. See RFC 7515 JSON Web Signature (JWS) for more details. Compact serialized format is 'Header.Payload.Signature'. There are three Base64Url-encoded parts and separated by '.'. - Header: Required base64Url-encoded JSON key/values for the JWS. - Plaintext: Required base64Url-encoded clear text. It is always non-empty. Can be freeform (JWS) or JSON-encoded (JWT). - Signature: Required base64Url-encoded signature.
type VerifyRequest = string

// VerifyResponse Optional message about verification result
type VerifyResponse = string

// KeyPoolQueryParamAlgorithms defines model for KeyPoolQueryParamAlgorithms.
type KeyPoolQueryParamAlgorithms = []KeyPoolAlgorithm

// KeyPoolQueryParamExportAllowed Indicates if the Key Pool supports export.
type KeyPoolQueryParamExportAllowed = KeyPoolExportAllowed

// KeyPoolQueryParamIds defines model for KeyPoolQueryParamIds.
type KeyPoolQueryParamIds = []KeyPoolId

// KeyPoolQueryParamImportAllowed Indicates if the Key Pool supports import (BYOK).
type KeyPoolQueryParamImportAllowed = KeyPoolImportAllowed

// KeyPoolQueryParamNames defines model for KeyPoolQueryParamNames.
type KeyPoolQueryParamNames = []KeyPoolName

// KeyPoolQueryParamPageNumber Page number starting at 0.
type KeyPoolQueryParamPageNumber = PageNumber

// KeyPoolQueryParamPageSize Page number.
type KeyPoolQueryParamPageSize = PageSize

// KeyPoolQueryParamProviders defines model for KeyPoolQueryParamProviders.
type KeyPoolQueryParamProviders = []KeyPoolProvider

// KeyPoolQueryParamSorts defines model for KeyPoolQueryParamSorts.
type KeyPoolQueryParamSorts = []KeyPoolSort

// KeyPoolQueryParamStatuses defines model for KeyPoolQueryParamStatuses.
type KeyPoolQueryParamStatuses = []KeyPoolStatus

// KeyPoolQueryParamVersioningAllowed Indicates if the Key Pool supports versioning.
type KeyPoolQueryParamVersioningAllowed = KeyPoolVersioningAllowed

// KeyQueryParamIds defines model for KeyQueryParamIds.
type KeyQueryParamIds = []KeyId

// KeyQueryParamKeyPoolIds defines model for KeyQueryParamKeyPoolIds.
type KeyQueryParamKeyPoolIds = []KeyPoolId

// KeyQueryParamMaximumGenerateDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMaximumGenerateDate = KeyGenerateDate

// KeyQueryParamMinimumGenerateDate ISO 8601 UTC timestamp of Key generation.
type KeyQueryParamMinimumGenerateDate = KeyGenerateDate

// KeyQueryParamPageNumber Page number starting at 0.
type KeyQueryParamPageNumber = PageNumber

// KeyQueryParamPageSize Page number.
type KeyQueryParamPageSize = PageSize

// KeyQueryParamSorts defines model for KeyQueryParamSorts.
type KeyQueryParamSorts = []KeySort

// HTTP400BadRequest defines model for HTTP400BadRequest.
type HTTP400BadRequest struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP401Unauthorized defines model for HTTP401Unauthorized.
type HTTP401Unauthorized struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP403Forbidden defines model for HTTP403Forbidden.
type HTTP403Forbidden struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP404NotFound defines model for HTTP404NotFound.
type HTTP404NotFound struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP429TooManyRequests defines model for HTTP429TooManyRequests.
type HTTP429TooManyRequests struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP500InternalServerError defines model for HTTP500InternalServerError.
type HTTP500InternalServerError struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP502BadGateway defines model for HTTP502BadGateway.
type HTTP502BadGateway struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP503ServiceUnavailable defines model for HTTP503ServiceUnavailable.
type HTTP503ServiceUnavailable struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP504GatewayTimeout defines model for HTTP504GatewayTimeout.
type HTTP504GatewayTimeout struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w8a3PbOJJ/BcWbKts7kiLLli/R1n1wZCVRPE58lh3X7kwuA5EtCTskwAFAx5op//cr",
	"PPgARWoo2tnkrvLFJgF0o1/oboAN/en5LIoZBSqFN/rTizHHEUjg+u0c1peMhf+dAF9fqp7TcMk4katI",
	"dwcgfE5iSRj1Rt4rEkrgaL5GPl/Hki05jlfERziF6XkdD+7jkAXgjSRPoOMRBfi7Qu91PIoj8EZeNt7r",
	"eMJfQYTVXESCmfQHDgtv5P3Hs5zwZ2aYeGbpzaj0HjqeXMcaK+d4rd6FXIeqYcG47t/gcXIfMy5Pw5B9",
	"hmAbm59XIFfAEWgARATCBkgxWsWZGfjJjnLYa8CVS9dDFenTYKte5ArQOayRAkLTM7R/czM9O2ioFhK0",
	"1sc0aKWIabSjIkjUUBFmYFtFuHRVKuIdjqC5KhRVDbWg/7XVg6KqlSYu8RLeJdEcuJ6ygq4YL6GxHAvo",
	"Huqmm5E/oG4yofp2mUwjq56KszsSWHdXp6xMUbEd3VBZ6fDWCkupa6W0GeOygq1ZDD5ZrJFgXBK6RFig",
	"XxcEwkBZxyggHHw18le0D71lr4N+VcyMsPB/PeihK4gBS5RFCbRgHEVJKEkcgkaJNC7RUEIKorV0FIPt",
	"JCOxTMQOC1RogKY86cHtuTLgbfj6AFwQRgld7uA07zKgBo4zH9zWeW7SaNflzlFsevZlI1fjqJVTnsW7",
	"3cJwkpCgaRiOGQu/fCDOWbrA9yRKotdAgWMJZ1hCE94iA4aWFg4F6s8+oX6YCHIHB3UWFuH7TynQJwW0",
	"i4E5VG7Y1QWhrVgxYC1YIfRLsfLFA/K/KRg/fbQiwTcXq5rFqYeOx0HEjNrA9Ob6+vK433+Jgyv4PQEh",
	"VaPPqASqH3Ech8THivtn/xJKWH8WaMNh+H7hjX7eTpyaY8I5UwnGnypdiYFLYuYH3a4e7nEUa0Jf4gCl",
	"xGTsCMkJXSp+IhBCWZ0Dc70CxA0M8lkSBogyieaAEqrSLslYgBhHn7FAERFC6VgNJxyCXHVaRRvz2UBb",
	"nO643+941vekb2b52jeLhFAJS2vttonN/wW+9B4+PqhG1wqLjD90rGoObyhO5Ipx8oeJtF9XOQ41TbVz",
	"msgVUGlJRQtMQtD6SARwFDAQWl0rfAcoBq41xKjQS0n5xwCE1hTWq7C5lg4dLR06WjpsqyVHApmajl4x",
	"PidBAPTr6ygnpaWCROL7AAEEaJ5IrQGcD4CgSm3Y90EIJJkezkGwhPvQXFVHjqqOHFUdtVVVLohMT8fv",
	"mHzFEvoNLKV3TCJDSgsvB0EmZNfhLRTG5nI/duR+7Mj9uK3cc85SuQ9eXDN2gena+jfx9cV/zRhSFKGM",
	"pKZq+AdLjNELoBJJxlCk8FjNCEQowmhJ7oAiHLGESsQWSJKo+XIYvCiqRb9lalFv7dSyybFVz7Dfn1IJ",
	"nOJwBvwO+CQV19dVUUoUMlQhA9rYqVGUULiPwVerRaNHzPcTrkIJo9pRCY24qV6GTtwfOnF/2D7uV7OZ",
	"6WbwEgevsYTPeP1tJGcpMbu4LSNoxMEHcqdCOUWE3uGQaD+m81G04CzSWkliITngaGf1DBz1DBz1DB6T",
	"lqUsZ0o5UroiPtxQfIdJiOchfH3lWJpQkagWSiIC6VVCZbhGCVVoVGBfYRqop0KqHSS6R0IUM475GrE7",
	"4CHDOrmLsBI0xbR5HjB08oChkwcM2+cBVXLJNHlsdXtNImDJN7D/sfSglKAWGgyIyQfsckNYh59w/ZRr",
	"7djR1LGjqdaZQ5l3NcKKUU1/BvqjX2GrWl6qAk6Ob3jYBeozlcC+nb1/h25hjiZUg6r0dv/t7eRAx+QV",
	"IDDtKtddSxBoH1MlO9oV4HOQyCfxCnhhk3ig4rvSMvalEhrBodoKqM1KhGUPzQDQ1asx+s/h4cmW6fUx",
	"AeNqcyMxCUUPjetwqgW59wZwALw3Sck9h3Vv+qE31uRJuJc9N4m/xsu9HrpeAQeEOaCFsoNN+cSYS4EU",
	"zwIUj0YQaK+310MzFoEd4GOqkkuIYrlGAcRAA7WHtlF0D4fLPY1kD6i/h1aaVlHcWaMuMhyMdPaht3Pz",
	"am39ButndzhMIN8Avr2dKAxF5kfovRYnDqvw3E6UfjEtqFesowgkJ76aQG1hAuW6bL+eJcZr5buU1IhQ",
	"QldmYFhWhAC9g5DFmcloXUJv2UM4XP4XHgxPln702+eDjnJ+OZg5PaoGCgg/UIxNP2wVy5QSqU3CbM8+",
	"gC8ZR/vTDweGD0Ndir+HXjGOTiez7uvxBcofu7PpB0QkUt4NEyoQRoeDrrF6ypSXzgDHL8flkSd25PSD",
	"Ijg3u62EF6RvVpPG0UNT+/n0M14XpNyYcIEjQFSfJCo1G8KwMEoMddi5l4rMjSWxlVrs7oIlXj5WvKnQ",
	"NjE7su6+uTgtC/ydBdVdKyxWvV/Ufj7GUiWL3sj7n59Pu//E3T/63Refuh9//OWXntPwt3JDgxE/VDn/",
	"zOeayLHpdO0AtZ602KcLtGYJijlkkjWs6EzhXu1SF8rxiWQeEanPW+UKopKYO4hDBFrFkqEAFCL1pFH9",
	"XSnGJPDKFPQ0Co8OFaCn91dMgDOVPlSyi+8N3OMAfBLhsGO9Yvq/e3P1U/Z8Mb2YdBBI/6AyMFqHNGba",
	"4mrj0dVPmSR8Zo2z6GPs4giwxLnFlWxGeVcdTDmRa+SvwP9NcRwkXP+DknehOAIRYx866ZSag1rz+WEL",
	"e/rk3NTtOLmLn7O9Lf0pCakiE8hmqg3s4xAwN9ajbKAQtjN7o+B6dG0oHWMbYC2McCG1o1CIvoQl1K+S",
	"76nJ99Tke2ryPTX5npo8XWqSb6xHtftq1wsrCFtng9JNtN65/gR0KVfe6HD7bruc+UjzKcscLjZGmO+n",
	"66lTeveKW+wXLxp8ZUw/anqjn/MKIbDHpil9HysC8DmsN4XolhXsWk3Q8UjQuABGF5w0Ly95qGYhJUCf",
	"zQQBMV74ssDUAocCtgNXV2xMZ+/R85P+Ibq5HuvTFCFxFKs1fg7rtGrDfp3Mz2QG/cGw2z/qHh5fHw5G",
	"/f6o3/+n1/FM8PRGnhJsV2GrMm8jnA1Kbij5PQF0czM9M4mioqBXxJokJKhBeGnl7Co6L4ZuUfrsUNcI",
	"/KwA8dApFyy3qlNuaGx5eVKpOLdVTW5atLFTWWxWrrl7cWbuN3aq8Ksop3tMFV3V2nGNYjN9ry7V3xeF",
	"LOEc1vrTWbFuTWeJNm0nJojas9li0pLh6+hEz3zX8ZnaMBkYlqZjKr2qAtSbiLpOneMGhO913Jo69UCE",
	"TaJCm7cxikyC2KvIrohQgxZJqBkWEQ7DbPRfEXD+t9u9DsKIYxqwCI2tGArJu6Jnfzw5P7DzBDlpGVW5",
	"hMpsVGWd48l5T/d/5jguUR9ivgSL1aaNCxKqGeYhmwu7VVJsEYoClsxlR6URRKVIC72TV1v4vdPB8OT1",
	"+OKZ+n9+u2ccWiaWv1sQUwSywEkotX+lKgb+7LnAXsc7PXwxKDUMnrsNKcjhi4ELkjdYkKwhAxk8L4Fk",
	"DSlI2lAg7PX4YoO2vC0nL2srULgB67TldG7C6r4NajdhC20WNiC8AJW+mfH2zY68mp12359OLrvDw0EB",
	"ZKPZwJaby0iOnh9XIUmbS0hscxnJYHhShSRtLiGxzSUkFQgqgF3Aw09DFyxtyIBsgwWZjM/edCezHzcs",
	"t6LDoNjsKKMqW3RFRwlV2cLzjpKlV3SUUZUs33Zs4tgEtlB6szEbHg7c5Wyaj54fu4vaNA+GJ+7SLiAp",
	"iqOApCiMApKiKIpICoIoIimIoYikIASXneJidDkqLkmXqeLCdPmqwVZyDi53ddhcR+HyWIfNdRo5ttx1",
	"5HhyB5JjyN1IDlvhTHIkFS4lx1bhWCrQ5u6lAm3uZCrQ5q6mAm3ucCrQ5m6nAm3ufDbR1qKsRVeFKndK",
	"DqLcNTlocgeVI6l0UzmySmeVI610WRXIq1dqpfuqQF69citdWRXyypVc6dY2kNdhrUPndbyrmVH71cxY",
	"1dXMGO2lbb+07Ze2fWLbJ7Z9Ytvf2PY3tv1NOj44m52qDX6hDKqcJNVtC8cc7M73/+Hm8P/gbu+Jt23F",
	"oyF7v7OonI/1G7szV4flM7DsLT+NMJs35yREH1xnm46aDcclXnMWhugMSzzHwh6ApUdpg+HwL4/WKg1g",
	"8zCHBrqUWSCyKN3BS2IFKex1a4cH9+xozlgImBYmbXxYk4mn6YnNX9xRbsCOvbS8//If788PduJK7cvz",
	"CzQVnwHNwcvj7rtt3sfa/bRx8yLU7jhie87b9BpTx1xManwfqWPu9zz6Ws+WY5h31kmVSuE5ARqEa/1h",
	"eOtC3b4GT46aLsHLgudzaUl70u+cmbVGmOIlRED1l8Y7YgoH091+WibrhrestZ6SmRV5iogEo9PZ2Ouo",
	"h7OJftK3j0/zR9ucem/blb3a7iwy2v783Q7YdOF2ZEWHBXEjVUqo22iHuqHRDi012qHm5NAOsS+66+MW",
	"sdV8pTDtZeUVNeWrTEIhyyg3V36UCM3n2U+mvdCQrlyvk392yKCwL8mdjlhE4LmLKYAQJHz6jMWnuskK",
	"Q2rnL4zJZqvo207AJuVCYi4hsIOUyyeUiFXe4hhzQXB1WrmJg8os7dGJ1s7JzaNyigaXyBtEtXwZOT7M",
	"3K6sjWjbw5mT7j7Z78E85TeOx9/Fftp0+Cl+HGT3wFvMrJ/s1y6+cDDf/nsSqbt9mt9x+Dd89SkHVvur",
	"AepfGjHVYxrZAhNyy7G3fHndebej3bZtkavOP37Rb9FFP2iFQII69/c9m96yqK3on+DnJr6ZvNz9FYVS",
	"KoyXWbmQThX0rw9I1HfiWfGeWUXdh5ki/fWE2gkclIOhc32jMMGgaoIZWdLdq1yLRU4Q6B0F2j89PTto",
	"UP5aX+t6B5ws1k9Z56q4e2SRa1FAlVagBjQvbxVkSSHoobEpbnw7e/8uE65kSOeJgDB6e3uta/oWHGDB",
	"eFTqnLnVsemorCrWLYWtrXpNy2KdWtnaUljDaYs6WAWIZcIB7b+9nWVlsH4unMblrcN6rC2rWy9tBWaG",
	"zilhlSsOu9awPrLsdKYwXKYlhVuR5BKsr2+0lpYZklUBd21v/+3ttS4LzcSwdWKRjtqxQvDHZvV/H7Qn",
	"aHMb7LupfTe1VqZW59ayim9bZInwnCXSxKq0tpaDSMKK+5wqXhC6YHV1U+hqMrtGp5dTzZkk0nzXuZzm",
	"B0neyOv3+r1DRSqLgeKYeCPvqNfvHRlhrIQ3okkYPvxvAAAA//8AHYdJi1UAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
