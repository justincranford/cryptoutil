// Package model provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1-0.20250618140738-aae687ce8fe9 DO NOT EDIT.
package model

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ElasticKeyAlgorithm.
const (
	A128CBCHS256A128GCMKW    ElasticKeyAlgorithm = "A128CBC-HS256/A128GCMKW"
	A128CBCHS256A128KW       ElasticKeyAlgorithm = "A128CBC-HS256/A128KW"
	A128CBCHS256A192GCMKW    ElasticKeyAlgorithm = "A128CBC-HS256/A192GCMKW"
	A128CBCHS256A192KW       ElasticKeyAlgorithm = "A128CBC-HS256/A192KW"
	A128CBCHS256A256GCMKW    ElasticKeyAlgorithm = "A128CBC-HS256/A256GCMKW"
	A128CBCHS256A256KW       ElasticKeyAlgorithm = "A128CBC-HS256/A256KW"
	A128CBCHS256Dir          ElasticKeyAlgorithm = "A128CBC-HS256/dir"
	A128CBCHS256ECDHES       ElasticKeyAlgorithm = "A128CBC-HS256/ECDH-ES"
	A128CBCHS256ECDHESA128KW ElasticKeyAlgorithm = "A128CBC-HS256/ECDH-ES+A128KW"
	A128CBCHS256ECDHESA192KW ElasticKeyAlgorithm = "A128CBC-HS256/ECDH-ES+A192KW"
	A128CBCHS256ECDHESA256KW ElasticKeyAlgorithm = "A128CBC-HS256/ECDH-ES+A256KW"
	A128CBCHS256RSA15        ElasticKeyAlgorithm = "A128CBC-HS256/RSA1_5"
	A128CBCHS256RSAOAEP      ElasticKeyAlgorithm = "A128CBC-HS256/RSA-OAEP"
	A128CBCHS256RSAOAEP256   ElasticKeyAlgorithm = "A128CBC-HS256/RSA-OAEP-256"
	A128CBCHS256RSAOAEP384   ElasticKeyAlgorithm = "A128CBC-HS256/RSA-OAEP-384"
	A128CBCHS256RSAOAEP512   ElasticKeyAlgorithm = "A128CBC-HS256/RSA-OAEP-512"
	A128GCMA128GCMKW         ElasticKeyAlgorithm = "A128GCM/A128GCMKW"
	A128GCMA128KW            ElasticKeyAlgorithm = "A128GCM/A128KW"
	A128GCMA192GCMKW         ElasticKeyAlgorithm = "A128GCM/A192GCMKW"
	A128GCMA192KW            ElasticKeyAlgorithm = "A128GCM/A192KW"
	A128GCMA256GCMKW         ElasticKeyAlgorithm = "A128GCM/A256GCMKW"
	A128GCMA256KW            ElasticKeyAlgorithm = "A128GCM/A256KW"
	A128GCMDir               ElasticKeyAlgorithm = "A128GCM/dir"
	A128GCMECDHES            ElasticKeyAlgorithm = "A128GCM/ECDH-ES"
	A128GCMECDHESA128KW      ElasticKeyAlgorithm = "A128GCM/ECDH-ES+A128KW"
	A128GCMECDHESA192KW      ElasticKeyAlgorithm = "A128GCM/ECDH-ES+A192KW"
	A128GCMECDHESA256KW      ElasticKeyAlgorithm = "A128GCM/ECDH-ES+A256KW"
	A128GCMRSA15             ElasticKeyAlgorithm = "A128GCM/RSA1_5"
	A128GCMRSAOAEP           ElasticKeyAlgorithm = "A128GCM/RSA-OAEP"
	A128GCMRSAOAEP256        ElasticKeyAlgorithm = "A128GCM/RSA-OAEP-256"
	A128GCMRSAOAEP384        ElasticKeyAlgorithm = "A128GCM/RSA-OAEP-384"
	A128GCMRSAOAEP512        ElasticKeyAlgorithm = "A128GCM/RSA-OAEP-512"
	A192CBCHS384A128GCMKW    ElasticKeyAlgorithm = "A192CBC-HS384/A128GCMKW"
	A192CBCHS384A128KW       ElasticKeyAlgorithm = "A192CBC-HS384/A128KW"
	A192CBCHS384A192GCMKW    ElasticKeyAlgorithm = "A192CBC-HS384/A192GCMKW"
	A192CBCHS384A192KW       ElasticKeyAlgorithm = "A192CBC-HS384/A192KW"
	A192CBCHS384A256GCMKW    ElasticKeyAlgorithm = "A192CBC-HS384/A256GCMKW"
	A192CBCHS384A256KW       ElasticKeyAlgorithm = "A192CBC-HS384/A256KW"
	A192CBCHS384Dir          ElasticKeyAlgorithm = "A192CBC-HS384/dir"
	A192CBCHS384ECDHES       ElasticKeyAlgorithm = "A192CBC-HS384/ECDH-ES"
	A192CBCHS384ECDHESA128KW ElasticKeyAlgorithm = "A192CBC-HS384/ECDH-ES+A128KW"
	A192CBCHS384ECDHESA192KW ElasticKeyAlgorithm = "A192CBC-HS384/ECDH-ES+A192KW"
	A192CBCHS384ECDHESA256KW ElasticKeyAlgorithm = "A192CBC-HS384/ECDH-ES+A256KW"
	A192CBCHS384RSA15        ElasticKeyAlgorithm = "A192CBC-HS384/RSA1_5"
	A192CBCHS384RSAOAEP      ElasticKeyAlgorithm = "A192CBC-HS384/RSA-OAEP"
	A192CBCHS384RSAOAEP256   ElasticKeyAlgorithm = "A192CBC-HS384/RSA-OAEP-256"
	A192CBCHS384RSAOAEP384   ElasticKeyAlgorithm = "A192CBC-HS384/RSA-OAEP-384"
	A192CBCHS384RSAOAEP512   ElasticKeyAlgorithm = "A192CBC-HS384/RSA-OAEP-512"
	A192GCMA128GCMKW         ElasticKeyAlgorithm = "A192GCM/A128GCMKW"
	A192GCMA128KW            ElasticKeyAlgorithm = "A192GCM/A128KW"
	A192GCMA192GCMKW         ElasticKeyAlgorithm = "A192GCM/A192GCMKW"
	A192GCMA192KW            ElasticKeyAlgorithm = "A192GCM/A192KW"
	A192GCMA256GCMKW         ElasticKeyAlgorithm = "A192GCM/A256GCMKW"
	A192GCMA256KW            ElasticKeyAlgorithm = "A192GCM/A256KW"
	A192GCMDir               ElasticKeyAlgorithm = "A192GCM/dir"
	A192GCMECDHES            ElasticKeyAlgorithm = "A192GCM/ECDH-ES"
	A192GCMECDHESA128KW      ElasticKeyAlgorithm = "A192GCM/ECDH-ES+A128KW"
	A192GCMECDHESA192KW      ElasticKeyAlgorithm = "A192GCM/ECDH-ES+A192KW"
	A192GCMECDHESA256KW      ElasticKeyAlgorithm = "A192GCM/ECDH-ES+A256KW"
	A192GCMRSA15             ElasticKeyAlgorithm = "A192GCM/RSA1_5"
	A192GCMRSAOAEP           ElasticKeyAlgorithm = "A192GCM/RSA-OAEP"
	A192GCMRSAOAEP256        ElasticKeyAlgorithm = "A192GCM/RSA-OAEP-256"
	A192GCMRSAOAEP384        ElasticKeyAlgorithm = "A192GCM/RSA-OAEP-384"
	A192GCMRSAOAEP512        ElasticKeyAlgorithm = "A192GCM/RSA-OAEP-512"
	A256CBCHS512A128GCMKW    ElasticKeyAlgorithm = "A256CBC-HS512/A128GCMKW"
	A256CBCHS512A128KW       ElasticKeyAlgorithm = "A256CBC-HS512/A128KW"
	A256CBCHS512A192GCMKW    ElasticKeyAlgorithm = "A256CBC-HS512/A192GCMKW"
	A256CBCHS512A192KW       ElasticKeyAlgorithm = "A256CBC-HS512/A192KW"
	A256CBCHS512A256GCMKW    ElasticKeyAlgorithm = "A256CBC-HS512/A256GCMKW"
	A256CBCHS512A256KW       ElasticKeyAlgorithm = "A256CBC-HS512/A256KW"
	A256CBCHS512Dir          ElasticKeyAlgorithm = "A256CBC-HS512/dir"
	A256CBCHS512ECDHES       ElasticKeyAlgorithm = "A256CBC-HS512/ECDH-ES"
	A256CBCHS512ECDHESA128KW ElasticKeyAlgorithm = "A256CBC-HS512/ECDH-ES+A128KW"
	A256CBCHS512ECDHESA192KW ElasticKeyAlgorithm = "A256CBC-HS512/ECDH-ES+A192KW"
	A256CBCHS512ECDHESA256KW ElasticKeyAlgorithm = "A256CBC-HS512/ECDH-ES+A256KW"
	A256CBCHS512RSA15        ElasticKeyAlgorithm = "A256CBC-HS512/RSA1_5"
	A256CBCHS512RSAOAEP      ElasticKeyAlgorithm = "A256CBC-HS512/RSA-OAEP"
	A256CBCHS512RSAOAEP256   ElasticKeyAlgorithm = "A256CBC-HS512/RSA-OAEP-256"
	A256CBCHS512RSAOAEP384   ElasticKeyAlgorithm = "A256CBC-HS512/RSA-OAEP-384"
	A256CBCHS512RSAOAEP512   ElasticKeyAlgorithm = "A256CBC-HS512/RSA-OAEP-512"
	A256GCMA128GCMKW         ElasticKeyAlgorithm = "A256GCM/A128GCMKW"
	A256GCMA128KW            ElasticKeyAlgorithm = "A256GCM/A128KW"
	A256GCMA192GCMKW         ElasticKeyAlgorithm = "A256GCM/A192GCMKW"
	A256GCMA192KW            ElasticKeyAlgorithm = "A256GCM/A192KW"
	A256GCMA256GCMKW         ElasticKeyAlgorithm = "A256GCM/A256GCMKW"
	A256GCMA256KW            ElasticKeyAlgorithm = "A256GCM/A256KW"
	A256GCMDir               ElasticKeyAlgorithm = "A256GCM/dir"
	A256GCMECDHES            ElasticKeyAlgorithm = "A256GCM/ECDH-ES"
	A256GCMECDHESA128KW      ElasticKeyAlgorithm = "A256GCM/ECDH-ES+A128KW"
	A256GCMECDHESA192KW      ElasticKeyAlgorithm = "A256GCM/ECDH-ES+A192KW"
	A256GCMECDHESA256KW      ElasticKeyAlgorithm = "A256GCM/ECDH-ES+A256KW"
	A256GCMRSA15             ElasticKeyAlgorithm = "A256GCM/RSA1_5"
	A256GCMRSAOAEP           ElasticKeyAlgorithm = "A256GCM/RSA-OAEP"
	A256GCMRSAOAEP256        ElasticKeyAlgorithm = "A256GCM/RSA-OAEP-256"
	A256GCMRSAOAEP384        ElasticKeyAlgorithm = "A256GCM/RSA-OAEP-384"
	A256GCMRSAOAEP512        ElasticKeyAlgorithm = "A256GCM/RSA-OAEP-512"
	ES256                    ElasticKeyAlgorithm = "ES256"
	ES384                    ElasticKeyAlgorithm = "ES384"
	ES512                    ElasticKeyAlgorithm = "ES512"
	EdDSA                    ElasticKeyAlgorithm = "EdDSA"
	HS256                    ElasticKeyAlgorithm = "HS256"
	HS384                    ElasticKeyAlgorithm = "HS384"
	HS512                    ElasticKeyAlgorithm = "HS512"
	PS256                    ElasticKeyAlgorithm = "PS256"
	PS384                    ElasticKeyAlgorithm = "PS384"
	PS512                    ElasticKeyAlgorithm = "PS512"
	RS256                    ElasticKeyAlgorithm = "RS256"
	RS384                    ElasticKeyAlgorithm = "RS384"
	RS512                    ElasticKeyAlgorithm = "RS512"
)

// Defines values for ElasticKeyProvider.
const (
	Internal ElasticKeyProvider = "Internal"
)

// Defines values for ElasticKeySort.
const (
	ElasticKeySortAlgorithmASC          ElasticKeySort = "algorithm:ASC"
	ElasticKeySortAlgorithmDESC         ElasticKeySort = "algorithm:DESC"
	ElasticKeySortElasticKeyIDASC       ElasticKeySort = "elastic_key_id:ASC"
	ElasticKeySortElasticKeyIDDESC      ElasticKeySort = "elastic_key_id:DESC"
	ElasticKeySortExportAllowedASC      ElasticKeySort = "export_allowed:ASC"
	ElasticKeySortExportAllowedDESC     ElasticKeySort = "export_allowed:DESC"
	ElasticKeySortImportAllowedASC      ElasticKeySort = "import_allowed:ASC"
	ElasticKeySortImportAllowedDESC     ElasticKeySort = "import_allowed:DESC"
	ElasticKeySortNameASC               ElasticKeySort = "name:ASC"
	ElasticKeySortNameDESC              ElasticKeySort = "name:DESC"
	ElasticKeySortProviderASC           ElasticKeySort = "provider:ASC"
	ElasticKeySortProviderDESC          ElasticKeySort = "provider:DESC"
	ElasticKeySortStatusASC             ElasticKeySort = "status:ASC"
	ElasticKeySortStatusDESC            ElasticKeySort = "status:DESC"
	ElasticKeySortVersioningAllowedASC  ElasticKeySort = "versioning_allowed:ASC"
	ElasticKeySortVersioningAllowedDESC ElasticKeySort = "versioning_allowed:DESC"
)

// Defines values for ElasticKeyStatus.
const (
	Active                         ElasticKeyStatus = "active"
	Creating                       ElasticKeyStatus = "creating"
	Disabled                       ElasticKeyStatus = "disabled"
	FinishedDelete                 ElasticKeyStatus = "finished_delete"
	GenerateFailed                 ElasticKeyStatus = "generate_failed"
	ImportFailed                   ElasticKeyStatus = "import_failed"
	PendingDeleteWasActive         ElasticKeyStatus = "pending_delete_was_active"
	PendingDeleteWasDisabled       ElasticKeyStatus = "pending_delete_was_disabled"
	PendingDeleteWasGenerateFailed ElasticKeyStatus = "pending_delete_was_generate_failed"
	PendingDeleteWasImportFailed   ElasticKeyStatus = "pending_delete_was_import_failed"
	PendingDeleteWasPendingImport  ElasticKeyStatus = "pending_delete_was_pending_import"
	PendingGenerate                ElasticKeyStatus = "pending_generate"
	PendingImport                  ElasticKeyStatus = "pending_import"
	StartedDelete                  ElasticKeyStatus = "started_delete"
)

// Defines values for MaterialKeySort.
const (
	MaterialKeySortElasticKeyID       MaterialKeySort = "elastic_key_id"
	MaterialKeySortElasticKeyIDASC    MaterialKeySort = "elastic_key_id:ASC"
	MaterialKeySortElasticKeyIDDESC   MaterialKeySort = "elastic_key_id:DESC"
	MaterialKeySortExpirationDate     MaterialKeySort = "expiration_date"
	MaterialKeySortExpirationDateASC  MaterialKeySort = "expiration_date:ASC"
	MaterialKeySortExpirationDateDESC MaterialKeySort = "expiration_date:DESC"
	MaterialKeySortGenerateDate       MaterialKeySort = "generate_date"
	MaterialKeySortGenerateDateASC    MaterialKeySort = "generate_date:ASC"
	MaterialKeySortGenerateDateDESC   MaterialKeySort = "generate_date:DESC"
	MaterialKeySortImportDate         MaterialKeySort = "import_date"
	MaterialKeySortImportDateASC      MaterialKeySort = "import_date:ASC"
	MaterialKeySortImportDateDESC     MaterialKeySort = "import_date:DESC"
	MaterialKeySortMaterialKeyID      MaterialKeySort = "material_key_id"
	MaterialKeySortMaterialKeyIDASC   MaterialKeySort = "material_key_id:ASC"
	MaterialKeySortMaterialKeyIDDESC  MaterialKeySort = "material_key_id:DESC"
	MaterialKeySortRevocationDate     MaterialKeySort = "revocation_date"
	MaterialKeySortRevocationDateASC  MaterialKeySort = "revocation_date:ASC"
	MaterialKeySortRevocationDateDESC MaterialKeySort = "revocation_date:DESC"
)

// DecryptRequest JSON Web Encryption (JWE) message in compact serialized format. See RFC 7516 JSON Web Encryption (JWE) for more details. Compact serialized format is 'Header.EncryptedKey.IV.Ciphertext.AuthenticationTag'. Each section is Base64Url-encoded; Some parts can be empty depending on 'alg' and 'enc' headers. - Header: Required base64Url-encoded JSON key/values for the JWE message. - EncryptedKey: Optional base64Url-encoded of an encrypted symmetric key used to encrypt the payload. Mon-empty for envelope encryption (e.g. alg=a256gcmkw), or empty for direct encryption (e.g. alg=dir). - IV: Required base64Url-encoded Initialization Vector (IV) used to encrypt the payload. For AES-GCM or AES-GCM-SIV it contains a 12-bytes nonce. For AES-CBC it contains a 16-bytes IV. - Ciphertext: Required base64Url-encoded encrypted bytes. - AuthenticationTag: Required base64Url-encoded authentication tag. For AES-GCM or AES-GCM-SIV it's a 16-bytes authentication tag. For AES-CBC-HMAC it contains an AEAD HMAC hash.
type DecryptRequest = string

// DecryptResponse Decrypted string. For bytes, decode from text (e.g. Hexadecimal, Base64, Base64-URL, Base64-MIME, etc) back to bytes.
type DecryptResponse = string

// ElasticKey defines model for ElasticKey.
type ElasticKey struct {
	// Algorithm Cryptographic algorithm(s) used for Material Keys in the Elastic Key. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'dir', the Elastic Key Key is directly used on values. direct encryption is useful for small values. If key encryption algorithm is 'K*W', a random Content Encryption Key (CEK) is used directly on values, and the Elastic Key Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
	Algorithm *ElasticKeyAlgorithm `json:"algorithm,omitempty"`

	// Description Description for an Elastic Key.
	Description *ElasticKeyDescription `json:"description,omitempty"`

	// ElasticKeyID Unique UUID for an Elastic Key.
	ElasticKeyID *ElasticKeyID `json:"elastic_key_id,omitempty"`

	// ExportAllowed Indicates if the Elastic Key supports export of Material Key. Always use default false for production. If true, the Elastic Key should only be used for testing or development.
	ExportAllowed *ElasticKeyExportAllowed `json:"export_allowed,omitempty"`

	// ImportAllowed Indicates if the Elastic Key supports import (BYOK).
	ImportAllowed *ElasticKeyImportAllowed `json:"import_allowed,omitempty"`

	// Name Friendly name for an Elastic Key.
	Name *ElasticKeyName `json:"name,omitempty"`

	// Provider Provider of the Elastic Key management service.
	Provider *ElasticKeyProvider `json:"provider,omitempty"`

	// Status Status of the Elastic Key.
	Status *ElasticKeyStatus `json:"status,omitempty"`

	// VersioningAllowed Indicates if the Elastic Key supports versioning.
	VersioningAllowed *ElasticKeyVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// ElasticKeyAlgorithm Cryptographic algorithm(s) used for Material Keys in the Elastic Key. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'dir', the Elastic Key Key is directly used on values. direct encryption is useful for small values. If key encryption algorithm is 'K*W', a random Content Encryption Key (CEK) is used directly on values, and the Elastic Key Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
type ElasticKeyAlgorithm string

// ElasticKeyCreate defines model for ElasticKeyCreate.
type ElasticKeyCreate struct {
	// Algorithm Cryptographic algorithm(s) used for Material Keys in the Elastic Key. The first is the content encryption algorithm, and the second is the optional key encryption algorithm. If key encryption algorithm is 'dir', the Elastic Key Key is directly used on values. direct encryption is useful for small values. If key encryption algorithm is 'K*W', a random Content Encryption Key (CEK) is used directly on values, and the Elastic Key Key is used to encrypt the CEK. Key wrap is useful for large values (e.g. files, blobs, etc). If in doubt, it is safe to use 'A256GCM/A256KW' for all values; it is the default.
	Algorithm *ElasticKeyAlgorithm `json:"algorithm,omitempty"`

	// Description Description for an Elastic Key.
	Description ElasticKeyDescription `json:"description"`

	// ExportAllowed Indicates if the Elastic Key supports export of Material Key. Always use default false for production. If true, the Elastic Key should only be used for testing or development.
	ExportAllowed *ElasticKeyExportAllowed `json:"export_allowed,omitempty"`

	// ImportAllowed Indicates if the Elastic Key supports import (BYOK).
	ImportAllowed *ElasticKeyImportAllowed `json:"import_allowed,omitempty"`

	// Name Friendly name for an Elastic Key.
	Name ElasticKeyName `json:"name"`

	// Provider Provider of the Elastic Key management service.
	Provider *ElasticKeyProvider `json:"provider,omitempty"`

	// VersioningAllowed Indicates if the Elastic Key supports versioning.
	VersioningAllowed *ElasticKeyVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// ElasticKeyDescription Description for an Elastic Key.
type ElasticKeyDescription = string

// ElasticKeyExportAllowed Indicates if the Elastic Key supports export of Material Key. Always use default false for production. If true, the Elastic Key should only be used for testing or development.
type ElasticKeyExportAllowed = bool

// ElasticKeyID Unique UUID for an Elastic Key.
type ElasticKeyID = openapi_types.UUID

// ElasticKeyImportAllowed Indicates if the Elastic Key supports import (BYOK).
type ElasticKeyImportAllowed = bool

// ElasticKeyMaterialKeysQueryParams defines model for ElasticKeyMaterialKeysQueryParams.
type ElasticKeyMaterialKeysQueryParams struct {
	MaterialKeyID *[]MaterialKeyID `json:"material_key_id,omitempty"`

	// MaxExpirationDate ISO 8601 UTC timestamp of Material Key generation.
	MaxExpirationDate *MaterialKeyExpirationDate `json:"max_expiration_date,omitempty"`

	// MaxGenerateDate ISO 8601 UTC timestamp of Material Key generation.
	MaxGenerateDate *MaterialKeyGenerateDate `json:"max_generate_date,omitempty"`

	// MaxImportDate ISO 8601 UTC timestamp of Material Key generation.
	MaxImportDate *MaterialKeyImportDate `json:"max_import_date,omitempty"`

	// MaxRevocationDate ISO 8601 UTC timestamp of Material Key generation.
	MaxRevocationDate *MaterialKeyRevocationDate `json:"max_revocation_date,omitempty"`

	// MinExpirationDate ISO 8601 UTC timestamp of Material Key generation.
	MinExpirationDate *MaterialKeyExpirationDate `json:"min_expiration_date,omitempty"`

	// MinGenerateDate ISO 8601 UTC timestamp of Material Key generation.
	MinGenerateDate *MaterialKeyGenerateDate `json:"min_generate_date,omitempty"`

	// MinImportDate ISO 8601 UTC timestamp of Material Key generation.
	MinImportDate *MaterialKeyImportDate `json:"min_import_date,omitempty"`

	// MinRevocationDate ISO 8601 UTC timestamp of Material Key generation.
	MinRevocationDate *MaterialKeyRevocationDate `json:"min_revocation_date,omitempty"`

	// Page Page number starting at 0.
	Page *PageNumber `json:"page,omitempty"`

	// Size Page number.
	Size *PageSize          `json:"size,omitempty"`
	Sort *[]MaterialKeySort `json:"sort,omitempty"`
}

// ElasticKeyName Friendly name for an Elastic Key.
type ElasticKeyName = string

// ElasticKeyProvider Provider of the Elastic Key management service.
type ElasticKeyProvider string

// ElasticKeySort defines model for ElasticKeySort.
type ElasticKeySort string

// ElasticKeyStatus Status of the Elastic Key.
type ElasticKeyStatus string

// ElasticKeyUpdate defines model for ElasticKeyUpdate.
type ElasticKeyUpdate struct {
	// Description Description for an Elastic Key.
	Description ElasticKeyDescription `json:"description"`

	// Name Friendly name for an Elastic Key.
	Name ElasticKeyName `json:"name"`
}

// ElasticKeyVersioningAllowed Indicates if the Elastic Key supports versioning.
type ElasticKeyVersioningAllowed = bool

// ElasticKeysQueryParams defines model for ElasticKeysQueryParams.
type ElasticKeysQueryParams struct {
	Algorithm    *[]ElasticKeyAlgorithm `json:"algorithm,omitempty"`
	ElasticKeyID *[]ElasticKeyID        `json:"elastic_key_id,omitempty"`

	// ExportAllowed Indicates if the Elastic Key supports export of Material Key. Always use default false for production. If true, the Elastic Key should only be used for testing or development.
	ExportAllowed *ElasticKeyExportAllowed `json:"export_allowed,omitempty"`

	// ImportAllowed Indicates if the Elastic Key supports import (BYOK).
	ImportAllowed *ElasticKeyImportAllowed `json:"import_allowed,omitempty"`
	Name          *[]ElasticKeyName        `json:"name,omitempty"`

	// Page Page number starting at 0.
	Page     *PageNumber           `json:"page,omitempty"`
	Provider *[]ElasticKeyProvider `json:"provider,omitempty"`

	// Size Page number.
	Size   *PageSize           `json:"size,omitempty"`
	Sort   *[]ElasticKeySort   `json:"sort,omitempty"`
	Status *[]ElasticKeyStatus `json:"status,omitempty"`

	// VersioningAllowed Indicates if the Elastic Key supports versioning.
	VersioningAllowed *ElasticKeyVersioningAllowed `json:"versioning_allowed,omitempty"`
}

// EncryptContext Base64URL-encoded context. This is clear data used for authentication and integrity checking during decryption (e.g. namespace, context).
type EncryptContext = string

// EncryptParams defines model for EncryptParams.
type EncryptParams struct {
	// Context Base64URL-encoded context. This is clear data used for authentication and integrity checking during decryption (e.g. namespace, context).
	Context *EncryptContext `json:"context,omitempty"`
}

// EncryptRequest Clear string to be encrypted. For bytes, pre-encode as text (e.g. Hexadecimal, Base64, Base64-URL, Base64-MIME, etc).
type EncryptRequest = string

// EncryptResponse JSON Web Encryption (JWE) message in compact serialized format. See RFC 7516 JSON Web Encryption (JWE) for more details. Compact serialized format is 'Header.EncryptedKey.IV.Ciphertext.AuthenticationTag'. Each section is Base64Url-encoded; Some parts can be empty depending on 'alg' and 'enc' headers. - Header: Required base64Url-encoded JSON key/values for the JWE. - EncryptedKey: Optional base64Url-encoded of an encrypted symmetric key used to encrypt the payload. Mon-empty for envelope encryption (e.g. alg=a256gcmkw), or empty for direct encryption (e.g. alg=dir). - IV: Required base64Url-encoded Initialization Vector (IV) used to encrypt the payload. For AES-GCM or AES-GCM-SIV it contains a 12-bytes nonce. For AES-CBC it contains a 16-bytes IV. - Ciphertext: Required base64Url-encoded encrypted bytes. - AuthenticationTag: Required base64Url-encoded authentication tag. For AES-GCM or AES-GCM-SIV it's a 16-bytes authentication tag. For AES-CBC-HMAC it contains an AEAD HMAC hash.
type EncryptResponse = string

// HTTPError defines model for HTTPError.
type HTTPError struct {
	// Error HTTP status message
	Error string `json:"error"`

	// Message Detailed error message
	Message string `json:"message"`

	// Status HTTP status code
	Status int `json:"status"`
}

// MaterialKey defines model for MaterialKey.
type MaterialKey struct {
	// ClearPublic Clear public key Material Key (if applicable)
	ClearPublic *MaterialKeyClearPublic `json:"clear_public,omitempty"`

	// ElasticKeyID Unique UUID for an Elastic Key.
	ElasticKeyID ElasticKeyID `json:"elastic_key_id"`

	// ExpirationDate ISO 8601 UTC timestamp of Material Key generation.
	ExpirationDate *MaterialKeyExpirationDate `json:"expiration_date,omitempty"`

	// GenerateDate ISO 8601 UTC timestamp of Material Key generation.
	GenerateDate *MaterialKeyGenerateDate `json:"generate_date,omitempty"`

	// ImportDate ISO 8601 UTC timestamp of Material Key generation.
	ImportDate *MaterialKeyImportDate `json:"import_date,omitempty"`

	// MaterialKeyID Unique UUID for a Material Key.
	MaterialKeyID MaterialKeyID `json:"material_key_id"`

	// RevocationDate ISO 8601 UTC timestamp of Material Key generation.
	RevocationDate *MaterialKeyRevocationDate `json:"revocation_date,omitempty"`
}

// MaterialKeyClearPublic Clear public key Material Key (if applicable)
type MaterialKeyClearPublic = string

// MaterialKeyExpirationDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyExpirationDate = time.Time

// MaterialKeyGenerate defines model for MaterialKeyGenerate.
type MaterialKeyGenerate = map[string]interface{}

// MaterialKeyGenerateDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyGenerateDate = time.Time

// MaterialKeyID Unique UUID for a Material Key.
type MaterialKeyID = openapi_types.UUID

// MaterialKeyImportDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyImportDate = time.Time

// MaterialKeyRevocationDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyRevocationDate = time.Time

// MaterialKeySort defines model for MaterialKeySort.
type MaterialKeySort string

// MaterialKeyUpdate defines model for MaterialKeyUpdate.
type MaterialKeyUpdate struct {
	// ElasticKeyID Unique UUID for an Elastic Key.
	ElasticKeyID ElasticKeyID `json:"elastic_key_id"`

	// MaterialKeyID Unique UUID for a Material Key.
	MaterialKeyID MaterialKeyID `json:"material_key_id"`
}

// MaterialKeysQueryParams defines model for MaterialKeysQueryParams.
type MaterialKeysQueryParams struct {
	ElasticKeyID  *[]ElasticKeyID  `json:"elastic_key_id,omitempty"`
	MaterialKeyID *[]MaterialKeyID `json:"material_key_id,omitempty"`

	// MaxExpirationDate ISO 8601 UTC timestamp of Material Key generation.
	MaxExpirationDate *MaterialKeyExpirationDate `json:"max_expiration_date,omitempty"`

	// MaxGenerateDate ISO 8601 UTC timestamp of Material Key generation.
	MaxGenerateDate *MaterialKeyGenerateDate `json:"max_generate_date,omitempty"`

	// MaxImportDate ISO 8601 UTC timestamp of Material Key generation.
	MaxImportDate *MaterialKeyImportDate `json:"max_import_date,omitempty"`

	// MaxRevocationDate ISO 8601 UTC timestamp of Material Key generation.
	MaxRevocationDate *MaterialKeyRevocationDate `json:"max_revocation_date,omitempty"`

	// MinExpirationDate ISO 8601 UTC timestamp of Material Key generation.
	MinExpirationDate *MaterialKeyExpirationDate `json:"min_expiration_date,omitempty"`

	// MinGenerateDate ISO 8601 UTC timestamp of Material Key generation.
	MinGenerateDate *MaterialKeyGenerateDate `json:"min_generate_date,omitempty"`

	// MinImportDate ISO 8601 UTC timestamp of Material Key generation.
	MinImportDate *MaterialKeyImportDate `json:"min_import_date,omitempty"`

	// MinRevocationDate ISO 8601 UTC timestamp of Material Key generation.
	MinRevocationDate *MaterialKeyRevocationDate `json:"min_revocation_date,omitempty"`

	// Page Page number starting at 0.
	Page *PageNumber `json:"page,omitempty"`

	// Size Page number.
	Size *PageSize          `json:"size,omitempty"`
	Sort *[]MaterialKeySort `json:"sort,omitempty"`
}

// PageNumber Page number starting at 0.
type PageNumber = int

// PageSize Page number.
type PageSize = int

// SignContext Base64URL-encoded context. This is clear data used for integrity checking during verify (e.g. namespace, context).
type SignContext = string

// SignParams defines model for SignParams.
type SignParams struct {
	// Context Base64URL-encoded context. This is clear data used for integrity checking during verify (e.g. namespace, context).
	Context *SignContext `json:"context,omitempty"`
}

// SignRequest Clear text to be signed. Can be JSON-encoded to create a JWT, or freeform to create a JWS. If you need freeform, encode as text (e.g. Base64-URL, Base64-MIME, Base64, Hexadecimal, etc).
type SignRequest = string

// SignResponse JSON Web Signature (JWS) message in compact serialized format. See RFC 7515 JSON Web Signature (JWS) for more details. Compact serialized format is 'Header.Payload.Signature'. Each section is Base64Url-encoded. All parts are non-empty. - Header: Required base64Url-encoded JSON key/values for the JWS message. - Plaintext: Required base64Url-encoded clear text. Payload can be freeform (JWS), or in a special case it can be JSON (JWT). - Signature: Required base64Url-encoded signature.
type SignResponse = string

// VerifyRequest JSON Web Signature (JWS) message in compact serialized format. See RFC 7515 JSON Web Signature (JWS) for more details. Compact serialized format is 'Header.Payload.Signature'. Each section is Base64Url-encoded. All parts are non-empty. - Header: Required base64Url-encoded JSON key/values for the JWS message. - Plaintext: Required base64Url-encoded clear text. Payload can be freeform (JWS), or in a special case it can be JSON (JWT). - Signature: Required base64Url-encoded signature.
type VerifyRequest = string

// VerifyResponse Optional message about verification result
type VerifyResponse = string

// ElasticKeyQueryParamAlgorithms defines model for ElasticKeyQueryParamAlgorithms.
type ElasticKeyQueryParamAlgorithms = []ElasticKeyAlgorithm

// ElasticKeyQueryParamElasticKeyIDS defines model for ElasticKeyQueryParamElasticKeyIDS.
type ElasticKeyQueryParamElasticKeyIDS = []ElasticKeyID

// ElasticKeyQueryParamExportAllowed Indicates if the Elastic Key supports export of Material Key. Always use default false for production. If true, the Elastic Key should only be used for testing or development.
type ElasticKeyQueryParamExportAllowed = ElasticKeyExportAllowed

// ElasticKeyQueryParamImportAllowed Indicates if the Elastic Key supports import (BYOK).
type ElasticKeyQueryParamImportAllowed = ElasticKeyImportAllowed

// ElasticKeyQueryParamNames defines model for ElasticKeyQueryParamNames.
type ElasticKeyQueryParamNames = []ElasticKeyName

// ElasticKeyQueryParamPageNumber Page number starting at 0.
type ElasticKeyQueryParamPageNumber = PageNumber

// ElasticKeyQueryParamPageSize Page number.
type ElasticKeyQueryParamPageSize = PageSize

// ElasticKeyQueryParamProviders defines model for ElasticKeyQueryParamProviders.
type ElasticKeyQueryParamProviders = []ElasticKeyProvider

// ElasticKeyQueryParamSorts defines model for ElasticKeyQueryParamSorts.
type ElasticKeyQueryParamSorts = []ElasticKeySort

// ElasticKeyQueryParamStatuses defines model for ElasticKeyQueryParamStatuses.
type ElasticKeyQueryParamStatuses = []ElasticKeyStatus

// ElasticKeyQueryParamVersioningAllowed Indicates if the Elastic Key supports versioning.
type ElasticKeyQueryParamVersioningAllowed = ElasticKeyVersioningAllowed

// MaterialKeyQueryParamElasticKeyIDS defines model for MaterialKeyQueryParamElasticKeyIDS.
type MaterialKeyQueryParamElasticKeyIDS = []ElasticKeyID

// MaterialKeyQueryParamMaterialKeyIDS defines model for MaterialKeyQueryParamMaterialKeyIDS.
type MaterialKeyQueryParamMaterialKeyIDS = []MaterialKeyID

// MaterialKeyQueryParamMaximumExpirationDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyQueryParamMaximumExpirationDate = MaterialKeyExpirationDate

// MaterialKeyQueryParamMaximumGenerateDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyQueryParamMaximumGenerateDate = MaterialKeyGenerateDate

// MaterialKeyQueryParamMaximumImportDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyQueryParamMaximumImportDate = MaterialKeyImportDate

// MaterialKeyQueryParamMaximumRevocationDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyQueryParamMaximumRevocationDate = MaterialKeyRevocationDate

// MaterialKeyQueryParamMinimumExpirationDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyQueryParamMinimumExpirationDate = MaterialKeyExpirationDate

// MaterialKeyQueryParamMinimumGenerateDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyQueryParamMinimumGenerateDate = MaterialKeyGenerateDate

// MaterialKeyQueryParamMinimumImportDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyQueryParamMinimumImportDate = MaterialKeyImportDate

// MaterialKeyQueryParamMinimumRevocationDate ISO 8601 UTC timestamp of Material Key generation.
type MaterialKeyQueryParamMinimumRevocationDate = MaterialKeyRevocationDate

// MaterialKeyQueryParamPageNumber Page number starting at 0.
type MaterialKeyQueryParamPageNumber = PageNumber

// MaterialKeyQueryParamPageSize Page number.
type MaterialKeyQueryParamPageSize = PageSize

// MaterialKeyQueryParamSorts defines model for MaterialKeyQueryParamSorts.
type MaterialKeyQueryParamSorts = []MaterialKeySort

// HTTP400BadRequest defines model for HTTP400BadRequest.
type HTTP400BadRequest struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP401Unauthorized defines model for HTTP401Unauthorized.
type HTTP401Unauthorized struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP403Forbidden defines model for HTTP403Forbidden.
type HTTP403Forbidden struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP404NotFound defines model for HTTP404NotFound.
type HTTP404NotFound struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP429TooManyRequests defines model for HTTP429TooManyRequests.
type HTTP429TooManyRequests struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP500InternalServerError defines model for HTTP500InternalServerError.
type HTTP500InternalServerError struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP502BadGateway defines model for HTTP502BadGateway.
type HTTP502BadGateway struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP503ServiceUnavailable defines model for HTTP503ServiceUnavailable.
type HTTP503ServiceUnavailable struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP504GatewayTimeout defines model for HTTP504GatewayTimeout.
type HTTP504GatewayTimeout struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/5u48QwXZAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
