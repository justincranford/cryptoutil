// Package model provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package model

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for KeyPoolAlgorithm.
const (
	AES128 KeyPoolAlgorithm = "AES-128"
	AES192 KeyPoolAlgorithm = "AES-192"
	AES256 KeyPoolAlgorithm = "AES-256"
)

// Defines values for KeyPoolProvider.
const (
	Internal KeyPoolProvider = "Internal"
)

// Defines values for KeyPoolStatus.
const (
	Active                         KeyPoolStatus = "active"
	Creating                       KeyPoolStatus = "creating"
	Disabled                       KeyPoolStatus = "disabled"
	FinishedDelete                 KeyPoolStatus = "finished_delete"
	GenerateFailed                 KeyPoolStatus = "generate_failed"
	ImportFailed                   KeyPoolStatus = "import_failed"
	PendingDeleteWasActive         KeyPoolStatus = "pending_delete_was_active"
	PendingDeleteWasDisabled       KeyPoolStatus = "pending_delete_was_disabled"
	PendingDeleteWasGenerateFailed KeyPoolStatus = "pending_delete_was_generate_failed"
	PendingDeleteWasImportFailed   KeyPoolStatus = "pending_delete_was_import_failed"
	PendingDeleteWasPendingImport  KeyPoolStatus = "pending_delete_was_pending_import"
	PendingGenerate                KeyPoolStatus = "pending_generate"
	PendingImport                  KeyPoolStatus = "pending_import"
	StartedDelete                  KeyPoolStatus = "started_delete"
)

// HTTPError defines model for HTTPError.
type HTTPError struct {
	// Error HTTP status message
	Error string `json:"error"`

	// Message Detailed error message
	Message string `json:"message"`

	// Status HTTP status code
	Status int `json:"status"`
}

// Key defines model for Key.
type Key struct {
	// GenerateDate ISO 8601 UTC timestamp of Key generation.
	GenerateDate *KeyGenerateDate `json:"generateDate,omitempty"`

	// KeyId Unique version of the Key in a Key Pool.
	KeyId *KeyId `json:"key_id,omitempty"`

	// KeyPoolId Unique UUID for a Key Pool.
	KeyPoolId *KeyPoolId `json:"key_pool_id,omitempty"`
}

// KeyGenerate defines model for KeyGenerate.
type KeyGenerate = map[string]interface{}

// KeyGenerateDate ISO 8601 UTC timestamp of Key generation.
type KeyGenerateDate = time.Time

// KeyId Unique version of the Key in a Key Pool.
type KeyId = int

// KeyPool defines model for KeyPool.
type KeyPool struct {
	// Algorithm Cryptographic algorithm for the Key Pool.
	Algorithm *KeyPoolAlgorithm `json:"algorithm,omitempty"`

	// Description Description for a Key Pool.
	Description *KeyPoolDescription `json:"description,omitempty"`

	// Id Unique UUID for a Key Pool.
	Id *KeyPoolId `json:"id,omitempty"`

	// IsExportAllowed Indicates if the Key Pool supports export.
	IsExportAllowed *KeyPoolIsExportAllowed `json:"isExportAllowed,omitempty"`

	// IsImportAllowed Indicates if the Key Pool supports import (BYOK).
	IsImportAllowed *KeyPoolIsImportAllowed `json:"isImportAllowed,omitempty"`

	// IsVersioningAllowed Indicates if the Key Pool supports versioning.
	IsVersioningAllowed *KeyPoolIsVersioningAllowed `json:"isVersioningAllowed,omitempty"`

	// Name Friendly name for a Key Pool.
	Name *KeyPoolName `json:"name,omitempty"`

	// Provider Provider of the Key Pool management service.
	Provider *KeyPoolProvider `json:"provider,omitempty"`

	// Status Status of the Key Pool.
	Status *KeyPoolStatus `json:"status,omitempty"`
}

// KeyPoolAlgorithm Cryptographic algorithm for the Key Pool.
type KeyPoolAlgorithm string

// KeyPoolCreate defines model for KeyPoolCreate.
type KeyPoolCreate struct {
	// Algorithm Cryptographic algorithm for the Key Pool.
	Algorithm *KeyPoolAlgorithm `json:"algorithm,omitempty"`

	// Description Description for a Key Pool.
	Description KeyPoolDescription `json:"description"`

	// IsExportAllowed Indicates if the Key Pool supports export.
	IsExportAllowed *KeyPoolIsExportAllowed `json:"isExportAllowed,omitempty"`

	// IsImportAllowed Indicates if the Key Pool supports import (BYOK).
	IsImportAllowed *KeyPoolIsImportAllowed `json:"isImportAllowed,omitempty"`

	// IsVersioningAllowed Indicates if the Key Pool supports versioning.
	IsVersioningAllowed *KeyPoolIsVersioningAllowed `json:"isVersioningAllowed,omitempty"`

	// Name Friendly name for a Key Pool.
	Name KeyPoolName `json:"name"`

	// Provider Provider of the Key Pool management service.
	Provider *KeyPoolProvider `json:"provider,omitempty"`
}

// KeyPoolDescription Description for a Key Pool.
type KeyPoolDescription = string

// KeyPoolId Unique UUID for a Key Pool.
type KeyPoolId = openapi_types.UUID

// KeyPoolIsExportAllowed Indicates if the Key Pool supports export.
type KeyPoolIsExportAllowed = bool

// KeyPoolIsImportAllowed Indicates if the Key Pool supports import (BYOK).
type KeyPoolIsImportAllowed = bool

// KeyPoolIsVersioningAllowed Indicates if the Key Pool supports versioning.
type KeyPoolIsVersioningAllowed = bool

// KeyPoolName Friendly name for a Key Pool.
type KeyPoolName = string

// KeyPoolProvider Provider of the Key Pool management service.
type KeyPoolProvider string

// KeyPoolStatus Status of the Key Pool.
type KeyPoolStatus string

// KeyPoolUpdate defines model for KeyPoolUpdate.
type KeyPoolUpdate struct {
	// Description Description for a Key Pool.
	Description KeyPoolDescription `json:"description"`

	// Name Friendly name for a Key Pool.
	Name KeyPoolName `json:"name"`
}

// KeyUpdate defines model for KeyUpdate.
type KeyUpdate struct {
	// KeyPoolId Unique UUID for a Key Pool.
	KeyPoolId KeyPoolId `json:"key_pool_id"`

	// KeyVersion Unique version of the Key in a Key Pool.
	KeyVersion KeyId `json:"key_version"`
}

// QueryParamFilter Filter criteria in the format 'field=value'. Supported operators are '=', '!=', '>', '<', '>=', '<='
type QueryParamFilter = string

// QueryParamPage Paging criteria in the format 'pageNumber:pageSize' or 'pageNumber'; pageNumber is 0 offset.
type QueryParamPage = string

// QueryParamSort Sort criteria in the format 'field:direction' or 'field'. Values for direction are ASC or DESC. If omitted, it defaults to ASC.
type QueryParamSort = string

// HTTP400BadRequest defines model for HTTP400BadRequest.
type HTTP400BadRequest struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP401Unauthorized defines model for HTTP401Unauthorized.
type HTTP401Unauthorized struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP403Forbidden defines model for HTTP403Forbidden.
type HTTP403Forbidden struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP404NotFound defines model for HTTP404NotFound.
type HTTP404NotFound struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP429TooManyRequests defines model for HTTP429TooManyRequests.
type HTTP429TooManyRequests struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP500InternalServerError defines model for HTTP500InternalServerError.
type HTTP500InternalServerError struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP502BadGateway defines model for HTTP502BadGateway.
type HTTP502BadGateway struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP503ServiceUnavailable defines model for HTTP503ServiceUnavailable.
type HTTP503ServiceUnavailable struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// HTTP504GatewayTimeout defines model for HTTP504GatewayTimeout.
type HTTP504GatewayTimeout struct {
	Error   string `json:"error"`
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"1GQi8iTZ/C8AAP//pZFSMsQhAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
