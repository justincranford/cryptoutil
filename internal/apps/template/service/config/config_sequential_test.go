// Copyright (c) 2025 Justin Cranford
//
//

package config

import (
	cryptoutilSharedMagic "cryptoutil/internal/shared/magic"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

func TestParse_HappyPath_Defaults(t *testing.T) {
	resetFlags()

	commandParameters := []string{"start"}
	s, err := Parse(commandParameters, true) // true => If --help is set, help is printed and the program exits
	require.NoError(t, err)
	require.Equal(t, help.Value, s.Help)
	require.Equal(t, configFile.Value, s.ConfigFile)
	require.Equal(t, logLevel.Value, s.LogLevel)
	require.Equal(t, verboseMode.Value, s.VerboseMode)
	require.Equal(t, devMode.Value, s.DevMode)
	require.Equal(t, bindPublicProtocol.Value, s.BindPublicProtocol)
	require.Equal(t, bindPublicAddress.Value, s.BindPublicAddress)
	require.Equal(t, bindPublicPort.Value, s.BindPublicPort)
	require.Equal(t, bindPrivateProtocol.Value, s.BindPrivateProtocol)
	require.Equal(t, bindPrivateAddress.Value, s.BindPrivateAddress)
	require.Equal(t, bindPrivatePort.Value, s.BindPrivatePort)
	require.Equal(t, tlsPublicDNSNames.Value, s.TLSPublicDNSNames)
	require.Equal(t, tlsPublicIPAddresses.Value, s.TLSPublicIPAddresses)
	require.Equal(t, tlsPrivateDNSNames.Value, s.TLSPrivateDNSNames)
	require.Equal(t, tlsPrivateIPAddresses.Value, s.TLSPrivateIPAddresses)
	require.Equal(t, tlsPublicMode.Value, s.TLSPublicMode)
	require.Equal(t, tlsPrivateMode.Value, s.TLSPrivateMode)
	require.Equal(t, tlsStaticCertPEM.Value, s.TLSStaticCertPEM)
	require.Equal(t, tlsStaticKeyPEM.Value, s.TLSStaticKeyPEM)
	require.Equal(t, tlsMixedCACertPEM.Value, s.TLSMixedCACertPEM)
	require.Equal(t, tlsMixedCAKeyPEM.Value, s.TLSMixedCAKeyPEM)
	require.Equal(t, publicBrowserAPIContextPath.Value, s.PublicBrowserAPIContextPath)
	require.Equal(t, publicServiceAPIContextPath.Value, s.PublicServiceAPIContextPath)
	require.Equal(t, corsAllowedOrigins.Value, s.CORSAllowedOrigins)
	require.Equal(t, corsAllowedMethods.Value, s.CORSAllowedMethods)
	require.Equal(t, corsAllowedHeaders.Value, s.CORSAllowedHeaders)
	require.Equal(t, corsMaxAge.Value, s.CORSMaxAge)
	require.Equal(t, csrfTokenName.Value, s.CSRFTokenName)
	require.Equal(t, csrfTokenSameSite.Value, s.CSRFTokenSameSite)
	require.Equal(t, csrfTokenMaxAge.Value, s.CSRFTokenMaxAge)
	require.Equal(t, csrfTokenCookieSecure.Value, s.CSRFTokenCookieSecure)
	require.Equal(t, csrfTokenCookieHTTPOnly.Value, s.CSRFTokenCookieHTTPOnly)
	require.Equal(t, csrfTokenCookieSessionOnly.Value, s.CSRFTokenCookieSessionOnly)
	require.Equal(t, csrfTokenSingleUseToken.Value, s.CSRFTokenSingleUseToken)
	require.Equal(t, browserIPRateLimit.Value, s.BrowserIPRateLimit)
	require.Equal(t, serviceIPRateLimit.Value, s.ServiceIPRateLimit)
	require.Equal(t, allowedIps.Value, s.AllowedIPs)
	require.Equal(t, allowedCidrs.Value, s.AllowedCIDRs)
	require.Equal(t, databaseContainer.Value, s.DatabaseContainer)
	require.Equal(t, databaseURL.Value, s.DatabaseURL)
	require.Equal(t, databaseInitTotalTimeout.Value, s.DatabaseInitTotalTimeout)
	require.Equal(t, databaseInitRetryWait.Value, s.DatabaseInitRetryWait)
	require.Equal(t, otlpEnabled.Value, s.OTLPEnabled)
	require.Equal(t, otlpConsole.Value, s.OTLPConsole)
	require.Equal(t, otlpService.Value, s.OTLPService)
	// OTLP instance is generated by default; ensure it's non-empty
	require.NotEmpty(t, s.OTLPInstance)
	require.Equal(t, otlpVersion.Value, s.OTLPVersion)
	require.Equal(t, otlpEnvironment.Value, s.OTLPEnvironment)
	require.Equal(t, otlpHostname.Value, s.OTLPHostname)
	require.Equal(t, otlpEndpoint.Value, s.OTLPEndpoint)
	require.Equal(t, unsealMode.Value, s.UnsealMode)
	unsealFilesSlice, ok := unsealFiles.Value.([]string)
	require.True(t, ok, "unsealFiles.value should be []string")
	require.Equal(t, unsealFilesSlice, s.UnsealFiles)
}

func TestParse_HappyPath_Overrides(t *testing.T) {
	resetFlags()

	commandParameters := []string{
		"start",
		"--help",
		"--config=test.yaml",
		"--log-level=debug",
		"--verbose",
		"--dev",
		"--bind-public-protocol=http",
		"--bind-public-address=192.168.1.2",
		"--bind-public-port=18080",
		"--bind-private-protocol=https",
		"--bind-private-address=192.168.1.3",
		"--bind-private-port=19090",
		"--tls-public-dns-names=public1.example.com,public2.example.com",
		"--tls-public-ip-addresses=192.168.1.4,192.168.1.6",
		"--tls-private-dns-names=private1.example.com,private2.example.com",
		"--tls-private-ip-addresses=192.168.1.5,192.168.1.7",
		"--tls-public-mode=static",
		"--tls-private-mode=mixed",
		"--tls-static-cert-pem=LS0tQkVHSU4=",
		"--tls-static-key-pem=S0VZLUJFRw==",
		"--tls-mixed-ca-cert-pem=Q0VSVC0tLQ==",
		"--tls-mixed-ca-key-pem=S0VZLUtFWQ==",
		"--browser-api-context-path=/browser",
		"--service-api-context-path=/service",
		"--cors-origins=https://example.com",
		"--cors-methods=GET,POST",
		"--cors-headers=X-Custom-Header",
		"--cors-max-age=1800",
		"--csrf-token-name=custom_csrf",
		"--csrf-token-same-site=Lax",
		"--csrf-token-max-age=24h",
		"--csrf-token-cookie-secure=false",
		"--csrf-token-cookie-http-only=false",
		"--csrf-token-cookie-session-only=false",
		"--csrf-token-single-use-token=true",
		"--browser-rate-limit=100",
		"--service-rate-limit=50",
		"--allowed-ips=192.168.1.100,192.168.1.101",
		"--allowed-cidrs=10.0.0.0/8,192.168.1.0/24",
		"--database-container=required",
		"--database-url=postgres://user:pass@db:5432/dbname?sslmode=disable",
		"--database-init-total-timeout=5m",
		"--database-init-retry-wait=30s",
		"--otlp",
		"--otlp-console",
		"--otlp-service=my-service",
		"--otlp-version=1.0.0",
		"--otlp-instance=my-instance",
		"--otlp-environment=development",
		"--otlp-hostname=example.com",
		"--otlp-endpoint=grpc://example.com:4317",
		"--unseal-mode=2-of-3",
		"--unseal-files=/docker/secrets/unseal1",
		"--unseal-files=/docker/secrets/unseal2",
		"--unseal-files=/docker/secrets/unseal3",
	}

	s, err := Parse(commandParameters, false) // false => If --help is set, help is printed but the program doesn't exit
	require.NoError(t, err)
	require.True(t, s.Help)
	require.Equal(t, []string{"test.yaml"}, s.ConfigFile)
	require.Equal(t, "debug", s.LogLevel)
	require.True(t, s.VerboseMode)
	require.Equal(t, cryptoutilSharedMagic.ProtocolHTTP, s.BindPublicProtocol)
	require.Equal(t, "192.168.1.2", s.BindPublicAddress)
	require.Equal(t, uint16(18080), s.BindPublicPort)
	require.Equal(t, cryptoutilSharedMagic.ProtocolHTTPS, s.BindPrivateProtocol)
	require.Equal(t, "192.168.1.3", s.BindPrivateAddress)
	require.Equal(t, uint16(19090), s.BindPrivatePort)
	require.Equal(t, []string{"public1.example.com", "public2.example.com"}, s.TLSPublicDNSNames)
	require.Equal(t, []string{"192.168.1.4", "192.168.1.6"}, s.TLSPublicIPAddresses)
	require.Equal(t, []string{"private1.example.com", "private2.example.com"}, s.TLSPrivateDNSNames)
	require.Equal(t, []string{"192.168.1.5", "192.168.1.7"}, s.TLSPrivateIPAddresses)
	require.Equal(t, TLSMode("static"), s.TLSPublicMode)
	require.Equal(t, TLSMode("mixed"), s.TLSPrivateMode)
	// Base64-decoded "LS0tQkVHSU4=" -> "---BEGIN"
	require.Equal(t, []byte("---BEGIN"), s.TLSStaticCertPEM)
	// Base64-decoded "S0VZLUJFRw==" -> "KEY-BEG"
	require.Equal(t, []byte("KEY-BEG"), s.TLSStaticKeyPEM)
	// Base64-decoded "Q0VSVC0tLQ==" -> "CERT---"
	require.Equal(t, []byte("CERT---"), s.TLSMixedCACertPEM)
	// Base64-decoded "S0VZLUtFWQ==" -> "KEY-KEY"
	require.Equal(t, []byte("KEY-KEY"), s.TLSMixedCAKeyPEM)
	require.Equal(t, cryptoutilSharedMagic.PathPrefixBrowser, s.PublicBrowserAPIContextPath)
	require.Equal(t, cryptoutilSharedMagic.PathPrefixService, s.PublicServiceAPIContextPath)
	require.Equal(t, []string{"https://example.com"}, s.CORSAllowedOrigins)
	require.Equal(t, []string{"GET", "POST"}, s.CORSAllowedMethods)
	require.Equal(t, []string{"X-Custom-Header"}, s.CORSAllowedHeaders)
	require.Equal(t, uint16(cryptoutilSharedMagic.IMEnterpriseSessionTimeout), s.CORSMaxAge)
	require.Equal(t, "custom_csrf", s.CSRFTokenName)
	require.Equal(t, "Lax", s.CSRFTokenSameSite)
	require.Equal(t, cryptoutilSharedMagic.HoursPerDay*time.Hour, s.CSRFTokenMaxAge)
	require.Equal(t, false, s.CSRFTokenCookieSecure)
	require.Equal(t, false, s.CSRFTokenCookieHTTPOnly)
	require.Equal(t, false, s.CSRFTokenCookieSessionOnly)
	require.Equal(t, true, s.CSRFTokenSingleUseToken)
	require.Equal(t, uint16(cryptoutilSharedMagic.JoseJAMaxMaterials), s.BrowserIPRateLimit)
	require.Equal(t, uint16(cryptoutilSharedMagic.IMMaxUsernameLength), s.ServiceIPRateLimit)
	require.Equal(t, []string{"192.168.1.100", "192.168.1.101"}, s.AllowedIPs)
	require.Equal(t, []string{cryptoutilSharedMagic.PrivateLANClassACIDRv4, "192.168.1.0/24"}, s.AllowedCIDRs)
	require.Equal(t, "required", s.DatabaseContainer)
	require.Equal(t, "postgres://user:pass@db:5432/dbname?sslmode=disable", s.DatabaseURL)
	require.Equal(t, cryptoutilSharedMagic.DefaultSidecarHealthCheckMaxRetries*time.Minute, s.DatabaseInitTotalTimeout)
	require.Equal(t, cryptoutilSharedMagic.TLSTestEndEntityCertValidity30Days*time.Second, s.DatabaseInitRetryWait)
	require.True(t, s.OTLPEnabled)
	require.True(t, s.OTLPConsole)
	require.Equal(t, "my-service", s.OTLPService)
	require.Equal(t, "my-instance", s.OTLPInstance)
	require.Equal(t, cryptoutilSharedMagic.ServiceVersion, s.OTLPVersion)
	require.Equal(t, "development", s.OTLPEnvironment)
	require.Equal(t, "example.com", s.OTLPHostname)
	require.Equal(t, "grpc://example.com:4317", s.OTLPEndpoint)
	require.True(t, s.DevMode)
	require.Equal(t, "2-of-3", s.UnsealMode)
	require.Equal(t, []string{"/docker/secrets/unseal1", "/docker/secrets/unseal2", "/docker/secrets/unseal3"}, s.UnsealFiles)
}

func TestAnalyzeSettings_RealSettings(t *testing.T) {
	result := analyzeSettings(allServiceTemplateServerRegisteredSettings)

	totalMappedByName := 0
	for _, settings := range result.SettingsByNames {
		totalMappedByName += len(settings)
	}

	require.Equal(t, len(allServiceTemplateServerRegisteredSettings), totalMappedByName, "All settings should be accounted for by name")

	// Count settings with non-empty shorthands
	settingsWithShorthands := 0

	for _, setting := range allServiceTemplateServerRegisteredSettings {
		if setting.Shorthand != "" {
			settingsWithShorthands++
		}
	}

	totalMappedByShorthand := 0
	for _, settings := range result.SettingsByShorthands {
		totalMappedByShorthand += len(settings)
	}

	require.Equal(t, settingsWithShorthands, totalMappedByShorthand, "All settings with non-empty shorthands should be accounted for")

	require.Empty(t, result.DuplicateNames, "Production settings should have no duplicate names")
	require.Empty(t, result.DuplicateShorthands, "Production settings should have no duplicate shorthands")

	for name, settings := range result.SettingsByNames {
		require.Len(t, settings, 1, "Setting name '%s' should be unique", name)
	}

	for shorthand, settings := range result.SettingsByShorthands {
		require.Len(t, settings, 1, "Setting shorthand '%s' should be unique", shorthand)
	}
}

func TestAnalyzeSettings_NoDuplicates(t *testing.T) {
	result := analyzeSettings([]*Setting{
		{Name: "unique1", Shorthand: "a", Value: "value1", Usage: "usage1"},
		{Name: "unique2", Shorthand: "b", Value: "value2", Usage: "usage2"},
		{Name: "unique3", Shorthand: "c", Value: "value3", Usage: "usage3"},
	})

	require.Len(t, result.SettingsByNames, 3)
	require.Len(t, result.SettingsByNames["unique1"], 1)
	require.Len(t, result.SettingsByNames["unique2"], 1)
	require.Len(t, result.SettingsByNames["unique3"], 1)
	require.Equal(t, "unique1", result.SettingsByNames["unique1"][0].Name)
	require.Equal(t, "unique2", result.SettingsByNames["unique2"][0].Name)
	require.Equal(t, "unique3", result.SettingsByNames["unique3"][0].Name)

	require.Len(t, result.SettingsByShorthands, 3)
	require.Len(t, result.SettingsByShorthands["a"], 1)
	require.Len(t, result.SettingsByShorthands["b"], 1)
	require.Len(t, result.SettingsByShorthands["c"], 1)
	require.Equal(t, "a", result.SettingsByShorthands["a"][0].Shorthand)
	require.Equal(t, "b", result.SettingsByShorthands["b"][0].Shorthand)
	require.Equal(t, "c", result.SettingsByShorthands["c"][0].Shorthand)

	require.Empty(t, result.DuplicateNames)

	require.Empty(t, result.DuplicateShorthands)
}

func TestAnalyzeSettings_DuplicateNamesOnly(t *testing.T) {
	result := analyzeSettings([]*Setting{
		{Name: "duplicate", Shorthand: "a", Value: "value1", Usage: "usage1"},
		{Name: "duplicate", Shorthand: "b", Value: "value2", Usage: "usage2"},
		{Name: "unique", Shorthand: "c", Value: "value3", Usage: "usage3"},
	})

	require.Len(t, result.SettingsByNames, 2)
	require.Len(t, result.SettingsByNames["duplicate"], 2)
	require.Len(t, result.SettingsByNames["unique"], 1)

	require.Contains(t, result.DuplicateNames, "duplicate")
	require.NotContains(t, result.DuplicateNames, "unique")

	require.Empty(t, result.DuplicateShorthands)
}

func TestAnalyzeSettings_DuplicateShorthandsOnly(t *testing.T) {
	result := analyzeSettings([]*Setting{
		{Name: "unique1", Shorthand: "d", Value: "value1", Usage: "usage1"},
		{Name: "unique2", Shorthand: "d", Value: "value2", Usage: "usage2"},
		{Name: "unique3", Shorthand: "u", Value: "value3", Usage: "usage3"},
	})

	require.Len(t, result.SettingsByShorthands, 2)
	require.Len(t, result.SettingsByShorthands["d"], 2)
	require.Len(t, result.SettingsByShorthands["u"], 1)

	require.Empty(t, result.DuplicateNames)

	require.Contains(t, result.DuplicateShorthands, "d")
	require.NotContains(t, result.DuplicateShorthands, "u")
}

func TestAnalyzeSettings_DuplicateNames_And_DuplicateShorthands(t *testing.T) {
	result := analyzeSettings([]*Setting{
		{Name: "duplicate", Shorthand: "d", Value: "value1", Usage: "usage1"},
		{Name: "duplicate", Shorthand: "d", Value: "value2", Usage: "usage2"},
		{Name: "unique1", Shorthand: "u", Value: "value3", Usage: "usage3"},
		{Name: "unique2", Shorthand: "U", Value: "value4", Usage: "usage4"},
	})

	require.Len(t, result.SettingsByNames, 3)
	require.Len(t, result.SettingsByNames["duplicate"], 2)
	require.Len(t, result.SettingsByNames["unique1"], 1)
	require.Len(t, result.SettingsByNames["unique2"], 1)

	require.Len(t, result.SettingsByShorthands, 3)
	require.Len(t, result.SettingsByShorthands["d"], 2)
	require.Len(t, result.SettingsByShorthands["u"], 1)
	require.Len(t, result.SettingsByShorthands["U"], 1)

	require.Contains(t, result.DuplicateNames, "duplicate")
	require.NotContains(t, result.DuplicateNames, "unique1")
	require.NotContains(t, result.DuplicateNames, "unique2")

	require.Contains(t, result.DuplicateShorthands, "d")
	require.NotContains(t, result.DuplicateShorthands, "u")
	require.NotContains(t, result.DuplicateShorthands, "U")
}

func TestParse_EnvironmentVariables(t *testing.T) {
	resetFlags()

	// Set environment variables
	t.Setenv("CRYPTOUTIL_LOG_LEVEL", "DEBUG")
	t.Setenv("CRYPTOUTIL_DEV", "true")
	t.Setenv("CRYPTOUTIL_BIND_PUBLIC_PORT", "8080")
	t.Setenv("CRYPTOUTIL_DATABASE_URL", "postgres://env:pass@envdb:5432/envdb?sslmode=require")

	commandParameters := []string{"start"}
	s, err := Parse(commandParameters, false)
	require.NoError(t, err)

	// Verify environment variables were loaded
	require.Equal(t, "DEBUG", s.LogLevel)
	require.True(t, s.DevMode)
	require.Equal(t, uint16(cryptoutilSharedMagic.DemoServerPort), s.BindPublicPort)
	require.Equal(t, "postgres://env:pass@envdb:5432/envdb?sslmode=require", s.DatabaseURL)
}

func TestParse_EnvironmentVariables_CommandLineOverride(t *testing.T) {
	resetFlags()

	// Set environment variables
	t.Setenv("CRYPTOUTIL_LOG_LEVEL", "DEBUG")
	t.Setenv("CRYPTOUTIL_DEV", "true")

	// Override with command line flags
	commandParameters := []string{"start", "--log-level=INFO", "--dev=false"}
	s, err := Parse(commandParameters, false)
	require.NoError(t, err)

	// Command line flags should override environment variables
	require.Equal(t, cryptoutilSharedMagic.DefaultLogLevelInfo, s.LogLevel)
	require.False(t, s.DevMode)
}

func TestParse_DryRun(t *testing.T) {
	resetFlags()

	commandParameters := []string{"start", "--dry-run"}
	s, err := Parse(commandParameters, false)
	require.NoError(t, err)
	require.True(t, s.DryRun)
}

func TestParse_DryRun_Default(t *testing.T) {
	resetFlags()

	commandParameters := []string{"start"}
	s, err := Parse(commandParameters, false)
	require.NoError(t, err)
	require.False(t, s.DryRun)
}
