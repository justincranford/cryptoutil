// Copyright (c) 2025 Justin Cranford
//
//

package config

import (
	"os"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

func TestParse_HappyPath_Defaults(t *testing.T) {
	resetFlags()

	commandParameters := []string{"start"}
	s, err := Parse(commandParameters, true) // true => If --help is set, help is printed and the program exits
	require.NoError(t, err)
	require.Equal(t, help.Value, s.Help)
	require.Equal(t, configFile.Value, s.ConfigFile)
	require.Equal(t, logLevel.Value, s.LogLevel)
	require.Equal(t, verboseMode.Value, s.VerboseMode)
	require.Equal(t, devMode.Value, s.DevMode)
	require.Equal(t, bindPublicProtocol.Value, s.BindPublicProtocol)
	require.Equal(t, bindPublicAddress.Value, s.BindPublicAddress)
	require.Equal(t, bindPublicPort.Value, s.BindPublicPort)
	require.Equal(t, bindPrivateProtocol.Value, s.BindPrivateProtocol)
	require.Equal(t, bindPrivateAddress.Value, s.BindPrivateAddress)
	require.Equal(t, bindPrivatePort.Value, s.BindPrivatePort)
	require.Equal(t, tlsPublicDNSNames.Value, s.TLSPublicDNSNames)
	require.Equal(t, tlsPublicIPAddresses.Value, s.TLSPublicIPAddresses)
	require.Equal(t, tlsPrivateDNSNames.Value, s.TLSPrivateDNSNames)
	require.Equal(t, tlsPrivateIPAddresses.Value, s.TLSPrivateIPAddresses)
	require.Equal(t, tlsPublicMode.Value, s.TLSPublicMode)
	require.Equal(t, tlsPrivateMode.Value, s.TLSPrivateMode)
	require.Equal(t, tlsStaticCertPEM.Value, s.TLSStaticCertPEM)
	require.Equal(t, tlsStaticKeyPEM.Value, s.TLSStaticKeyPEM)
	require.Equal(t, tlsMixedCACertPEM.Value, s.TLSMixedCACertPEM)
	require.Equal(t, tlsMixedCAKeyPEM.Value, s.TLSMixedCAKeyPEM)
	require.Equal(t, publicBrowserAPIContextPath.Value, s.PublicBrowserAPIContextPath)
	require.Equal(t, publicServiceAPIContextPath.Value, s.PublicServiceAPIContextPath)
	require.Equal(t, corsAllowedOrigins.Value, s.CORSAllowedOrigins)
	require.Equal(t, corsAllowedMethods.Value, s.CORSAllowedMethods)
	require.Equal(t, corsAllowedHeaders.Value, s.CORSAllowedHeaders)
	require.Equal(t, corsMaxAge.Value, s.CORSMaxAge)
	require.Equal(t, csrfTokenName.Value, s.CSRFTokenName)
	require.Equal(t, csrfTokenSameSite.Value, s.CSRFTokenSameSite)
	require.Equal(t, csrfTokenMaxAge.Value, s.CSRFTokenMaxAge)
	require.Equal(t, csrfTokenCookieSecure.Value, s.CSRFTokenCookieSecure)
	require.Equal(t, csrfTokenCookieHTTPOnly.Value, s.CSRFTokenCookieHTTPOnly)
	require.Equal(t, csrfTokenCookieSessionOnly.Value, s.CSRFTokenCookieSessionOnly)
	require.Equal(t, csrfTokenSingleUseToken.Value, s.CSRFTokenSingleUseToken)
	require.Equal(t, browserIPRateLimit.Value, s.BrowserIPRateLimit)
	require.Equal(t, serviceIPRateLimit.Value, s.ServiceIPRateLimit)
	require.Equal(t, allowedIps.Value, s.AllowedIPs)
	require.Equal(t, allowedCidrs.Value, s.AllowedCIDRs)
	require.Equal(t, databaseContainer.Value, s.DatabaseContainer)
	require.Equal(t, databaseURL.Value, s.DatabaseURL)
	require.Equal(t, databaseInitTotalTimeout.Value, s.DatabaseInitTotalTimeout)
	require.Equal(t, databaseInitRetryWait.Value, s.DatabaseInitRetryWait)
	require.Equal(t, otlpEnabled.Value, s.OTLPEnabled)
	require.Equal(t, otlpConsole.Value, s.OTLPConsole)
	require.Equal(t, otlpService.Value, s.OTLPService)
	// OTLP instance is generated by default; ensure it's non-empty
	require.NotEmpty(t, s.OTLPInstance)
	require.Equal(t, otlpVersion.Value, s.OTLPVersion)
	require.Equal(t, otlpEnvironment.Value, s.OTLPEnvironment)
	require.Equal(t, otlpHostname.Value, s.OTLPHostname)
	require.Equal(t, otlpEndpoint.Value, s.OTLPEndpoint)
	require.Equal(t, unsealMode.Value, s.UnsealMode)
	unsealFilesSlice, ok := unsealFiles.Value.([]string)
	require.True(t, ok, "unsealFiles.value should be []string")
	require.Equal(t, unsealFilesSlice, s.UnsealFiles)
}

func TestParse_HappyPath_Overrides(t *testing.T) {
	resetFlags()

	commandParameters := []string{
		"start",
		"--help",
		"--config=test.yaml",
		"--log-level=debug",
		"--verbose",
		"--dev",
		"--bind-public-protocol=http",
		"--bind-public-address=192.168.1.2",
		"--bind-public-port=18080",
		"--bind-private-protocol=https",
		"--bind-private-address=192.168.1.3",
		"--bind-private-port=19090",
		"--tls-public-dns-names=public1.example.com,public2.example.com",
		"--tls-public-ip-addresses=192.168.1.4,192.168.1.6",
		"--tls-private-dns-names=private1.example.com,private2.example.com",
		"--tls-private-ip-addresses=192.168.1.5,192.168.1.7",
		"--tls-public-mode=static",
		"--tls-private-mode=mixed",
		"--tls-static-cert-pem=LS0tQkVHSU4=",
		"--tls-static-key-pem=S0VZLUJFRw==",
		"--tls-mixed-ca-cert-pem=Q0VSVC0tLQ==",
		"--tls-mixed-ca-key-pem=S0VZLUtFWQ==",
		"--browser-api-context-path=/browser",
		"--service-api-context-path=/service",
		"--cors-origins=https://example.com",
		"--cors-methods=GET,POST",
		"--cors-headers=X-Custom-Header",
		"--cors-max-age=1800",
		"--csrf-token-name=custom_csrf",
		"--csrf-token-same-site=Lax",
		"--csrf-token-max-age=24h",
		"--csrf-token-cookie-secure=false",
		"--csrf-token-cookie-http-only=false",
		"--csrf-token-cookie-session-only=false",
		"--csrf-token-single-use-token=true",
		"--browser-rate-limit=100",
		"--service-rate-limit=50",
		"--allowed-ips=192.168.1.100,192.168.1.101",
		"--allowed-cidrs=10.0.0.0/8,192.168.1.0/24",
		"--database-container=required",
		"--database-url=postgres://user:pass@db:5432/dbname?sslmode=disable",
		"--database-init-total-timeout=5m",
		"--database-init-retry-wait=30s",
		"--otlp",
		"--otlp-console",
		"--otlp-service=my-service",
		"--otlp-version=1.0.0",
		"--otlp-instance=my-instance",
		"--otlp-environment=development",
		"--otlp-hostname=example.com",
		"--otlp-endpoint=grpc://example.com:4317",
		"--unseal-mode=2-of-3",
		"--unseal-files=/docker/secrets/unseal1",
		"--unseal-files=/docker/secrets/unseal2",
		"--unseal-files=/docker/secrets/unseal3",
	}

	s, err := Parse(commandParameters, false) // false => If --help is set, help is printed but the program doesn't exit
	require.NoError(t, err)
	require.True(t, s.Help)
	require.Equal(t, []string{"test.yaml"}, s.ConfigFile)
	require.Equal(t, "debug", s.LogLevel)
	require.True(t, s.VerboseMode)
	require.Equal(t, "http", s.BindPublicProtocol)
	require.Equal(t, "192.168.1.2", s.BindPublicAddress)
	require.Equal(t, uint16(18080), s.BindPublicPort)
	require.Equal(t, "https", s.BindPrivateProtocol)
	require.Equal(t, "192.168.1.3", s.BindPrivateAddress)
	require.Equal(t, uint16(19090), s.BindPrivatePort)
	require.Equal(t, []string{"public1.example.com", "public2.example.com"}, s.TLSPublicDNSNames)
	require.Equal(t, []string{"192.168.1.4", "192.168.1.6"}, s.TLSPublicIPAddresses)
	require.Equal(t, []string{"private1.example.com", "private2.example.com"}, s.TLSPrivateDNSNames)
	require.Equal(t, []string{"192.168.1.5", "192.168.1.7"}, s.TLSPrivateIPAddresses)
	require.Equal(t, TLSMode("static"), s.TLSPublicMode)
	require.Equal(t, TLSMode("mixed"), s.TLSPrivateMode)
	// Base64-decoded "LS0tQkVHSU4=" -> "---BEGIN"
	require.Equal(t, []byte("---BEGIN"), s.TLSStaticCertPEM)
	// Base64-decoded "S0VZLUJFRw==" -> "KEY-BEG"
	require.Equal(t, []byte("KEY-BEG"), s.TLSStaticKeyPEM)
	// Base64-decoded "Q0VSVC0tLQ==" -> "CERT---"
	require.Equal(t, []byte("CERT---"), s.TLSMixedCACertPEM)
	// Base64-decoded "S0VZLUtFWQ==" -> "KEY-KEY"
	require.Equal(t, []byte("KEY-KEY"), s.TLSMixedCAKeyPEM)
	require.Equal(t, "/browser", s.PublicBrowserAPIContextPath)
	require.Equal(t, "/service", s.PublicServiceAPIContextPath)
	require.Equal(t, []string{"https://example.com"}, s.CORSAllowedOrigins)
	require.Equal(t, []string{"GET", "POST"}, s.CORSAllowedMethods)
	require.Equal(t, []string{"X-Custom-Header"}, s.CORSAllowedHeaders)
	require.Equal(t, uint16(1800), s.CORSMaxAge)
	require.Equal(t, "custom_csrf", s.CSRFTokenName)
	require.Equal(t, "Lax", s.CSRFTokenSameSite)
	require.Equal(t, 24*time.Hour, s.CSRFTokenMaxAge)
	require.Equal(t, false, s.CSRFTokenCookieSecure)
	require.Equal(t, false, s.CSRFTokenCookieHTTPOnly)
	require.Equal(t, false, s.CSRFTokenCookieSessionOnly)
	require.Equal(t, true, s.CSRFTokenSingleUseToken)
	require.Equal(t, uint16(100), s.BrowserIPRateLimit)
	require.Equal(t, uint16(50), s.ServiceIPRateLimit)
	require.Equal(t, []string{"192.168.1.100", "192.168.1.101"}, s.AllowedIPs)
	require.Equal(t, []string{"10.0.0.0/8", "192.168.1.0/24"}, s.AllowedCIDRs)
	require.Equal(t, "required", s.DatabaseContainer)
	require.Equal(t, "postgres://user:pass@db:5432/dbname?sslmode=disable", s.DatabaseURL)
	require.Equal(t, 5*time.Minute, s.DatabaseInitTotalTimeout)
	require.Equal(t, 30*time.Second, s.DatabaseInitRetryWait)
	require.True(t, s.OTLPEnabled)
	require.True(t, s.OTLPConsole)
	require.Equal(t, "my-service", s.OTLPService)
	require.Equal(t, "my-instance", s.OTLPInstance)
	require.Equal(t, "1.0.0", s.OTLPVersion)
	require.Equal(t, "development", s.OTLPEnvironment)
	require.Equal(t, "example.com", s.OTLPHostname)
	require.Equal(t, "grpc://example.com:4317", s.OTLPEndpoint)
	require.True(t, s.DevMode)
	require.Equal(t, "2-of-3", s.UnsealMode)
	require.Equal(t, []string{"/docker/secrets/unseal1", "/docker/secrets/unseal2", "/docker/secrets/unseal3"}, s.UnsealFiles)
}

func TestAnalyzeSettings_RealSettings(t *testing.T) {
	result := analyzeSettings(allServeiceTemplateServerRegisteredSettings)

	totalMappedByName := 0
	for _, settings := range result.SettingsByNames {
		totalMappedByName += len(settings)
	}

	require.Equal(t, len(allServeiceTemplateServerRegisteredSettings), totalMappedByName, "All settings should be accounted for by name")

	// Count settings with non-empty shorthands
	settingsWithShorthands := 0

	for _, setting := range allServeiceTemplateServerRegisteredSettings {
		if setting.Shorthand != "" {
			settingsWithShorthands++
		}
	}

	totalMappedByShorthand := 0
	for _, settings := range result.SettingsByShorthands {
		totalMappedByShorthand += len(settings)
	}

	require.Equal(t, settingsWithShorthands, totalMappedByShorthand, "All settings with non-empty shorthands should be accounted for")

	require.Empty(t, result.DuplicateNames, "Production settings should have no duplicate names")
	require.Empty(t, result.DuplicateShorthands, "Production settings should have no duplicate shorthands")

	for name, settings := range result.SettingsByNames {
		require.Len(t, settings, 1, "Setting name '%s' should be unique", name)
	}

	for shorthand, settings := range result.SettingsByShorthands {
		require.Len(t, settings, 1, "Setting shorthand '%s' should be unique", shorthand)
	}
}

func TestAnalyzeSettings_NoDuplicates(t *testing.T) {
	result := analyzeSettings([]*Setting{
		{Name: "unique1", Shorthand: "a", Value: "value1", Usage: "usage1"},
		{Name: "unique2", Shorthand: "b", Value: "value2", Usage: "usage2"},
		{Name: "unique3", Shorthand: "c", Value: "value3", Usage: "usage3"},
	})

	require.Len(t, result.SettingsByNames, 3)
	require.Len(t, result.SettingsByNames["unique1"], 1)
	require.Len(t, result.SettingsByNames["unique2"], 1)
	require.Len(t, result.SettingsByNames["unique3"], 1)
	require.Equal(t, "unique1", result.SettingsByNames["unique1"][0].Name)
	require.Equal(t, "unique2", result.SettingsByNames["unique2"][0].Name)
	require.Equal(t, "unique3", result.SettingsByNames["unique3"][0].Name)

	require.Len(t, result.SettingsByShorthands, 3)
	require.Len(t, result.SettingsByShorthands["a"], 1)
	require.Len(t, result.SettingsByShorthands["b"], 1)
	require.Len(t, result.SettingsByShorthands["c"], 1)
	require.Equal(t, "a", result.SettingsByShorthands["a"][0].Shorthand)
	require.Equal(t, "b", result.SettingsByShorthands["b"][0].Shorthand)
	require.Equal(t, "c", result.SettingsByShorthands["c"][0].Shorthand)

	require.Empty(t, result.DuplicateNames)

	require.Empty(t, result.DuplicateShorthands)
}

func TestAnalyzeSettings_DuplicateNamesOnly(t *testing.T) {
	result := analyzeSettings([]*Setting{
		{Name: "duplicate", Shorthand: "a", Value: "value1", Usage: "usage1"},
		{Name: "duplicate", Shorthand: "b", Value: "value2", Usage: "usage2"},
		{Name: "unique", Shorthand: "c", Value: "value3", Usage: "usage3"},
	})

	require.Len(t, result.SettingsByNames, 2)
	require.Len(t, result.SettingsByNames["duplicate"], 2)
	require.Len(t, result.SettingsByNames["unique"], 1)

	require.Contains(t, result.DuplicateNames, "duplicate")
	require.NotContains(t, result.DuplicateNames, "unique")

	require.Empty(t, result.DuplicateShorthands)
}

func TestAnalyzeSettings_DuplicateShorthandsOnly(t *testing.T) {
	result := analyzeSettings([]*Setting{
		{Name: "unique1", Shorthand: "d", Value: "value1", Usage: "usage1"},
		{Name: "unique2", Shorthand: "d", Value: "value2", Usage: "usage2"},
		{Name: "unique3", Shorthand: "u", Value: "value3", Usage: "usage3"},
	})

	require.Len(t, result.SettingsByShorthands, 2)
	require.Len(t, result.SettingsByShorthands["d"], 2)
	require.Len(t, result.SettingsByShorthands["u"], 1)

	require.Empty(t, result.DuplicateNames)

	require.Contains(t, result.DuplicateShorthands, "d")
	require.NotContains(t, result.DuplicateShorthands, "u")
}

func TestAnalyzeSettings_DuplicateNames_And_DuplicateShorthands(t *testing.T) {
	result := analyzeSettings([]*Setting{
		{Name: "duplicate", Shorthand: "d", Value: "value1", Usage: "usage1"},
		{Name: "duplicate", Shorthand: "d", Value: "value2", Usage: "usage2"},
		{Name: "unique1", Shorthand: "u", Value: "value3", Usage: "usage3"},
		{Name: "unique2", Shorthand: "U", Value: "value4", Usage: "usage4"},
	})

	require.Len(t, result.SettingsByNames, 3)
	require.Len(t, result.SettingsByNames["duplicate"], 2)
	require.Len(t, result.SettingsByNames["unique1"], 1)
	require.Len(t, result.SettingsByNames["unique2"], 1)

	require.Len(t, result.SettingsByShorthands, 3)
	require.Len(t, result.SettingsByShorthands["d"], 2)
	require.Len(t, result.SettingsByShorthands["u"], 1)
	require.Len(t, result.SettingsByShorthands["U"], 1)

	require.Contains(t, result.DuplicateNames, "duplicate")
	require.NotContains(t, result.DuplicateNames, "unique1")
	require.NotContains(t, result.DuplicateNames, "unique2")

	require.Contains(t, result.DuplicateShorthands, "d")
	require.NotContains(t, result.DuplicateShorthands, "u")
	require.NotContains(t, result.DuplicateShorthands, "U")
}

func TestParse_EnvironmentVariables(t *testing.T) {
	resetFlags()

	// Set environment variables
	t.Setenv("CRYPTOUTIL_LOG_LEVEL", "DEBUG")
	t.Setenv("CRYPTOUTIL_DEV", "true")
	t.Setenv("CRYPTOUTIL_BIND_PUBLIC_PORT", "8080")
	t.Setenv("CRYPTOUTIL_DATABASE_URL", "postgres://env:pass@envdb:5432/envdb?sslmode=require")

	commandParameters := []string{"start"}
	s, err := Parse(commandParameters, false)
	require.NoError(t, err)

	// Verify environment variables were loaded
	require.Equal(t, "DEBUG", s.LogLevel)
	require.True(t, s.DevMode)
	require.Equal(t, uint16(8080), s.BindPublicPort)
	require.Equal(t, "postgres://env:pass@envdb:5432/envdb?sslmode=require", s.DatabaseURL)
}

func TestParse_EnvironmentVariables_CommandLineOverride(t *testing.T) {
	resetFlags()

	// Set environment variables
	t.Setenv("CRYPTOUTIL_LOG_LEVEL", "DEBUG")
	t.Setenv("CRYPTOUTIL_DEV", "true")

	// Override with command line flags
	commandParameters := []string{"start", "--log-level=INFO", "--dev=false"}
	s, err := Parse(commandParameters, false)
	require.NoError(t, err)

	// Command line flags should override environment variables
	require.Equal(t, "INFO", s.LogLevel)
	require.False(t, s.DevMode)
}

func TestParse_DryRun(t *testing.T) {
	resetFlags()

	commandParameters := []string{"start", "--dry-run"}
	s, err := Parse(commandParameters, false)
	require.NoError(t, err)
	require.True(t, s.DryRun)
}

func TestParse_DryRun_Default(t *testing.T) {
	resetFlags()

	commandParameters := []string{"start"}
	s, err := Parse(commandParameters, false)
	require.NoError(t, err)
	require.False(t, s.DryRun)
}

func TestValidateConfiguration_HappyPath(t *testing.T) {
	t.Parallel()

	s := &ServiceTemplateServerSettings{
		BindPublicAddress:   "127.0.0.1",
		BindPrivateAddress:  "127.0.0.1",
		BindPublicPort:      8080,
		BindPrivatePort:     9090,
		BindPublicProtocol:  "https",
		BindPrivateProtocol: "https",
		TLSPublicDNSNames:   []string{"public.example.com"},
		TLSPrivateDNSNames:  []string{"private.example.com"},
		DatabaseURL:         "postgres://user:pass@localhost:5432/db",
		CORSAllowedOrigins:  []string{"https://example.com"},
		LogLevel:            "INFO",
		BrowserIPRateLimit:  100,
		ServiceIPRateLimit:  200,
		OTLPEnabled:         true,
		OTLPEndpoint:        "grpc://otel:4317",
	}

	err := validateConfiguration(s)
	require.NoError(t, err)
}

func TestValidateConfiguration_Errors(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		settings *ServiceTemplateServerSettings
		errMsg   string
	}{
		{
			name: "blank public bind address",
			settings: &ServiceTemplateServerSettings{
				BindPublicAddress:   "",
				BindPrivateAddress:  "127.0.0.1",
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			errMsg: "bind public address cannot be blank",
		},
		{
			name: "blank private bind address",
			settings: &ServiceTemplateServerSettings{
				BindPublicAddress:   "127.0.0.1",
				BindPrivateAddress:  "",
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			errMsg: "bind private address cannot be blank",
		},
		{
			name: "same non-zero ports",
			settings: &ServiceTemplateServerSettings{
				BindPublicPort:      8080,
				BindPrivatePort:     8080,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			errMsg: "cannot be the same",
		},
		{
			name: "invalid public protocol",
			settings: &ServiceTemplateServerSettings{
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "ftp",
				BindPrivateProtocol: "https",
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			errMsg: "invalid public protocol 'ftp'",
		},
		{
			name: "invalid private protocol",
			settings: &ServiceTemplateServerSettings{
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "ftp",
				TLSPublicDNSNames:   []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			errMsg: "invalid private protocol 'ftp'",
		},
		{
			name: "https public missing TLS config",
			settings: &ServiceTemplateServerSettings{
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "http",
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			errMsg: "HTTPS public protocol requires TLS DNS names or IP addresses",
		},
		{
			name: "https private missing TLS config",
			settings: &ServiceTemplateServerSettings{
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "http",
				BindPrivateProtocol: "https",
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			errMsg: "HTTPS private protocol requires TLS DNS names or IP addresses",
		},
		{
			name: "invalid database URL format",
			settings: &ServiceTemplateServerSettings{
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				DatabaseURL:         "invalid-no-scheme",
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			errMsg: "invalid database URL format",
		},
		{
			name: "invalid CORS origin format",
			settings: &ServiceTemplateServerSettings{
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				CORSAllowedOrigins:  []string{"invalid-no-scheme"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			errMsg: "invalid CORS origin format",
		},
		{
			name: "invalid log level",
			settings: &ServiceTemplateServerSettings{
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INVALID",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			errMsg: "invalid log level 'INVALID'",
		},
		{
			name: "browser rate limit zero",
			settings: &ServiceTemplateServerSettings{
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  0,
				ServiceIPRateLimit:  100,
			},
			errMsg: "browser rate limit cannot be 0",
		},
		{
			name: "service rate limit zero",
			settings: &ServiceTemplateServerSettings{
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  0,
			},
			errMsg: "service rate limit cannot be 0",
		},
		{
			name: "invalid OTLP endpoint format",
			settings: &ServiceTemplateServerSettings{
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
				OTLPEnabled:         true,
				OTLPEndpoint:        "invalid-no-scheme:4317",
			},
			errMsg: "invalid OTLP endpoint format",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			err := validateConfiguration(tc.settings)
			require.Error(t, err)
			require.Contains(t, err.Error(), tc.errMsg)
		})
	}
}

// TestValidateConfiguration_BoundaryConditions tests edge cases at validation boundaries.
// Kills mutation: config.go:1526 (CONDITIONALS_BOUNDARY: > vs >=).
// Kills mutation: config.go:1530 (CONDITIONALS_BOUNDARY: > vs >=).
// Kills mutation: config.go:1593 (CONDITIONALS_BOUNDARY: > vs >=).
// Kills mutation: config.go:1599 (CONDITIONALS_BOUNDARY: > vs >=).
func TestValidateConfiguration_BoundaryConditions(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		settings *ServiceTemplateServerSettings
		wantErr  bool
		errMsg   string
	}{
		{
			name: "public port exactly 65535 - valid",
			settings: &ServiceTemplateServerSettings{
				BindPublicAddress:   "127.0.0.1",
				BindPrivateAddress:  "127.0.0.1",
				BindPublicPort:      65535,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			wantErr: false,
		},
		{
			name: "private port exactly 65535 - valid",
			settings: &ServiceTemplateServerSettings{
				BindPublicAddress:   "127.0.0.1",
				BindPrivateAddress:  "127.0.0.1",
				BindPublicPort:      8080,
				BindPrivatePort:     65535,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  100,
			},
			wantErr: false,
		},
		{
			name: "browser rate limit exactly MaxIPRateLimit - valid warning",
			settings: &ServiceTemplateServerSettings{
				BindPublicAddress:   "127.0.0.1",
				BindPrivateAddress:  "127.0.0.1",
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  10000, // cryptoutilSharedMagic.MaxIPRateLimit
				ServiceIPRateLimit:  100,
			},
			wantErr: false,
		},
		{
			name: "browser rate limit above MaxIPRateLimit - warning",
			settings: &ServiceTemplateServerSettings{
				BindPublicAddress:   "127.0.0.1",
				BindPrivateAddress:  "127.0.0.1",
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  10001,
				ServiceIPRateLimit:  100,
			},
			wantErr: true,
			errMsg:  "browser rate limit 10001 is very high",
		},
		{
			name: "service rate limit exactly MaxIPRateLimit - valid warning",
			settings: &ServiceTemplateServerSettings{
				BindPublicAddress:   "127.0.0.1",
				BindPrivateAddress:  "127.0.0.1",
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  10000, // cryptoutilSharedMagic.MaxIPRateLimit
			},
			wantErr: false,
		},
		{
			name: "service rate limit above MaxIPRateLimit - warning",
			settings: &ServiceTemplateServerSettings{
				BindPublicAddress:   "127.0.0.1",
				BindPrivateAddress:  "127.0.0.1",
				BindPublicPort:      8080,
				BindPrivatePort:     9090,
				BindPublicProtocol:  "https",
				BindPrivateProtocol: "https",
				TLSPublicDNSNames:   []string{"test.com"},
				TLSPrivateDNSNames:  []string{"test.com"},
				LogLevel:            "INFO",
				BrowserIPRateLimit:  100,
				ServiceIPRateLimit:  10001,
			},
			wantErr: true,
			errMsg:  "service rate limit 10001 is very high",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			err := validateConfiguration(tc.settings)
			if tc.wantErr {
				require.Error(t, err)
				require.Contains(t, err.Error(), tc.errMsg)
			} else {
				if err != nil {
					// Allow warnings that don't prevent startup.
					require.NotContains(t, err.Error(), "invalid")
				}
			}
		})
	}
}

// TestParseWithMultipleConfigFiles tests config file merging with multiple files.
// Kills mutation: config.go:1046 (INCREMENT_DECREMENT: i++ vs i--).
func TestParseWithMultipleConfigFiles(t *testing.T) {
	resetFlags()

	// Create two temporary config files.
	configFile1 := t.TempDir() + "/config1.yaml"
	configFile2 := t.TempDir() + "/config2.yaml"

	// Write first config file (base settings).
	config1Content := `
log-level: INFO
bind-public-port: 8080
browser-ip-rate-limit: 100
`
	err := os.WriteFile(configFile1, []byte(config1Content), 0o600)
	require.NoError(t, err)

	// Write second config file (overrides).
	config2Content := `
log-level: DEBUG
bind-public-port: 9080
service-rate-limit: 200
`
	err = os.WriteFile(configFile2, []byte(config2Content), 0o600)
	require.NoError(t, err)

	// Parse with multiple config files (second should override first).
	commandParameters := []string{
		"start",
		"--config=" + configFile1,
		"--config=" + configFile2,
	}

	s, err := Parse(commandParameters, true)
	require.NoError(t, err)

	// Verify second config file values override first.
	require.Equal(t, "DEBUG", s.LogLevel, "second config should override log-level")
	require.Equal(t, uint16(9080), s.BindPublicPort, "second config should override bind-public-port")
	require.Equal(t, uint16(200), s.ServiceIPRateLimit, "second config should set service-rate-limit")
	require.Equal(t, uint16(100), s.BrowserIPRateLimit, "first config browser-ip-rate-limit should remain")
}

// TestFormatDefault_EmptyStringSlice tests formatDefault with empty []string.
// Kills mutation: config.go:1459 (CONDITIONALS_NEGATION: len(v) == 0 vs len(v) != 0).
func TestFormatDefault_EmptyStringSlice(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		value    any
		expected string
	}{
		{
			name:     "empty string slice",
			value:    []string{},
			expected: "[]",
		},
		{
			name:     "single element string slice",
			value:    []string{"one"},
			expected: "[one]",
		},
		{
			name:     "multi element string slice",
			value:    []string{"one", "two", "three"},
			expected: "[one,two,three]",
		},
		{
			name:     "empty string",
			value:    "",
			expected: `""`,
		},
		{
			name:     "non-empty string",
			value:    "test",
			expected: `"test"`,
		},
		{
			name:     "boolean true",
			value:    true,
			expected: "true",
		},
		{
			name:     "boolean false",
			value:    false,
			expected: "false",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			result := formatDefault(tc.value)
			require.Equal(t, tc.expected, result)
		})
	}
}

// TestParse_BooleanEnvironmentVariableBinding tests that boolean settings are bound to environment variables.
// Kills mutation: config.go:949 (CONDITIONALS_NEGATION: if _, ok := setting.Value.(bool); ok).
func TestParse_BooleanEnvironmentVariableBinding(t *testing.T) {
	resetFlags()

	// Set environment variables for boolean settings
	t.Setenv("CRYPTOUTIL_DEV", "true")
	t.Setenv("CRYPTOUTIL_VERBOSE", "true")
	t.Setenv("CRYPTOUTIL_DRY_RUN", "true")

	// Parse without any command line flags (environment variables should be used)
	commandParameters := []string{"start"}
	s, err := Parse(commandParameters, true)
	require.NoError(t, err)

	// Verify boolean environment variables were bound and parsed correctly
	require.True(t, s.DevMode, "CRYPTOUTIL_DEV should set DevMode to true")
	require.True(t, s.VerboseMode, "CRYPTOUTIL_VERBOSE should set VerboseMode to true")
	require.True(t, s.DryRun, "CRYPTOUTIL_DRY_RUN should set DryRun to true")

	// Verify that flag overrides environment variable (precedence test)
	resetFlags()
	t.Setenv("CRYPTOUTIL_DEV", "true")

	commandParameters = []string{"start", "--dev=false"}
	s, err = Parse(commandParameters, true)
	require.NoError(t, err)
	require.False(t, s.DevMode, "flag should override environment variable")
}
