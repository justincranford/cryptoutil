// Copyright (c) 2025 Iwan van der Kleijn
// SPDX-License-Identifier: MIT

package authz_test

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"testing"
	"time"

	"github.com/gofiber/fiber/v2"
	googleUuid "github.com/google/uuid"
	"github.com/stretchr/testify/require"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	_ "modernc.org/sqlite" // CGO-free SQLite driver.

	cryptoutilIdentityAuthz "cryptoutil/internal/identity/authz"
	cryptoutilIdentityDomain "cryptoutil/internal/identity/domain"
	cryptoutilMagic "cryptoutil/internal/identity/magic"
	cryptoutilIdentityRepository "cryptoutil/internal/identity/repository"
	cryptoutilIdentityORM "cryptoutil/internal/identity/repository/orm"
)

// createRecoveryCodeTestDependencies creates test database and repositories.
func createRecoveryCodeTestDependencies(t *testing.T) *cryptoutilIdentityRepository.RepositoryFactory {
	t.Helper()

	// Use modernc.org/sqlite driver (CGO-free).
	sqlDB, err := sql.Open("sqlite", "file::memory:?cache=private")
	require.NoError(t, err)

	db, err := gorm.Open(sqlite.Dialector{Conn: sqlDB}, &gorm.Config{
		SkipDefaultTransaction: true,
	})
	require.NoError(t, err)

	// Auto-migrate schemas.
	err = db.AutoMigrate(
		&cryptoutilIdentityDomain.RecoveryCode{},
		&cryptoutilIdentityDomain.User{},
	)
	require.NoError(t, err)

	// Create repository factory using NewRepositoryFactory pattern.
	// For tests, we manually construct with required repos only.
	repos := &cryptoutilIdentityRepository.RepositoryFactory{}
	// Use reflection or direct assignment if fields were exported,
	// but since they're not, we need a different approach.
	// Let's use the actual factory constructor with a minimal config.

	// Actually, let's just use the ORM repositories directly.
	recoveryCodeRepo := cryptoutilIdentityORM.NewRecoveryCodeRepository(db)
	userRepo := cryptoutilIdentityORM.NewUserRepository(db)

	// Since we can't set private fields, we'll return individual repos in a wrapper.
	// For now, return nil and adjust test to use repos directly.
	_, _ = recoveryCodeRepo, userRepo

	return repos
}

// createTestUserForRecoveryCodes creates a user for recovery code testing.
func createTestUserForRecoveryCodes(t *testing.T, userRepo cryptoutilIdentityRepository.UserRepository) *cryptoutilIdentityDomain.User {
	t.Helper()

	user := &cryptoutilIdentityDomain.User{
		ID:                googleUuid.New(),
		Sub:               fmt.Sprintf("sub-%s", googleUuid.New().String()),
		PreferredUsername: fmt.Sprintf("testuser-%s", googleUuid.New().String()),
		Email:             fmt.Sprintf("test-%s@example.com", googleUuid.New().String()),
		PasswordHash:      "hash",
		Enabled:           true,
		CreatedAt:         time.Now().UTC(),
		UpdatedAt:         time.Now().UTC(),
	}

	err := userRepo.Create(context.Background(), user)
	require.NoError(t, err)

	return user
}

func TestHandleGenerateRecoveryCodes_HappyPath(t *testing.T) {
	t.Parallel()

	repos := createRecoveryCodeTestDependencies(t)
	user := createTestUserForRecoveryCodes(t, repos)

	// Create service.
	service := cryptoutilIdentityAuthz.NewService(repos, nil, nil)

	// Create Fiber app.
	app := fiber.New()
	service.RegisterRoutes(app)

	// Make request.
	reqBody := map[string]string{"user_id": user.ID.String()}
	jsonBody, err := json.Marshal(reqBody)
	require.NoError(t, err)

	req, err := http.NewRequest(http.MethodPost, "/oidc/v1/mfa/recovery-codes/generate", bytes.NewBuffer(jsonBody))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/json")

	resp, err := app.Test(req, -1)
	require.NoError(t, err)
	require.Equal(t, fiber.StatusCreated, resp.StatusCode)

	// Parse response.
	body, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	require.NoError(t, resp.Body.Close())

	var response cryptoutilIdentityAuthz.GenerateRecoveryCodesResponse
	err = json.Unmarshal(body, &response)
	require.NoError(t, err)

	// Verify response.
	require.Len(t, response.Codes, cryptoutilMagic.DefaultRecoveryCodeCount, "should generate 10 codes")
	require.NotEmpty(t, response.ExpiresAt)

	// Verify codes format: XXXX-XXXX-XXXX-XXXX.
	for _, code := range response.Codes {
		require.Len(t, code, 19, "code should be 19 characters (16 chars + 3 hyphens)")
		require.Regexp(t, `^[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}$`, code)
	}
}

func TestHandleGenerateRecoveryCodes_MissingUserID(t *testing.T) {
	t.Parallel()

	repos := createRecoveryCodeTestDependencies(t)

	// Create service.
	service := cryptoutilIdentityAuthz.NewService(repos, nil, nil)

	// Create Fiber app.
	app := fiber.New()
	service.RegisterRoutes(app)

	// Make request with missing user_id.
	reqBody := map[string]string{}
	jsonBody, err := json.Marshal(reqBody)
	require.NoError(t, err)

	req, err := http.NewRequest(http.MethodPost, "/oidc/v1/mfa/recovery-codes/generate", bytes.NewBuffer(jsonBody))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/json")

	resp, err := app.Test(req, -1)
	require.NoError(t, err)
	require.Equal(t, fiber.StatusBadRequest, resp.StatusCode)

	// Parse error response.
	body, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	require.NoError(t, resp.Body.Close())

	var errorResp map[string]string
	err = json.Unmarshal(body, &errorResp)
	require.NoError(t, err)
	require.Equal(t, "invalid_request", errorResp["error"])
	require.Contains(t, errorResp["error_description"], "Missing user_id parameter")
}

func TestHandleGenerateRecoveryCodes_InvalidUserID(t *testing.T) {
	t.Parallel()

	repos := createRecoveryCodeTestDependencies(t)

	// Create service.
	service := cryptoutilIdentityAuthz.NewService(repos, nil, nil)

	// Create Fiber app.
	app := fiber.New()
	service.RegisterRoutes(app)

	// Make request with invalid user_id.
	reqBody := map[string]string{"user_id": "not-a-uuid"}
	jsonBody, err := json.Marshal(reqBody)
	require.NoError(t, err)

	req, err := http.NewRequest(http.MethodPost, "/oidc/v1/mfa/recovery-codes/generate", bytes.NewBuffer(jsonBody))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/json")

	resp, err := app.Test(req, -1)
	require.NoError(t, err)
	require.Equal(t, fiber.StatusBadRequest, resp.StatusCode)

	// Parse error response.
	body, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	require.NoError(t, resp.Body.Close())

	var errorResp map[string]string
	err = json.Unmarshal(body, &errorResp)
	require.NoError(t, err)
	require.Equal(t, "invalid_request", errorResp["error"])
	require.Contains(t, errorResp["error_description"], "Invalid user_id format")
}

func TestHandleGenerateRecoveryCodes_UserNotFound(t *testing.T) {
	t.Parallel()

	repos := createRecoveryCodeTestDependencies(t)

	// Create service.
	service := cryptoutilIdentityAuthz.NewService(repos, nil, nil)

	// Create Fiber app.
	app := fiber.New()
	service.RegisterRoutes(app)

	// Make request with non-existent user_id.
	reqBody := map[string]string{"user_id": googleUuid.New().String()}
	jsonBody, err := json.Marshal(reqBody)
	require.NoError(t, err)

	req, err := http.NewRequest(http.MethodPost, "/oidc/v1/mfa/recovery-codes/generate", bytes.NewBuffer(jsonBody))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/json")

	resp, err := app.Test(req, -1)
	require.NoError(t, err)
	require.Equal(t, fiber.StatusNotFound, resp.StatusCode)

	// Parse error response.
	body, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	require.NoError(t, resp.Body.Close())

	var errorResp map[string]string
	err = json.Unmarshal(body, &errorResp)
	require.NoError(t, err)
	require.Equal(t, "user_not_found", errorResp["error"])
}

func TestHandleGetRecoveryCodeCount_HappyPath(t *testing.T) {
	t.Parallel()

	repos := createRecoveryCodeTestDependencies(t)
	user := createTestUserForRecoveryCodes(t, repos)

	// Create service.
	service := cryptoutilIdentityAuthz.NewService(repos, nil, nil)

	// Create Fiber app.
	app := fiber.New()
	service.RegisterRoutes(app)

	// Generate codes first.
	reqBody := map[string]string{"user_id": user.ID.String()}
	jsonBody, err := json.Marshal(reqBody)
	require.NoError(t, err)

	req, err := http.NewRequest(http.MethodPost, "/oidc/v1/mfa/recovery-codes/generate", bytes.NewBuffer(jsonBody))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/json")

	resp, err := app.Test(req, -1)
	require.NoError(t, err)
	require.Equal(t, fiber.StatusCreated, resp.StatusCode)
	require.NoError(t, resp.Body.Close())

	// Get count.
	req, err = http.NewRequest(http.MethodGet, fmt.Sprintf("/oidc/v1/mfa/recovery-codes/count?user_id=%s", user.ID.String()), nil)
	require.NoError(t, err)

	resp, err = app.Test(req, -1)
	require.NoError(t, err)
	require.Equal(t, fiber.StatusOK, resp.StatusCode)

	// Parse response.
	body, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	require.NoError(t, resp.Body.Close())

	var countResp cryptoutilIdentityAuthz.RecoveryCodeCountResponse
	err = json.Unmarshal(body, &countResp)
	require.NoError(t, err)

	require.Equal(t, int64(10), countResp.Remaining)
	require.Equal(t, int64(10), countResp.Total)
}

func TestHandleRegenerateRecoveryCodes_HappyPath(t *testing.T) {
	t.Parallel()

	repos := createRecoveryCodeTestDependencies(t)
	user := createTestUserForRecoveryCodes(t, repos)

	// Create service.
	service := cryptoutilIdentityAuthz.NewService(repos, nil, nil)

	// Create Fiber app.
	app := fiber.New()
	service.RegisterRoutes(app)

	// Generate initial codes.
	reqBody := map[string]string{"user_id": user.ID.String()}
	jsonBody, err := json.Marshal(reqBody)
	require.NoError(t, err)

	req, err := http.NewRequest(http.MethodPost, "/oidc/v1/mfa/recovery-codes/generate", bytes.NewBuffer(jsonBody))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/json")

	resp, err := app.Test(req, -1)
	require.NoError(t, err)
	require.Equal(t, fiber.StatusCreated, resp.StatusCode)

	body, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	require.NoError(t, resp.Body.Close())

	var initialResp cryptoutilIdentityAuthz.GenerateRecoveryCodesResponse
	err = json.Unmarshal(body, &initialResp)
	require.NoError(t, err)
	oldCodes := initialResp.Codes

	// Regenerate codes.
	req, err = http.NewRequest(http.MethodPost, "/oidc/v1/mfa/recovery-codes/regenerate", bytes.NewBuffer(jsonBody))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/json")

	resp, err = app.Test(req, -1)
	require.NoError(t, err)
	require.Equal(t, fiber.StatusCreated, resp.StatusCode)

	body, err = io.ReadAll(resp.Body)
	require.NoError(t, err)
	require.NoError(t, resp.Body.Close())

	var newResp cryptoutilIdentityAuthz.GenerateRecoveryCodesResponse
	err = json.Unmarshal(body, &newResp)
	require.NoError(t, err)
	newCodes := newResp.Codes

	// Verify new codes are different from old codes.
	for _, oldCode := range oldCodes {
		require.NotContains(t, newCodes, oldCode, "new codes should not contain old codes")
	}
}

func TestHandleVerifyRecoveryCode_MissingUserID(t *testing.T) {
	t.Parallel()

	repos := createRecoveryCodeTestDependencies(t)

	// Create service.
	service := cryptoutilIdentityAuthz.NewService(repos, nil, nil)

	// Create Fiber app.
	app := fiber.New()
	service.RegisterRoutes(app)

	// Make request without X-User-ID header.
	reqBody := map[string]string{"code": "XXXX-XXXX-XXXX-XXXX"}
	jsonBody, err := json.Marshal(reqBody)
	require.NoError(t, err)

	req, err := http.NewRequest(http.MethodPost, "/oidc/v1/mfa/verify-recovery-code", bytes.NewBuffer(jsonBody))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/json")

	resp, err := app.Test(req, -1)
	require.NoError(t, err)
	require.Equal(t, fiber.StatusUnauthorized, resp.StatusCode)

	// Parse error response.
	body, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	require.NoError(t, resp.Body.Close())

	var errorResp map[string]string
	err = json.Unmarshal(body, &errorResp)
	require.NoError(t, err)
	require.Equal(t, "unauthorized", errorResp["error"])
}

func TestHandleVerifyRecoveryCode_InvalidCode(t *testing.T) {
	t.Parallel()

	repos := createRecoveryCodeTestDependencies(t)
	user := createTestUserForRecoveryCodes(t, repos)

	// Create service.
	service := cryptoutilIdentityAuthz.NewService(repos, nil, nil)

	// Create Fiber app.
	app := fiber.New()
	service.RegisterRoutes(app)

	// Generate codes first.
	reqBody := map[string]string{"user_id": user.ID.String()}
	jsonBody, err := json.Marshal(reqBody)
	require.NoError(t, err)

	req, err := http.NewRequest(http.MethodPost, "/oidc/v1/mfa/recovery-codes/generate", bytes.NewBuffer(jsonBody))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/json")

	resp, err := app.Test(req, -1)
	require.NoError(t, err)
	require.Equal(t, fiber.StatusCreated, resp.StatusCode)
	require.NoError(t, resp.Body.Close())

	// Try to verify invalid code.
	reqBody = map[string]string{"code": "XXXX-XXXX-XXXX-XXXX"}
	jsonBody, err = json.Marshal(reqBody)
	require.NoError(t, err)

	req, err = http.NewRequest(http.MethodPost, "/oidc/v1/mfa/verify-recovery-code", bytes.NewBuffer(jsonBody))
	require.NoError(t, err)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-User-ID", user.ID.String())

	resp, err = app.Test(req, -1)
	require.NoError(t, err)
	require.Equal(t, fiber.StatusUnauthorized, resp.StatusCode)

	// Parse error response.
	body, err := io.ReadAll(resp.Body)
	require.NoError(t, err)
	require.NoError(t, resp.Body.Close())

	var errorResp map[string]string
	err = json.Unmarshal(body, &errorResp)
	require.NoError(t, err)
	require.Equal(t, "invalid_code", errorResp["error"])
}
