// Copyright (c) 2025 Justin Cranford
//
//

package main

import (
	"context"
	"crypto/rand"
	"crypto/tls"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	cryptoutilMagic "cryptoutil/internal/common/magic"
)

const (
	alphabetSize       = 26              // Number of letters in English alphabet
	tokenExpirySeconds = 3600            // Standard OAuth token expiry time (1 hour)
	healthCheckTimeout = 5 * time.Second // Timeout for health check requests
	mockCertFile       = "mock_cert.pem"
	mockKeyFile        = "mock_key.pem"
	httpMethodOptions  = "OPTIONS" // HTTP OPTIONS method for CORS preflight
)

func getCertPaths() (string, string) {
	// Try to find cert files relative to current executable
	exePath, err := os.Executable()
	if err != nil {
		log.Printf("Failed to get executable path: %v", err)

		return mockCertFile, mockKeyFile
	}

	exeDir := filepath.Dir(exePath)
	certFile := filepath.Join(exeDir, mockCertFile)
	keyFile := filepath.Join(exeDir, mockKeyFile)

	// Check if files exist in exe directory
	if _, err := os.Stat(certFile); os.IsNotExist(err) {
		// Fall back to current working directory
		certFile = mockCertFile
		keyFile = mockKeyFile
	}

	return certFile, keyFile
}

// MockAuthZServer simulates OAuth 2.1 Authorization Server.
func startAuthZServer(ctx context.Context, port int) {
	mux := http.NewServeMux()

	// CORS middleware
	corsHandler := func(handler http.HandlerFunc) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			// Set CORS headers
			w.Header().Set("Access-Control-Allow-Origin", "http://127.0.0.1:8446")
			w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
			w.Header().Set("Access-Control-Allow-Credentials", "true")

			// Handle preflight requests
			if r.Method == httpMethodOptions {
				w.WriteHeader(http.StatusOK)

				return
			}

			handler(w, r)
		}
	}

	mux.HandleFunc("/oauth2/v1/authorize", corsHandler(func(w http.ResponseWriter, r *http.Request) {
		// Simulate OAuth 2.1 authorization code flow
		// Parse the redirect_uri from query parameters
		redirectURI := r.URL.Query().Get("redirect_uri")
		if redirectURI == "" {
			http.Error(w, "redirect_uri is required", http.StatusBadRequest)

			return
		}

		// Generate authorization code and get state
		code := generateRandomString(cryptoutilMagic.TestRandomStringLength16)
		state := r.URL.Query().Get("state")

		// Build redirect URL with authorization code and state
		redirectURL := fmt.Sprintf("%s?code=%s&state=%s", redirectURI, code, state)

		// Perform HTTP redirect
		http.Redirect(w, r, redirectURL, http.StatusFound)
	}))

	mux.HandleFunc("/oauth2/v1/token", corsHandler(func(w http.ResponseWriter, r *http.Request) {
		// Simulate token exchange
		response := map[string]any{
			"access_token":  generateRandomString(cryptoutilMagic.TestRandomStringLength32),
			"token_type":    "Bearer",
			"expires_in":    tokenExpirySeconds,
			"id_token":      generateRandomString(cryptoutilMagic.TestRandomStringLength64),
			"refresh_token": generateRandomString(cryptoutilMagic.TestRandomStringLength32),
		}

		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(response); err != nil {
			log.Printf("Failed to encode token response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	}))

	mux.HandleFunc("/oauth2/v1/introspect", corsHandler(func(w http.ResponseWriter, r *http.Request) {
		// Simulate token introspection
		response := map[string]any{
			"active":     true,
			"client_id":  "spa-client",
			"token_type": "Bearer",
			"exp":        time.Now().Add(time.Hour).Unix(),
			"iat":        time.Now().Unix(),
		}

		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(response); err != nil {
			log.Printf("Failed to encode introspect response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	}))

	mux.HandleFunc("/authorize", corsHandler(func(w http.ResponseWriter, r *http.Request) {
		// Simulate OAuth 2.1 authorization code flow
		response := map[string]any{
			"code":  generateRandomString(cryptoutilMagic.TestRandomStringLength16),
			"state": r.URL.Query().Get("state"),
		}

		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(response); err != nil {
			log.Printf("Failed to encode authorize response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	}))

	mux.HandleFunc("/token", corsHandler(func(w http.ResponseWriter, r *http.Request) {
		// Simulate token exchange
		response := map[string]any{
			"access_token":  generateRandomString(cryptoutilMagic.TestRandomStringLength32),
			"token_type":    "Bearer",
			"expires_in":    tokenExpirySeconds,
			"id_token":      generateRandomString(cryptoutilMagic.TestRandomStringLength64),
			"refresh_token": generateRandomString(cryptoutilMagic.TestRandomStringLength32),
		}

		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(response); err != nil {
			log.Printf("Failed to encode token response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	}))

	mux.HandleFunc("/health", corsHandler(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(map[string]string{"status": "ok", "service": "authz"}); err != nil {
			log.Printf("Failed to encode health response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	}))

	server := &http.Server{
		Addr:    "127.0.0.1:" + fmt.Sprintf("%d", port),
		Handler: mux,
	}

	log.Printf("AuthZ Server starting on port %d", port)

	// Start server in background and don't wait
	go func() {
		log.Printf("AuthZ Server attempting to listen on %s", server.Addr)

		certFile, keyFile := getCertPaths()

		if err := server.ListenAndServeTLS(certFile, keyFile); err != nil && err != http.ErrServerClosed {
			log.Printf("AuthZ Server on port %d failed: %v", port, err)
		} else {
			log.Printf("AuthZ Server on port %d stopped gracefully", port)
		}
	}()
}

// MockIdPServer simulates OIDC Identity Provider.
func startIDPServer(ctx context.Context, port int) {
	mux := http.NewServeMux()

	// CORS middleware
	corsHandler := func(handler http.HandlerFunc) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			// Set CORS headers
			w.Header().Set("Access-Control-Allow-Origin", "http://127.0.0.1:8446")
			w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
			w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
			w.Header().Set("Access-Control-Allow-Credentials", "true")

			// Handle preflight requests
			if r.Method == httpMethodOptions {
				w.WriteHeader(http.StatusOK)

				return
			}

			handler(w, r)
		}
	}

	mux.HandleFunc("/oidc/v1/userinfo", corsHandler(func(w http.ResponseWriter, r *http.Request) {
		// Simulate OIDC UserInfo endpoint
		auth := r.Header.Get("Authorization")
		if !strings.HasPrefix(auth, "Bearer ") {
			http.Error(w, "unauthorized", http.StatusUnauthorized)

			return
		}

		response := map[string]any{
			"sub":            "test_user",
			"name":           "Test User",
			"email":          "test@example.com",
			"email_verified": true,
			"profile":        "https://example.com/profile/test_user",
			"picture":        "https://example.com/avatar/test_user.jpg",
			"updated_at":     time.Now().Unix(),
		}

		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(response); err != nil {
			log.Printf("Failed to encode userinfo response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	}))

	mux.HandleFunc("/login", corsHandler(func(w http.ResponseWriter, r *http.Request) {
		// Simulate successful authentication for any method
		response := map[string]any{
			"success":    true,
			"user_id":    "test_user",
			"session_id": generateRandomString(cryptoutilMagic.TestRandomStringLength16),
		}

		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(response); err != nil {
			log.Printf("Failed to encode login response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	}))

	mux.HandleFunc("/health", corsHandler(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(map[string]string{"status": "ok", "service": "idp"}); err != nil {
			log.Printf("Failed to encode health response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	}))

	server := &http.Server{
		Addr:    "127.0.0.1:" + fmt.Sprintf("%d", port),
		Handler: mux,
	}

	log.Printf("IdP Server starting on port %d", port)

	// Start server in background and don't wait
	go func() {
		certFile, keyFile := getCertPaths()

		if err := server.ListenAndServeTLS(certFile, keyFile); err != nil && err != http.ErrServerClosed {
			log.Printf("IdP Server on port %d failed: %v", port, err)
		}
	}()
}

// MockResourceServer simulates protected API.
func startResourceServer(ctx context.Context, port int) {
	mux := http.NewServeMux()
	mux.HandleFunc("/api/protected", func(w http.ResponseWriter, r *http.Request) {
		auth := r.Header.Get("Authorization")
		if !strings.HasPrefix(auth, "Bearer ") {
			http.Error(w, "unauthorized", http.StatusUnauthorized)

			return
		}

		response := map[string]any{
			"data":    "protected resource",
			"user_id": "test_user",
		}

		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(response); err != nil {
			log.Printf("Failed to encode protected resource response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	})

	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(map[string]string{"status": "ok", "service": "resource"}); err != nil {
			log.Printf("Failed to encode health response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	})

	server := &http.Server{
		Addr:    "127.0.0.1:" + fmt.Sprintf("%d", port),
		Handler: mux,
	}

	log.Printf("Resource Server starting on port %d", port)

	// Start server in background and don't wait
	go func() {
		certFile, keyFile := getCertPaths()

		if err := server.ListenAndServeTLS(certFile, keyFile); err != nil && err != http.ErrServerClosed {
			log.Printf("Resource Server on port %d failed: %v", port, err)
		}
	}()
}

// MockSPARP simulates SPA Relying Party.
func startSPARP(ctx context.Context, port int) {
	mux := http.NewServeMux()
	mux.HandleFunc("/callback", func(w http.ResponseWriter, r *http.Request) {
		code := r.URL.Query().Get("code")
		state := r.URL.Query().Get("state")

		response := map[string]any{
			"code":        code,
			"state":       state,
			"received_at": time.Now().Format(time.RFC3339),
		}

		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(response); err != nil {
			log.Printf("Failed to encode callback response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	})

	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		if err := json.NewEncoder(w).Encode(map[string]string{"status": "ok", "service": "spa-rp"}); err != nil {
			log.Printf("Failed to encode health response: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)

			return
		}
	})

	server := &http.Server{
		Addr:    "127.0.0.1:" + fmt.Sprintf("%d", port),
		Handler: mux,
	}

	log.Printf("SPA RP starting on port %d", port)

	// Start server in background and don't wait
	go func() {
		certFile, keyFile := getCertPaths()

		if err := server.ListenAndServeTLS(certFile, keyFile); err != nil && err != http.ErrServerClosed {
			log.Printf("SPA RP on port %d failed: %v", port, err)
		}
	}()
}

func generateRandomString(length int) string {
	bytes := make([]byte, length)
	if _, err := rand.Read(bytes); err != nil {
		log.Printf("Failed to generate random string: %v", err)
		// Fallback to a simple pattern for testing
		for i := range bytes {
			bytes[i] = 'A' + byte(i%alphabetSize) // A-Z pattern
		}
	}

	return base64.URLEncoding.EncodeToString(bytes)[:length]
}

func testHealthEndpoints() {
	// Give servers time to start
	time.Sleep(2 * time.Second)

	endpoints := []struct {
		url      string
		expected string
	}{
		{"https://127.0.0.1:8080/health", "authz"},
		{"https://127.0.0.1:8081/health", "idp"},
		{"https://127.0.0.1:8082/health", "resource"},
		{"https://127.0.0.1:8083/health", "spa-rp"},
	}

	client := &http.Client{
		Timeout: healthCheckTimeout,
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		},
	}

	for _, ep := range endpoints {
		req, err := http.NewRequestWithContext(context.Background(), "GET", ep.url, nil)
		if err != nil {
			log.Printf("❌ Health check FAILED for %s: failed to create request: %v", ep.url, err)

			continue
		}

		resp, err := client.Do(req)
		if err != nil {
			log.Printf("❌ Health check FAILED for %s: %v", ep.url, err)

			continue
		}

		defer func() {
			if closeErr := resp.Body.Close(); closeErr != nil {
				log.Printf("⚠️  Failed to close response body: %v", closeErr)
			}
		}()

		var result map[string]string
		if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
			log.Printf("❌ Health check FAILED for %s: invalid JSON response", ep.url)

			continue
		}

		if result["status"] == "ok" && result["service"] == ep.expected {
			log.Printf("✅ Health check PASSED for %s", ep.url)
		} else {
			log.Printf("❌ Health check FAILED for %s: unexpected response %+v", ep.url, result)
		}
	}
}

func main() {
	log.Println("Starting mock identity services...")

	// Start all mock services - they will run until the process is killed
	startAuthZServer(context.Background(), cryptoutilMagic.TestAuthZServerPort)
	startIDPServer(context.Background(), cryptoutilMagic.TestIDPServerPort)
	startResourceServer(context.Background(), cryptoutilMagic.TestResourceServerPort)
	startSPARP(context.Background(), cryptoutilMagic.TestSPARPServerPort)

	log.Println("All mock identity services started successfully")
	log.Println("Services are running on:")
	log.Println("  AuthZ Server: https://127.0.0.1:8080")
	log.Println("  IdP Server:   https://127.0.0.1:8081")
	log.Println("  Resource:     https://127.0.0.1:8082")
	log.Println("  SPA RP:       https://127.0.0.1:8083")

	// Test health endpoints
	log.Println("Testing health endpoints...")
	testHealthEndpoints()

	log.Println("Press Ctrl+C to stop.")

	// Keep services running indefinitely
	select {}
}
