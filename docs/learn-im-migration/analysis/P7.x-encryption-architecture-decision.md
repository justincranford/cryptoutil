# P7.x Encryption Analysis - Architecture Decision

**Date**: 2025-01-XX
**Status**: ARCHITECTURE DECISION REQUIRED
**Phases Affected**: P7.2, P7.3, P7.4

---

## Executive Summary

Phases P7.2-P7.4 (barrier encryption, context-aware encryption, manual key rotation) require significant architectural decisions because:

1. **Barrier encryption is KMS-specific**: The existing barrier service (`internal/shared/barrier/`) is tightly coupled to KMS's OrmRepository pattern
2. **Learn-IM uses different repository pattern**: Uses GORM directly, not KMS OrmRepository abstraction
3. **JWKs already encrypted**: MessageRecipientJWK.JWK field already stores encrypted JWKs (alg=dir, enc=A256GCM)
4. **Three architectural options** with different complexity/benefit tradeoffs

**Recommendation**: Document options, defer implementation decision to user as this is educational project.

---

## Current State

### Learn-IM JWK Storage (Already Encrypted)

**Domain Model** (`internal/learn/domain/jwk.go`):
```go
type MessageRecipientJWK struct {
    ID          googleUuid.UUID
    RecipientID googleUuid.UUID
    MessageID   googleUuid.UUID
    JWK         string  // ← ALREADY ENCRYPTED (alg=dir, enc=A256GCM)
    CreatedAt   time.Time
    UpdatedAt   time.Time
}
```

**Current Encryption**: Direct encryption with A256GCM (stored as JWE Compact Serialization)

**Purpose**: Each recipient gets their own encrypted JWK for decrypting the message content

---

## KMS Barrier Encryption Pattern

**Architecture** (`internal/shared/barrier/barrier_service.go`):
- **4-tier hierarchy**: Unseal Key → Root Key → Intermediate Key → Content Key
- **OrmRepository dependency**: Requires KMS OrmRepository with barrier tables
- **Tables required**:
  - `barrier_root_keys` (encrypted with unseal keys)
  - `barrier_intermediate_keys` (encrypted with root keys)
  - `barrier_content_keys` (encrypted with intermediate keys)

**API**:
```go
func (b *BarrierService) EncryptContent(tx *OrmTransaction, clearBytes []byte) ([]byte, error)
func (b *BarrierService) DecryptContent(tx *OrmTransaction, encryptedBytes []byte) ([]byte, error)
```

**KMS Use Case**: Elastic Keys (per-tenant encryption keys) stored encrypted with barrier encryption

---

## Option 1: Full Barrier Integration (High Complexity)

### Implementation

1. **Add Barrier Tables to Learn-IM Schema**:
   ```sql
   CREATE TABLE barrier_root_keys (
       uuid TEXT PRIMARY KEY,
       encrypted TEXT NOT NULL,
       kek_uuid TEXT NOT NULL  -- References unseal keys
   );

   CREATE TABLE barrier_intermediate_keys (
       uuid TEXT PRIMARY KEY,
       encrypted TEXT NOT NULL,
       kek_uuid TEXT NOT NULL  -- References root keys
   );

   CREATE TABLE barrier_content_keys (
       uuid TEXT PRIMARY KEY,
       encrypted TEXT NOT NULL,
       kek_uuid TEXT NOT NULL  -- References intermediate keys
   );
   ```

2. **Create Learn-IM OrmRepository** (Pattern from KMS):
   - Wrap GORM with transaction abstraction
   - Implement CRUD operations for barrier tables
   - Support PostgreSQL and SQLite

3. **Integrate Barrier Service**:
   - Add BarrierService to Learn-IM server initialization
   - Inject into JWK repositories
   - Update Create/FindBy methods to encrypt/decrypt JWK field

4. **Migration Strategy**:
   - Add barrier tables to existing schema
   - Re-encrypt existing JWKs with barrier encryption
   - Update all JWK access code

### Pros
- ✅ Production-grade multi-layer encryption (defense in depth)
- ✅ Matches KMS pattern (architectural consistency)
- ✅ Supports key rotation at all levels (root, intermediate, content)
- ✅ Clear separation of concerns (unseal → root → intermediate → content)

### Cons
- ❌ High complexity (2-4 hours implementation)
- ❌ Significant schema changes (3 new tables)
- ❌ Repository pattern refactoring required
- ❌ JWKs already encrypted (diminishing returns for educational app)
- ❌ Overkill for learn-im use case (demonstration app, not production KMS)

### Effort Estimate
- **Schema + Migrations**: 30-45 minutes
- **OrmRepository creation**: 45-60 minutes
- **Barrier Service integration**: 30-45 minutes
- **JWK encryption updates**: 30-45 minutes
- **Testing**: 60-90 minutes
- **Total**: **3-5 hours**

---

## Option 2: Context-Aware Encryption Only (Medium Complexity)

### Implementation

1. **Skip Barrier Encryption**: Don't add barrier tables or multi-tier hierarchy

2. **Add Context to Existing Encryption**:
   ```go
   // Before: Direct encryption (current)
   func (s *JWKGenService) EncryptJWK(jwk *jose.JSONWebKey) (string, error)

   // After: Context-aware encryption
   func (s *JWKGenService) EncryptJWKWithContext(ctx context.Context, jwk *jose.JSONWebKey) (string, error)
   ```

3. **Update JWK Repository Methods**:
   ```go
   // Before
   func (r *MessageRecipientJWKRepository) Create(ctx context.Context, jwk *domain.MessageRecipientJWK) error {
       encryptedJWK, err := r.jwkGenService.EncryptJWK(jwk.PlainJWK)
       // ...
   }

   // After
   func (r *MessageRecipientJWKRepository) Create(ctx context.Context, jwk *domain.MessageRecipientJWK) error {
       encryptedJWK, err := r.jwkGenService.EncryptJWKWithContext(ctx, jwk.PlainJWK)
       // ...
   }
   ```

4. **Context Propagation**:
   - Trace IDs for encryption/decryption operations
   - Timeout control for crypto operations
   - Cancellation support

### Pros
- ✅ Lower complexity (30-60 minutes)
- ✅ Adds observability (trace IDs, timeouts)
- ✅ No schema changes
- ✅ Maintains existing encryption strength
- ✅ Idiomatic Go (context propagation best practice)

### Cons
- ❌ Doesn't add barrier encryption (may not satisfy P7.3 requirements)
- ❌ No multi-tier key hierarchy
- ❌ Minimal security improvement (same encryption, just context-aware)

### Effort Estimate
- **Add context parameter**: 15-20 minutes
- **Update repository methods**: 15-20 minutes
- **Testing**: 30-45 minutes
- **Total**: **60-90 minutes**

---

## Option 3: Defer to Future Enhancement (Zero Complexity)

### Implementation

1. **Document Current State**:
   - JWKs already encrypted (alg=dir, enc=A256GCM)
   - Encryption strength adequate for educational app
   - Barrier encryption is KMS-specific pattern

2. **Mark P7.x as Future Enhancement**:
   - Create architectural decision record (ADR)
   - Document options (full barrier vs context-only vs defer)
   - Recommend deferring until:
     - Learn-IM becomes production service, OR
     - Repository abstraction layer created, OR
     - Cross-service barrier service refactored

3. **Complete Remaining Tasks**:
   - P0.0.4, P0.1.4: Fix golangci-lint config
   - Document completed work
   - Final quality gates

### Pros
- ✅ Zero implementation time
- ✅ Focuses on core learn-im functionality
- ✅ Acknowledges architectural complexity
- ✅ Clear documentation for future work
- ✅ Pragmatic for educational project

### Cons
- ❌ Doesn't implement P7.x requirements
- ❌ No architectural learning from barrier encryption
- ❌ Incomplete phase completion (15/17 phases)

### Effort Estimate
- **Documentation**: 20-30 minutes
- **ADR creation**: 10-15 minutes
- **Total**: **30-45 minutes**

---

## Architectural Considerations

### Why Barrier Encryption is KMS-Specific

**KMS Use Case**: Tenant-specific elastic keys must be stored encrypted
- High-security requirement (keys protecting customer data)
- Multi-tier hierarchy provides defense in depth
- Key rotation at multiple levels (annual root, quarterly intermediate, per-operation content)
- Compliance requirements (FIPS 140-3, key escrow, audit trails)

**Learn-IM Use Case**: Encrypted messaging demonstration
- JWKs already encrypted with strong algorithm (A256GCM)
- Educational purpose (demonstrate concepts, not production security)
- Single-tier encryption sufficient for demo
- Barrier encryption adds complexity without proportional educational value

### Repository Pattern Mismatch

**KMS OrmRepository**:
```go
type OrmRepository struct {
    db *gorm.DB
}

type OrmTransaction struct {
    tx *gorm.DB
}

// Barrier operations require OrmTransaction
func (r *OrmRepository) CreateBarrierRootKey(tx *OrmTransaction, key *BarrierRootKey) error
```

**Learn-IM Repository**:
```go
type MessageRecipientJWKRepository struct {
    db *gorm.DB
}

// Uses GORM directly, no transaction abstraction
func (r *MessageRecipientJWKRepository) Create(ctx context.Context, jwk *MessageRecipientJWK) error {
    return getDB(ctx, r.db).WithContext(ctx).Create(jwk).Error
}
```

**Bridging Gap Requires**:
1. Create OrmRepository abstraction for learn-im
2. Refactor all repositories to use transaction pattern
3. Update all service layer code to use transactions
4. Add transaction context propagation
5. Estimated effort: **4-6 hours** (beyond P7.3 scope)

---

## P7.2 Context Pattern Analysis

### Current Encryption Code

**jwe_message_util.go** (likely location):
```go
// Assumed current implementation
func EncryptMessage(message []byte, recipientJWKs []string) (string, error) {
    // Create JWE
    // Encrypt with recipient keys
    // Return compact serialization
}
```

### Context-Aware Pattern

```go
func EncryptMessageWithContext(ctx context.Context, message []byte, recipientJWKs []string) (string, error) {
    // Check context cancellation
    select {
    case <-ctx.Done():
        return "", ctx.Err()
    default:
    }

    // Create JWE with trace ID
    encrypter, err := jose.NewMultiEncrypter(...)

    // Encrypt with timeout
    encrypted, err := encrypter.Encrypt(message)

    return encrypted.CompactSerialize()
}
```

**Benefits**:
- Cancellation support (abort long-running encryption)
- Timeout control (prevent hung operations)
- Trace ID propagation (observability)
- Idiomatic Go (context.Context best practice)

**Effort**: 30-45 minutes (independent of barrier encryption)

---

## P7.4 Manual Key Rotation Analysis

### Current State
- No manual rotation endpoint exists
- JWKs are per-message (not long-lived)
- Rotation less critical (messages ephemeral)

### Manual Rotation Use Cases

**For Barrier Keys** (if implementing Option 1):
- Rotate root keys (annual)
- Rotate intermediate keys (quarterly)
- Force rotation after security incident

**For Message JWKs** (current architecture):
- Limited use case (JWKs are per-message, not reused)
- Rotation would mean: generate new JWK, re-encrypt message content, update all recipient JWKs
- High complexity for minimal benefit

### API Design (if implementing)

```go
// POST /admin/v1/keys/rotate
type RotateRequest struct {
    KeyType string // "root", "intermediate", "content"
}

type RotateResponse struct {
    OldKeyID string
    NewKeyID string
    Status   string // "success", "in_progress", "failed"
}

// GET /admin/v1/keys/status
type KeyStatusResponse struct {
    RootKey struct {
        KeyID     string
        CreatedAt time.Time
        NextRotation time.Time
    }
    // ... intermediate, content
}
```

**Effort** (with barrier encryption): 1-2 hours
**Effort** (without barrier encryption): N/A (nothing to rotate)

---

## Recommendation

### For Educational Value (Option 2)

**Implement Context-Aware Encryption Only** (P7.2):
- Adds observability (trace IDs, timeouts, cancellation)
- Demonstrates context propagation best practices
- Low complexity (60-90 minutes)
- Educational value (idiomatic Go patterns)
- Skip P7.3 (barrier encryption) and P7.4 (rotation API)

**Rationale**:
- JWKs already encrypted (adequate security for demo)
- Barrier encryption is KMS-specific (not applicable to all services)
- Context patterns are universal (apply to all Go services)
- Focus on completing core learn-im functionality

### For Production-Grade Learning (Option 1)

**Implement Full Barrier Integration** (P7.3):
- Create OrmRepository abstraction
- Add barrier tables (root, intermediate, content)
- Integrate BarrierService
- Implement rotation API (P7.4)
- Estimated effort: **5-7 hours** (significant investment)

**Rationale**:
- Deep architectural learning (multi-tier encryption)
- Production patterns (transaction management, key rotation)
- KMS integration experience
- Comprehensive security understanding

### For Pragmatic Completion (Option 3)

**Defer P7.x to Future Enhancement**:
- Document current state (JWKs already encrypted)
- Create ADR explaining architectural complexity
- Focus on remaining tasks (lint fixes, documentation)
- Mark P7.x as future work
- Estimated effort: **30-45 minutes**

**Rationale**:
- Acknowledges complexity vs benefit tradeoff
- Pragmatic for educational project
- Enables focus on core functionality
- Clear path for future work

---

## Decision Matrix

| Criterion | Option 1 (Full Barrier) | Option 2 (Context Only) | Option 3 (Defer) |
|-----------|------------------------|------------------------|------------------|
| **Effort** | 5-7 hours | 60-90 minutes | 30-45 minutes |
| **Educational Value** | High (production patterns) | Medium (Go best practices) | Low (documentation only) |
| **Security Improvement** | High (multi-tier) | Low (observability only) | None |
| **Architectural Complexity** | High (repository refactor) | Low (parameter addition) | None |
| **Immediate Applicability** | KMS-specific | Universal (all services) | N/A |
| **Risk** | High (schema changes) | Low (backward compatible) | None |
| **Completeness** | 17/17 phases | 16/17 phases (skip P7.3, P7.4) | 15/17 phases |

---

## Next Steps

**User Decision Required**:
1. Review three options above
2. Choose based on:
   - Available time (5-7 hours vs 60-90 min vs 30-45 min)
   - Learning goals (production patterns vs Go idioms vs pragmatic completion)
   - Risk tolerance (schema changes vs parameter addition vs none)
3. Agent proceeds with chosen option

**Recommended Decision Point Questions**:
- Is learn-im intended to become production service? → Option 1
- Is learn-im educational demonstration only? → Option 2 or 3
- Is time constraint <2 hours? → Option 3
- Is learning barrier encryption essential? → Option 1
- Is learning context patterns sufficient? → Option 2

---

## Conclusion

P7.x phases require architectural decision because:
- Barrier encryption is KMS-specific pattern (not universally applicable)
- Learn-IM uses different repository pattern (GORM direct, not OrmRepository abstraction)
- JWKs already encrypted (barrier encryption adds complexity without proportional value for demo app)
- Three options with different complexity/benefit tradeoffs

**Agent Recommendation**: Option 2 (Context-Aware Encryption) for educational value + pragmatic completion balance.

**Defer to User**: Final decision on Option 1, 2, or 3 based on available time and learning goals.
