# P5.09 Fix Parallel Migration Infrastructure

**Task ID**: P5.09
**Priority**: CRITICAL
**Created**: 2025-11-26
**Status**: NOT STARTED
**Depends On**: P5.08 (completed)
**Estimated Effort**: 4 hours

## Problem Statement

golang-migrate v4 library not thread-safe for concurrent AutoMigrate calls in parallel Go tests, causing "dirty database version" errors and schema lock conflicts.

## Context

- **Discovered In**: P5.08 post-mortem (commit fa25bf75)
- **Failure Rate**: 25% of comprehensive authz tests (4/16)
- **Root Cause**: Multiple goroutines calling `migrate.Up()` simultaneously corrupt `schema_migrations.dirty` flag
- **Impact**: Blocks parallel test execution for all identity packages

## Evidence

```bash
# Parallel test failures
go test ./internal/identity/authz -run=TestHandleAuthorize -v -count=1
# FAIL: TestHandleAuthorizeGET_InvalidRedirectURI
#   Error: Dirty database version 1. Fix and force version.
# FAIL: TestHandleAuthorizeGET_HappyPath
#   Error: database table is locked: database schema is locked: main (262)
# FAIL: TestHandleAuthorizePOST_HappyPath
#   Error: Dirty database version 4. Fix and force version.

# Individual test passes
go test ./internal/identity/authz -run=TestHandleAuthorizeGET_HappyPath -v
# PASS: TestHandleAuthorizeGET_HappyPath (0.01s)
```

## Current Implementation

**File**: `internal/identity/repository/migrations.go`

```go
func Migrate(db *sql.DB) error {
    // ... setup code ...

    // Apply migrations - NO MUTEX PROTECTION
    if err := m.Up(); err != nil && !errors.Is(err, migrate.ErrNoChange) {
        return fmt.Errorf("failed to apply migrations: %w", err)
    }

    return nil
}
```

**File**: `internal/identity/repository/factory.go`

```go
func (f *RepositoryFactory) AutoMigrate(_ context.Context) error {
    sqlDB, err := f.db.DB()
    if err != nil {
        return /* error */
    }

    // EACH TEST CALLS THIS CONCURRENTLY
    if err := Migrate(sqlDB); err != nil {
        return /* error */
    }

    return nil
}
```

## Proposed Solutions

### Option A: Mutex-Protected Migration (Recommended)

**Implementation**:
```go
// internal/identity/repository/migrations.go
var (
    migrationMutex sync.Mutex
    migrationDone  bool
)

func Migrate(db *sql.DB) error {
    migrationMutex.Lock()
    defer migrationMutex.Unlock()

    if migrationDone {
        return nil // Already migrated in this process
    }

    // ... existing migration code ...

    migrationDone = true
    return nil
}
```

**Pros**:
- Minimal code changes
- Works with existing golang-migrate infrastructure
- No test file changes required

**Cons**:
- Single migration per process (can't test rollback/replay)
- Mutex contention in high-parallelism scenarios

### Option B: GORM AutoMigrate for Tests

**Implementation**:
```go
// internal/identity/repository/factory_test.go (test-only helper)
func (f *RepositoryFactory) AutoMigrateGORM(ctx context.Context) error {
    return f.db.AutoMigrate(
        &domain.User{},
        &domain.Client{},
        &domain.ClientSecretVersion{},
        &domain.KeyRotationEvent{},
        &domain.Token{},
        &domain.Session{},
        &domain.AuthorizationRequest{},
        // ... all domain models ...
    )
}
```

**Pros**:
- No mutex needed (GORM handles CREATE TABLE IF NOT EXISTS)
- Each test can have isolated schema
- Simpler migration logic for tests

**Cons**:
- Divergence between test and production migration paths
- Need to maintain two migration strategies
- SQL migrations become unused in tests

### Option C: Per-Test Database Files

**Implementation**:
```go
func createTestDB(t *testing.T) *gorm.DB {
    dbFile := filepath.Join(t.TempDir(), "test-"+uuid.NewV7().String()+".db")
    cfg := &config.DatabaseConfig{
        Type: "sqlite",
        DSN:  dbFile,
    }
    db, err := initializeDatabase(context.Background(), cfg)
    require.NoError(t, err)

    // Each test gets fresh DB, migration runs once per test
    err = Migrate(db)
    require.NoError(t, err)

    return db
}
```

**Pros**:
- Complete test isolation
- No shared state between tests
- Can test migration rollback/replay

**Cons**:
- Slower (disk I/O for each test)
- More complex test setup
- Requires cleanup (though t.TempDir() handles it)

## Recommended Approach

**Hybrid: Option A (mutex) + Validation**

```go
// internal/identity/repository/migrations.go
var (
    migrationMutex sync.Mutex
    migratedDBs    = make(map[string]bool) // Track migrated DB instances by DSN or pointer
)

func Migrate(db *sql.DB) error {
    migrationMutex.Lock()
    defer migrationMutex.Unlock()

    // Generate unique key for this DB instance
    dbKey := fmt.Sprintf("%p", db)

    if migratedDBs[dbKey] {
        return nil // Already migrated
    }

    // ... existing migration code ...

    // Validate tables exist after migration
    if err := validateSchema(db); err != nil {
        return fmt.Errorf("schema validation failed: %w", err)
    }

    migratedDBs[dbKey] = true
    return nil
}

func validateSchema(db *sql.DB) error {
    requiredTables := []string{
        "users", "clients", "client_secret_versions",
        "key_rotation_events", "tokens", "sessions",
        "authorization_requests", /* ... */
    }

    for _, table := range requiredTables {
        var exists int
        query := `SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name=?`
        if err := db.QueryRow(query, table).Scan(&exists); err != nil {
            return fmt.Errorf("failed to check table %s: %w", table, err)
        }
        if exists == 0 {
            return fmt.Errorf("required table missing: %s", table)
        }
    }

    return nil
}
```

## Acceptance Criteria

- [ ] Migration mutex prevents concurrent migration attempts
- [ ] Schema validation detects missing tables after migration
- [ ] All 16 comprehensive authz tests pass in parallel (`go test -count=1`)
- [ ] IDP tests pass without "no such table" errors
- [ ] Rotation test passes 10 consecutive times (`go test -count=10`)
- [ ] No "dirty database version" errors in any test run
- [ ] No "database schema is locked" errors
- [ ] Post-mortem documents the chosen solution and rationale

## Implementation Plan

### Phase 1: Add Mutex Protection (30 minutes)
1. Add package-level mutex and state map to migrations.go
2. Wrap Migrate() with mutex lock/unlock
3. Track migrated DB instances by pointer address
4. Test with parallel authz tests

### Phase 2: Add Schema Validation (30 minutes)
1. Create validateSchema() helper function
2. Query sqlite_master for required tables
3. Return error if any table missing
4. Call validation after migration succeeds

### Phase 3: Fix Test Failures (2 hours)
1. Run comprehensive authz tests (`go test -count=10`)
2. Run IDP tests (`go test ./internal/identity/idp`)
3. Debug any remaining failures
4. Add logging to track migration attempts

### Phase 4: Documentation (1 hour)
1. Update 04-01.sqlite-gorm.instructions.md with parallel migration patterns
2. Add section to testing.instructions.md on migration best practices
3. Create post-mortem documenting solution
4. Update P5.09 task status to COMPLETE

## Testing Strategy

```bash
# Parallel test stress test
go test ./internal/identity/authz -run=TestHandleAuthorize -count=10 -timeout=60s

# IDP test validation
go test ./internal/identity/idp -run=TestHandleLogin -count=5 -timeout=30s

# Rotation endpoint stability
go test ./internal/identity/authz -run=TestClientSecretRotation -count=20 -timeout=90s

# Full identity package suite
go test ./internal/identity/... -count=3 -timeout=5m
```

## Related Files

- `internal/identity/repository/migrations.go` - Migration logic
- `internal/identity/repository/factory.go` - AutoMigrate wrapper
- `internal/identity/authz/handlers_authorize_comprehensive_test.go` - Failing tests
- `internal/identity/idp/handlers_login_test.go` - Table creation failures
- `docs/04-general-stuff/todos-database-schema.md` - Historical migration issues

## References

- **P5.08 Post-Mortem**: docs/02-identityV2/passthru5/P5.08-POSTMORTEM.md
- **golang-migrate docs**: https://github.com/golang-migrate/migrate
- **SQLite WAL mode**: https://www.sqlite.org/wal.html
- **GORM AutoMigrate**: https://gorm.io/docs/migration.html
