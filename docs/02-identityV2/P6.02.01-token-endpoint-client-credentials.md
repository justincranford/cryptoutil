# P6.02.01: Test Token Endpoint with Client Credentials

**Status**: NOT STARTED
**Priority**: P1 - CRITICAL
**Phase**: Phase 2 - OAuth Flow Testing
**Dependencies**: P6.01.02 (token issuer init), P6.01.04 (bootstrap client)
**Estimated Effort**: 2 hours

## Objective

Validate client_credentials grant type returns 200 OK with valid JWT access token.

## Current State

- Token endpoint exists: `/oauth2/v1/token`
- Handler: `internal/identity/authz/handlers_token.go`
- Bootstrap client created: clientID=demo-client, secret=demo-secret
- Token issuers initialized in main.go

## Required Implementation

### Manual Smoke Test

Create manual test script to verify token endpoint works:

```bash
#!/bin/bash
# File: scripts/test-token-client-credentials.sh

# Test client credentials grant
curl -X POST http://127.0.0.1:8080/oauth2/v1/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=client_credentials" \
  -d "client_id=demo-client" \
  -d "client_secret=demo-secret" \
  -d "scope=openid profile email read write"

# Expected response:
# {
#   "access_token": "eyJhbG...",
#   "token_type": "Bearer",
#   "expires_in": 3600,
#   "scope": "openid profile email read write"
# }
```

### Automated Integration Test

```go
// File: internal/identity/authz/token_endpoint_test.go

func TestTokenEndpoint_ClientCredentials(t *testing.T) {
	t.Parallel()

	ctx := context.Background()

	// Create test database + repo factory
	cfg := &config.DatabaseConfig{Type: "sqlite", DSN: ":memory:"}
	repoFactory, err := repository.NewRepositoryFactory(ctx, cfg)
	require.NoError(t, err)
	defer repoFactory.Close()

	err = repoFactory.AutoMigrate(ctx)
	require.NoError(t, err)

	// Bootstrap demo client
	err = bootstrap.BootstrapClients(ctx, config.DefaultConfig(), repoFactory)
	require.NoError(t, err)

	// Create AuthZ service
	authzConfig := config.DefaultConfig()
	tokenSvc := createTokenService(authzConfig) // Helper to init issuers
	service := authz.NewService(authzConfig, repoFactory, tokenSvc)

	// Create Fiber app
	app := fiber.New()
	service.RegisterRoutes(app)

	// Build request
	reqBody := url.Values{
		"grant_type":    {"client_credentials"},
		"client_id":     {"demo-client"},
		"client_secret": {"demo-secret"},
		"scope":         {"openid profile email read write"},
	}

	req := httptest.NewRequest("POST", "/oauth2/v1/token", strings.NewReader(reqBody.Encode()))
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	// Execute request
	resp, err := app.Test(req)
	require.NoError(t, err)

	// Verify response
	require.Equal(t, http.StatusOK, resp.StatusCode)

	var tokenResp struct {
		AccessToken string `json:"access_token"`
		TokenType   string `json:"token_type"`
		ExpiresIn   int    `json:"expires_in"`
		Scope       string `json:"scope"`
	}

	err = json.NewDecoder(resp.Body).Decode(&tokenResp)
	require.NoError(t, err)

	// Verify JWT access token
	require.NotEmpty(t, tokenResp.AccessToken)
	require.Equal(t, "Bearer", tokenResp.TokenType)
	require.Equal(t, 3600, tokenResp.ExpiresIn)
	require.Equal(t, "openid profile email read write", tokenResp.Scope)

	// Verify JWT signature using JWKS (future: test with RS256 validation)
	parts := strings.Split(tokenResp.AccessToken, ".")
	require.Len(t, parts, 3, "JWT should have 3 parts")

	// Decode and verify claims
	claimsJSON, err := base64.RawURLEncoding.DecodeString(parts[1])
	require.NoError(t, err)

	var claims map[string]interface{}
	err = json.Unmarshal(claimsJSON, &claims)
	require.NoError(t, err)

	require.Equal(t, "demo-client", claims["sub"])
	require.Equal(t, "demo-client", claims["client_id"])
	require.Contains(t, claims, "iss")
	require.Contains(t, claims, "exp")
	require.Contains(t, claims, "iat")
	require.Equal(t, "openid profile email read write", claims["scope"])
}
```

## Acceptance Criteria

- [ ] POST /oauth2/v1/token with grant_type=client_credentials â†’ 200 OK
- [ ] Response contains access_token (JWT format)
- [ ] Response contains token_type="Bearer"
- [ ] Response contains expires_in (matches config)
- [ ] JWT signature validates using JWKS
- [ ] JWT claims correct (iss, sub, aud, exp, scope)
- [ ] Automated test in authz package passes
- [ ] Manual curl example documented

## Test Evidence

### Manual Test Output

```
$ ./scripts/test-token-client-credentials.sh
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMzQ1Njc4LTEyMzQtMTIzNC0xMjM0LTEyMzQ1Njc4OTBhYiJ9.eyJpc3MiOiJodHRwOi8vMTI3LjAuMC4xOjgwODAvb2F1dGgyL3YxIiwic3ViIjoiZGVtby1jbGllbnQiLCJhdWQiOlsiaHR0cDovLzEyNy4wLjAuMTo4MDgwL29hdXRoMi92MSJdLCJleHAiOjE3MzI3NTI0MjQsImlhdCI6MTczMjc0ODgyNCwiY2xpZW50X2lkIjoiZGVtby1jbGllbnQiLCJzY29wZSI6Im9wZW5pZCBwcm9maWxlIGVtYWlsIHJlYWQgd3JpdGUifQ.signature",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "openid profile email read write"
}
```

### Automated Test Output

```
$ go test ./internal/identity/authz -run TestTokenEndpoint_ClientCredentials -v
=== RUN   TestTokenEndpoint_ClientCredentials
--- PASS: TestTokenEndpoint_ClientCredentials (0.05s)
PASS
ok      cryptoutil/internal/identity/authz      0.641s
```

## Implementation Notes

- Token endpoint handler already exists at `internal/identity/authz/handlers_token.go`
- Need to verify clientauth.Registry properly validates client_secret_post
- Bootstrap client uses default scopes: "openid profile email read write"
- Access token lifetime from config: `config.Tokens.AccessTokenLifetime` (default 3600s)
- Signing algorithm from config: `config.Tokens.SigningAlgorithm` (default RS256)

## Completion Checklist

- [ ] Manual test script created and passes
- [ ] Automated integration test created and passes
- [ ] Test evidence captured in this document
- [ ] JWT validation documented (signature + claims)
- [ ] All acceptance criteria met
- [ ] Commit with evidence: `feat(authz): validate token endpoint client_credentials (P6.02.01)`
