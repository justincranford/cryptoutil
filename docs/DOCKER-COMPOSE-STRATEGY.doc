# Docker Compose Strategy (Refined)

## Overview

This document defines the refined Docker Compose strategy for cryptoutil products (KMS, Identity, and future products), incorporating decisions from grooming sessions 01-06. The goal is creating consistent, intuitive, self-documenting configurations optimized for non-production environments with clear patterns for production adaptation.

## Core Principles (Validated)

### P1: Non-Production Focus (Grooming Q1, Q5)

**ALWAYS**: Docker Compose is NEVER for production, ALWAYS for non-production

- Configurations seeded with sensible default users, credentials, data, and configs
- **Dual default strategy**: Include both well-known test values (admin/admin) AND generated UUIDs
- Users can copy-n-paste and remove unwanted sets; update/delete more intuitive than create from scratch
- Configuration must be intuitive to the point of being self-documenting (no additional documentation required)

### P2: Profile Strategy (Grooming Q1, Q10, Q11)

**Separate profiles for each component** (telemetry, kms, identity) with **combination profiles** for common use cases

Profile hierarchy:

- `telemetry` - Telemetry stack only
- `kms` - KMS services only
- `identity` - Identity services only
- `kms-identity` - Both products (no telemetry)
- `demo` - Minimal demo (SQLite only, no telemetry)
- `demo-telemetry` - Demo with observability learning
- `full` - Everything (telemetry + kms + identity)

**Fixed Port Ranges** (Q11):

- **KMS**: 8080-8099 (public), 9080-9099 (admin)
- **Identity**: 8100-8199 (public), 9100-9199 (admin)
- **Telemetry**: 3000 (Grafana), 4317/4318 (OTLP), 13133 (health)

### P3: Service Naming Convention (Grooming Q2, Q50, Q79)

**Pattern**: `product-service-instance` (e.g., `kms-sqlite-1`, `identity-authz-1`)

- Obvious service names and clear purposes
- Consistent patterns across all products
- Inline documentation in compose files
- Go e2e tests validate naming patterns via YAML parsing

### P4: Federation Dependencies (Grooming Q3, Q23)

**Hardcoded URLs in configuration files** - services use Docker Compose service names as hostnames

- Services discover each other via default Docker DNS resolution within compose network
- No dynamic service registration required
- All services always start; federation enabled via configuration
- Federation services warn if peer unavailable but don't fail startup

### P5: Database Migration Pattern (Grooming Q4, Q12, Q42)

**Health check dependencies in compose** (depends_on with condition: service_healthy)

- Instance 1 runs first and applies migrations
- Instances 2-N wait until instance 1 is healthy
- Instances 2-N can start concurrently after instance 1 healthy
- Configuration files applied on first start by first container

### P6: Data Seeding (Grooming Q5, Q30)

**Configuration files applied on first start by first container**

- Demo data includes pre-seeded clients, users, and credentials
- Both well-known values (admin/admin, test@example.com) AND generated UUIDs provided
- First container instance handles SQL migrations and loads shared config into DB

### P7: Image Architecture (Grooming Q6, Q7)

**Separate images for different binary types**:

- `identity-unified`: Single binary for authz/idp/rs (unified binary, start command differentiates)
- `identity-spa`: Standalone SPA application (Dockerfile.spa)
- `kms`: KMS service binary

**NOT separate binaries**: authz, idp, and rs are releasable together in identity-unified binary

## Proposed Structure (Refined)

### Root Compose File: ./deployments/compose.yml

- Orchestrates all products via profile selection
- Includes telemetry, KMS, and Identity compose files
- Profile combinations enable flexible deployment scenarios

### Per-Product Compose Files

#### deployments/telemetry/compose.yml

- OpenTelemetry Collector Contrib
- Grafana-OTEL-LGTM (Loki, Tempo, Prometheus)
- Health check sidecar for collector

#### deployments/kms/compose.yml

- Profiles: `full`, `standalone` (default), `demo`
- Services: kms-sqlite-1, kms-postgres-1, kms-postgres-2
- Demo: kms-sqlite-1 only

#### deployments/identity/compose.yml

- Profiles: `full`, `standalone` (default), `demo`
- Services: identity-authz-1, identity-idp-1, identity-rs-1, identity-spa-rp-1
- Uses unified binary (cmd/identity-unified) for authz/idp/rs
- SPA RP uses separate Dockerfile.spa
- Demo: SQLite backend, single authz instance

## Secrets Management (Grooming Q9, Q45)

**Centralized secrets with product-specific subdirectories**:

```
deployments/
├── secrets/                    # Shared secrets
│   └── shared/                 # Cross-product secrets
├── kms/secrets/                # KMS-specific secrets
│   └── unseal/                 # Unseal key materials
└── identity/secrets/           # Identity-specific secrets
    └── signing/                # JWT signing keys
```

**CRITICAL**: NEVER use environment variables for secrets. ALWAYS Docker secrets mounted to /run/secrets/

## Validation Approach (Grooming Q43, Q51-Q52, Q58, Q62, Q69, Q75, Q79)

### Go E2E Tests (Primary Validation)

All validation MUST be implemented as Go e2e tests that:

- Execute `docker compose` CLI commands directly
- Parse compose YAML for naming pattern validation
- Validate profile combinations start successfully
- Verify service health checks pass
- Run identically in local development and CI workflows

### Validation Checks

- YAML syntax validation
- Service name uniqueness across products
- Port conflict detection
- Profile consistency validation
- Service health and connectivity
- Default credential detection logging

### Validation Service (Grooming Q44, Q61, Q64, Q68)

**Always-on validation service in all profiles**:

- Standalone job that scans configurations at startup
- Scan configuration files for known default patterns
- Log security warnings for default credential usage
- Integrated into service entrypoints for runtime validation

## Security (Grooming Q57, Q74)

**All security validations MUST be automated**:

- Secret file permission checks (600, owned by app user)
- Image vulnerability scanning with Trivy
- Network isolation testing between services
- Runtime security audits
- CI/CD pipeline validation scripts

## Operations (Grooming Q53, Q55, Q56, Q59, Q76)

### Container-Only Dependencies (Q56, Q76)

- Bind mounts replaced with named volumes (no host dependencies)
- Works identically on Windows/Mac/Linux
- No environment-specific compose overrides needed

### Database Volume Snapshots (Q55, Q72)

- Database-specific backup tools (pg_dump, sqlite dump)
- Pre-seeded volume images with reset capabilities

### Performance Metrics (Q59, Q67)

- Container startup times and resource usage
- Service discovery latency and API response times
- Database connection pool utilization

## Testing Strategy (Grooming Q52, Q65, Q66, Q70)

### Test Execution

- Sequential profile execution with cleanup between tests
- Detailed logs with service output capture
- Screenshot capture of web interfaces
- Test artifacts uploaded to CI/CD storage

### Integration Points (Grooming Q69)

- Go e2e tests runnable locally AND in CI workflows
- NO pre-commit hooks for profile validation (too slow)
- NO release-specific validation (pre-release project)

## Build Optimization (Grooming Q27, Q46, Q73)

**Multi-stage Dockerfiles with shared base layers**:

- Common base stage with Go builder and static linking
- Product-specific build stages
- BuildKit with caching enabled
- Monorepo build with selective rebuilds

## Success Criteria (Grooming Q80)

**Primary**: All profiles working with `docker compose up -d`

- All profiles start successfully in isolation and combination
- Go e2e tests pass for all profile combinations
- Zero documentation needed for basic usage
- Commands in compose match actual binary interfaces
- All required Dockerfiles exist and build correctly

## Implementation Tasks

### Phase 1: Foundation (Complete)

- [x] Extract telemetry to ./deployments/telemetry/compose.yml
- [x] Create deployments/kms/compose.yml with all profiles
- [x] Create deployments/identity/compose.yml with corrected builders
- [x] Create Dockerfile.spa for standalone SPA RP application
- [x] Fix identity compose commands to match binary interfaces

### Phase 2: Secrets & Configuration (In Progress)

- [ ] Implement centralized secrets hierarchy
- [ ] Add default data seeding for all profiles
- [ ] Validate profile dependencies and startup order
- [ ] Create validation service

### Phase 3: Testing & Validation

- [ ] Create Go e2e test framework for compose validation
- [ ] Implement naming convention validation
- [ ] Add profile combination testing
- [ ] Test federation scenarios

### Phase 4: CI/CD Integration

- [ ] Update CI/CD workflows to use new compose structure
- [ ] Add Trivy image scanning
- [ ] Implement artifact upload for test results
- [ ] Add performance baseline measurements

## Open Questions (Resolved)

| Question | Resolution | Grooming Session |
|----------|------------|------------------|
| Profile strategy | Separate profiles + combination profiles | Q1 |
| Service naming | product-service-instance | Q2, Q50, Q79 |
| Federation handling | Hardcoded URLs via Docker DNS | Q3, Q23 |
| Sensible defaults | Both well-known + generated values | Q5 |
| Image architecture | Unified binary for authz/idp/rs, separate for SPA | Q6, Q7 |
| Secrets structure | Centralized with product subdirectories | Q9, Q45 |
| Telemetry in demo | Separate demo-telemetry profile | Q10 |
| Port allocation | Fixed ranges per product | Q11 |
| Migration pattern | Health check dependencies | Q12, Q42 |
| Validation approach | Go e2e tests | Q43, Q52, Q58 |
| Host compatibility | Container-only dependencies | Q56, Q76 |

---

*Document Version*: 2.0.0
*Last Updated*: December 3, 2025
*Grooming Sessions*: 01-06 Complete
- [ ] Extract telemetry to ./deployments/telemetry/compose.yml
- [ ] Create deployments/kms/compose.yml with all profiles
- [ ] Create deployments/identity/compose.yml with corrected builders and images
- [ ] Create Dockerfile.spa for standalone SPA RP application
- [ ] Fix identity compose commands to match binary interfaces

### Phase 2: Configuration Consistency
- [ ] Standardize service naming conventions across all compose files
- [ ] Implement shared secrets and config patterns
- [ ] Add default data seeding for all profiles
- [ ] Validate profile dependencies and startup order
- [ ] Ensure SPA RP uses separate image from unified identity services

### Phase 3: Documentation and Testing
- [ ] Update README.md with new compose usage instructions
- [ ] Create automated tests for compose configurations
- [ ] Validate that configurations are self-documenting
- [ ] Test profile combinations and federation scenarios

### Phase 4: Migration and Cleanup
- [ ] Migrate existing deployments to new structure
- [ ] Remove old compose files after validation
- [ ] Update CI/CD workflows to use new compose structure
- [ ] Train team on new configuration patterns

## Key Learnings from Analysis

### Missing Components Identified
- **Dockerfile.spa**: Required for standalone SPA Relying Party application
- **Corrected Builders**: identity compose builder uses wrong Dockerfile (KMS instead of identity)
- **Binary Mismatches**: Compose commands don't align with actual binary interfaces

### Architectural Clarifications
- **SPA RP**: Standalone sample application serving embedded static files
- **Traditional RP**: KMS Swagger UI (backend + embedded UI pattern)
- **Unified vs Separate**: Identity uses unified binary for core services, separate for SPA

### Risks and Gaps
- Profile strategy (separate vs combination profiles) needs decision
- Service naming conventions need standardization
- Federation dependencies between products need clear handling
- Default seeding data needs definition for "sensible defaults"

## Open Questions
- Profile strategy: separate vs. combination profiles?
- Service naming: exact conventions for multi-service products?
- Federation: how to handle cross-product dependencies?
- Defaults: what constitutes "sensible defaults" for seeding?
- Commands: ensure compose commands match binary entry points?
- Builders: separate builders for different binaries within same product?

## Success Criteria
- All configurations pass docker-compose config validation
- Profiles start successfully in isolation and combination
- Configurations are intuitive enough that new team members can understand without docs
- Production teams can easily adapt configurations for their environments
- No breaking changes to existing functionality during transition
- All required Dockerfiles exist and build correctly
- Commands in compose match actual binary interfaces
