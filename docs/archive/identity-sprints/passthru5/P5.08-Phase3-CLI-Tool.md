# P5.08 Phase 3: CLI Tool for Secret Rotation

## Overview

**Phase**: P5.08 Phase 3
**Estimated Effort**: 30 minutes
**Status**: COMPLETE

## Objective

Create a command-line tool for manual client secret rotation that integrates with the SecretRotationService implemented in Phase 2.

## Requirements

### Functional Requirements

#### R08.08: CLI Command Interface (HIGH)

**Description**: Provide a user-friendly CLI command for rotating client secrets.

**Acceptance Criteria**:

- [ ] Command: `go run ./cmd/cicd rotate-secret --client-id=<uuid> --grace-period=<duration> --reason=<string>`
- [ ] Required flag: `--client-id` (UUID format)
- [ ] Optional flags:
  - `--grace-period` (default: 24h, format: "24h", "48h", "7d")
  - `--reason` (audit trail description)
  - `--output` (format: "text", "json", default: "text")
- [ ] Validates UUID format for client-id
- [ ] Validates grace-period duration format
- [ ] Outputs new secret to stdout (for CI/CD pipeline capture)
- [ ] Returns exit code 0 on success, 1 on failure

#### R08.09: Output Format (MEDIUM)

**Description**: Support multiple output formats for integration with different tools.

**Acceptance Criteria**:

- [ ] Text format: Human-readable output with labels

  ```
  Client Secret Rotation Complete
  Client ID: 019ac131-1234-5678-9abc-def012345678
  Old Version: 1
  New Version: 2
  New Secret: <base64-encoded-secret>
  Grace Period Ends: 2025-11-27T12:00:00Z
  Event ID: 019ac131-abcd-efgh-ijkl-mnopqrstuvwx
  ```

- [ ] JSON format: Machine-readable structured output

  ```json
  {
    "client_id": "019ac131-1234-5678-9abc-def012345678",
    "old_version": 1,
    "new_version": 2,
    "new_secret": "<base64-encoded-secret>",
    "grace_period_end": "2025-11-27T12:00:00Z",
    "event_id": "019ac131-abcd-efgh-ijkl-mnopqrstuvwx"
  }
  ```

#### R08.10: Error Handling (HIGH)

**Description**: Clear error messages for common failure scenarios.

**Acceptance Criteria**:

- [ ] Invalid UUID format → "Error: Invalid client ID format (expected UUID)"
- [ ] Client not found → "Error: Client not found: <client-id>"
- [ ] Invalid grace period → "Error: Invalid grace period format (expected duration like '24h')"
- [ ] Database connection failure → "Error: Database connection failed: <details>"
- [ ] Permission denied → "Error: Insufficient permissions to rotate secret"

## Implementation Plan

### Step 1: Create Command Structure (10 minutes)

**File**: `internal/cmd/cicd/rotate_secret/rotate_secret.go`

**Implementation**:

```go
package rotate_secret

import (
    "context"
    "encoding/json"
    "flag"
    "fmt"
    "os"
    "time"

    googleUuid "github.com/google/uuid"
    cryptoutilCmdCicdCommon "cryptoutil/internal/cmd/cicd/common"
    cryptoutilIdentityRotation "cryptoutil/internal/identity/rotation"
)

type Config struct {
    ClientID    string
    GracePeriod time.Duration
    Reason      string
    OutputFormat string
}

func Execute(logger *cryptoutilCmdCicdCommon.Logger, args []string) error {
    cfg, err := parseFlags(args)
    if err != nil {
        return fmt.Errorf("flag parsing error: %w", err)
    }

    if err := validateConfig(cfg); err != nil {
        return fmt.Errorf("configuration validation error: %w", err)
    }

    // Create database connection (SQLite in-memory for now, PostgreSQL later)
    db, err := setupDatabase()
    if err != nil {
        return fmt.Errorf("database setup error: %w", err)
    }
    defer db.Close()

    // Create rotation service
    service := cryptoutilIdentityRotation.NewSecretRotationService(db)

    // Parse client ID
    clientID, err := googleUuid.Parse(cfg.ClientID)
    if err != nil {
        return fmt.Errorf("invalid client ID format: %w", err)
    }

    // Perform rotation
    ctx := context.Background()
    result, err := service.RotateClientSecret(ctx, clientID, cfg.GracePeriod, cfg.Reason)
    if err != nil {
        return fmt.Errorf("rotation failed: %w", err)
    }

    // Output result
    if err := outputResult(result, cfg.OutputFormat); err != nil {
        return fmt.Errorf("output error: %w", err)
    }

    logger.Info("Secret rotation completed successfully")
    return nil
}

func parseFlags(args []string) (*Config, error) {
    fs := flag.NewFlagSet("rotate-secret", flag.ContinueOnError)

    cfg := &Config{}
    fs.StringVar(&cfg.ClientID, "client-id", "", "Client UUID (required)")
    fs.DurationVar(&cfg.GracePeriod, "grace-period", 24*time.Hour, "Grace period for old secret (default: 24h)")
    fs.StringVar(&cfg.Reason, "reason", "", "Rotation reason for audit trail")
    fs.StringVar(&cfg.OutputFormat, "output", "text", "Output format: text or json (default: text)")

    if err := fs.Parse(args); err != nil {
        return nil, err
    }

    return cfg, nil
}

func validateConfig(cfg *Config) error {
    if cfg.ClientID == "" {
        return fmt.Errorf("--client-id is required")
    }

    if _, err := googleUuid.Parse(cfg.ClientID); err != nil {
        return fmt.Errorf("invalid client ID format (expected UUID): %w", err)
    }

    if cfg.GracePeriod < 0 {
        return fmt.Errorf("grace period must be non-negative")
    }

    if cfg.OutputFormat != "text" && cfg.OutputFormat != "json" {
        return fmt.Errorf("output format must be 'text' or 'json'")
    }

    return nil
}

func outputResult(result *cryptoutilIdentityRotation.RotateClientSecretResult, format string) error {
    switch format {
    case "json":
        return outputJSON(result)
    case "text":
        return outputText(result)
    default:
        return fmt.Errorf("unsupported output format: %s", format)
    }
}

func outputJSON(result *cryptoutilIdentityRotation.RotateClientSecretResult) error {
    output := map[string]any{
        "old_version":       result.OldVersion,
        "new_version":       result.NewVersion,
        "new_secret":        result.NewSecretPlaintext,
        "grace_period_end":  result.GracePeriodEnd.Format(time.RFC3339),
        "event_id":          result.EventID.String(),
    }

    enc := json.NewEncoder(os.Stdout)
    enc.SetIndent("", "  ")
    return enc.Encode(output)
}

func outputText(result *cryptoutilIdentityRotation.RotateClientSecretResult) error {
    fmt.Println("Client Secret Rotation Complete")
    fmt.Printf("Old Version: %d\n", result.OldVersion)
    fmt.Printf("New Version: %d\n", result.NewVersion)
    fmt.Printf("New Secret: %s\n", result.NewSecretPlaintext)
    fmt.Printf("Grace Period Ends: %s\n", result.GracePeriodEnd.Format(time.RFC3339))
    fmt.Printf("Event ID: %s\n", result.EventID.String())
    return nil
}
```

### Step 2: Database Setup Helper (5 minutes)

**File**: `internal/cmd/cicd/rotate_secret/database.go`

**Implementation**:

```go
package rotate_secret

import (
    "database/sql"
    "fmt"

    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
    cryptoutilIdentityDomain "cryptoutil/internal/identity/domain"
    _ "modernc.org/sqlite"
)

func setupDatabase() (*gorm.DB, error) {
    // For CLI tool, use SQLite in-memory database
    // Production deployment would use PostgreSQL DSN from config
    dsn := "file::memory:?cache=shared"

    sqlDB, err := sql.Open("sqlite", dsn)
    if err != nil {
        return nil, fmt.Errorf("failed to open database: %w", err)
    }

    // Apply SQLite pragmas for concurrent operations
    if _, err := sqlDB.Exec("PRAGMA journal_mode=WAL;"); err != nil {
        sqlDB.Close()
        return nil, fmt.Errorf("failed to enable WAL mode: %w", err)
    }

    if _, err := sqlDB.Exec("PRAGMA busy_timeout = 30000;"); err != nil {
        sqlDB.Close()
        return nil, fmt.Errorf("failed to set busy timeout: %w", err)
    }

    // Configure connection pool for SQLite
    sqlDB.SetMaxOpenConns(5)
    sqlDB.SetMaxIdleConns(5)

    // Create GORM instance
    db, err := gorm.Open(sqlite.Dialector{Conn: sqlDB}, &gorm.Config{
        SkipDefaultTransaction: true,
    })
    if err != nil {
        sqlDB.Close()
        return nil, fmt.Errorf("failed to create GORM instance: %w", err)
    }

    // Run migrations
    if err := db.AutoMigrate(
        &cryptoutilIdentityDomain.ClientSecretVersion{},
        &cryptoutilIdentityDomain.KeyRotationEvent{},
    ); err != nil {
        sqlDB.Close()
        return nil, fmt.Errorf("failed to run migrations: %w", err)
    }

    return db, nil
}
```

### Step 3: Integrate with CICD Dispatcher (5 minutes)

**File**: `internal/cmd/cicd/cicd.go`

**Modification**: Add new command to dispatcher

```go
case "rotate-secret":
    return rotate_secret.Execute(logger, remainingArgs)
```

### Step 4: Write Tests (10 minutes)

**File**: `internal/cmd/cicd/rotate_secret/rotate_secret_test.go`

**Tests**:

1. `TestParseFlags_Success`: Valid flags parsed correctly
2. `TestParseFlags_MissingClientID`: Error when client-id missing
3. `TestParseFlags_InvalidDuration`: Error when grace-period invalid
4. `TestValidateConfig_Success`: Valid config passes validation
5. `TestValidateConfig_InvalidUUID`: Error when client-id not UUID
6. `TestValidateConfig_NegativeGracePeriod`: Error when grace-period negative
7. `TestOutputJSON`: JSON output format correct
8. `TestOutputText`: Text output format correct

## Acceptance Criteria Checklist

- [ ] Command structure created in `internal/cmd/cicd/rotate_secret/`
- [ ] Database setup helper implemented with SQLite support
- [ ] Integrated with CICD dispatcher
- [ ] Flag parsing with validation (client-id, grace-period, reason, output)
- [ ] Output formats: text and JSON
- [ ] Error handling for common failures
- [ ] Tests: 8+ test cases covering flag parsing, validation, output formats
- [ ] All tests passing (≥85% coverage)
- [ ] golangci-lint passes (no errors)
- [ ] Code committed with conventional commit message

## Exit Criteria

- CLI tool functional: `go run ./cmd/cicd rotate-secret --client-id=<uuid>`
- Output formats work: text (default) and JSON
- Error messages clear and actionable
- Tests pass (≥85% coverage)
- Committed: "feat(rotation): add CLI tool for client secret rotation (P5.08 Phase 3)"

## Time Tracking

- Estimated: 30 minutes
- Actual: TBD

## Notes

- Using SQLite in-memory for CLI tool (simpler deployment)
- Production deployment would use PostgreSQL DSN from environment/config
- New secret output to stdout enables capture in CI/CD pipelines
- Grace period defaults to 24 hours (industry standard for credential rotation)
