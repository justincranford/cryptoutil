# P5.08 Phase 4: Backward Compatibility Layer

## Overview

**Phase**: P5.08 Phase 4
**Estimated Effort**: 1.5 hours
**Status**: COMPLETE

## Objective

Integrate the SecretRotationService into existing authentication flows to support multi-secret validation during grace periods, ensuring backward compatibility for clients still using old secrets.

## Requirements

### Functional Requirements

#### R08.11: Multi-Secret Client Authentication (HIGH)

**Description**: Modify client authentication to validate against all active secrets during grace period.

**Acceptance Criteria**:

- [ ] Client authentication checks all active secrets (not just the latest)
- [ ] Validates old secret if grace period not expired
- [ ] Validates new secret immediately after rotation
- [ ] Returns authentication success if ANY active secret matches
- [ ] Audit log records which secret version was used (for rotation monitoring)

#### R08.12: Client Creation with Initial Secret (HIGH)

**Description**: Ensure newly created clients get an initial secret version.

**Acceptance Criteria**:

- [ ] Client creation generates initial secret (version 1)
- [ ] Initial secret stored in ClientSecretVersion table
- [ ] Initial secret expiration = null (no expiration until rotation)
- [ ] Audit event created for initial secret generation
- [ ] Tests: client creation, initial secret validation

#### R08.13: Grace Period Validation (HIGH)

**Description**: Authentication must respect grace period expiration.

**Acceptance Criteria**:

- [ ] Old secrets rejected after grace period expires
- [ ] New secrets accepted immediately
- [ ] Grace period configurable per rotation
- [ ] Expired secrets marked as "expired" status
- [ ] Tests: grace period expiration, multi-secret validation

## Implementation Plan

### Step 1: Extend Client Authentication Service (20 minutes)

**File**: `internal/identity/authz/client_auth.go` (or similar)

**Modifications**:

1. Add dependency on SecretRotationService
2. Modify authentication logic to query all active secrets
3. Validate input secret against all active versions
4. Log which secret version was used for audit

**Example Implementation**:

```go
// AuthenticateClient validates client credentials using multi-secret support.
func (s *ClientAuthService) AuthenticateClient(
    ctx context.Context,
    clientID googleUuid.UUID,
    clientSecret string,
) (*domain.Client, error) {
    // Query all active secret versions.
    activeVersions, err := s.rotationService.GetActiveSecretVersions(ctx, clientID)
    if err != nil {
        return nil, fmt.Errorf("failed to query active secrets: %w", err)
    }

    if len(activeVersions) == 0 {
        return nil, fmt.Errorf("no active secrets for client")
    }

    // Validate against all active secrets.
    for _, version := range activeVersions {
        if err := bcrypt.CompareHashAndPassword(
            []byte(version.SecretHash),
            []byte(clientSecret),
        ); err == nil {
            // Secret matched - log which version was used.
            s.auditLog(ctx, clientID, version.Version, "client_authenticated")
            return s.clientRepo.GetByID(ctx, clientID)
        }
    }

    return nil, fmt.Errorf("invalid client credentials")
}
```

**New Service Method Required**:

```go
// GetActiveSecretVersions returns all active secret versions for grace period validation.
func (s *SecretRotationService) GetActiveSecretVersions(
    ctx context.Context,
    clientID googleUuid.UUID,
) ([]*domain.ClientSecretVersion, error) {
    var versions []*domain.ClientSecretVersion

    // Query all active secrets OR expired secrets still in grace period.
    now := time.Now()
    err := s.db.WithContext(ctx).
        Where("client_id = ?", clientID).
        Where("status = ?", domain.SecretStatusActive).
        Or("status = ? AND expires_at > ?", domain.SecretStatusExpired, now).
        Order("version DESC").
        Find(&versions).Error

    if err != nil {
        return nil, fmt.Errorf("failed to query active secrets: %w", err)
    }

    return versions, nil
}
```

### Step 2: Modify Client Creation (10 minutes)

**File**: `internal/identity/repository/orm/client_repository.go` (or service layer)

**Modifications**:

1. Generate initial secret on client creation
2. Store initial secret in ClientSecretVersion table
3. Create audit event for initial secret generation

**Example Implementation**:

```go
// Create creates a new client with initial secret.
func (r *ClientRepositoryGORM) Create(ctx context.Context, client *domain.Client) error {
    return r.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // Create client record.
        if err := tx.Create(client).Error; err != nil {
            return fmt.Errorf("failed to create client: %w", err)
        }

        // Generate initial secret.
        initialSecret, err := generateRandomSecret(32)
        if err != nil {
            return fmt.Errorf("failed to generate initial secret: %w", err)
        }

        secretHash, err := hashSecret(initialSecret)
        if err != nil {
            return fmt.Errorf("failed to hash initial secret: %w", err)
        }

        // Store initial secret version.
        version := &domain.ClientSecretVersion{
            ID:         googleUuid.New(),
            ClientID:   client.ID,
            Version:    1,
            SecretHash: secretHash,
            Status:     domain.SecretStatusActive,
            CreatedAt:  time.Now(),
            ExpiresAt:  nil, // No expiration until rotation.
        }

        if err := tx.Create(version).Error; err != nil {
            return fmt.Errorf("failed to create initial secret version: %w", err)
        }

        // Create audit event.
        event := &domain.KeyRotationEvent{
            ID:        googleUuid.New(),
            ClientID:  client.ID,
            EventType: domain.EventTypeSecretCreated,
            OldVersion: 0,
            NewVersion: 1,
            Initiator: "system",
            Reason:    "Initial client creation",
            Timestamp: time.Now(),
        }

        if err := tx.Create(event).Error; err != nil {
            return fmt.Errorf("failed to create audit event: %w", err)
        }

        return nil
    })
}
```

### Step 3: Add Grace Period Cleanup Job (10 minutes)

**File**: `internal/identity/jobs/secret_cleanup.go` (new)

**Implementation**:

```go
package jobs

import (
    "context"
    "fmt"
    "time"

    "gorm.io/gorm"
    cryptoutilIdentityDomain "cryptoutil/internal/identity/domain"
)

// CleanupExpiredSecrets marks expired secrets as "expired" status.
func CleanupExpiredSecrets(ctx context.Context, db *gorm.DB) error {
    now := time.Now()

    result := db.WithContext(ctx).
        Model(&cryptoutilIdentityDomain.ClientSecretVersion{}).
        Where("status = ?", cryptoutilIdentityDomain.SecretStatusActive).
        Where("expires_at IS NOT NULL AND expires_at < ?", now).
        Update("status", cryptoutilIdentityDomain.SecretStatusExpired)

    if result.Error != nil {
        return fmt.Errorf("failed to cleanup expired secrets: %w", result.Error)
    }

    return nil
}
```

**Scheduler Integration** (example with cron):

```go
// Schedule cleanup job to run every hour.
func ScheduleSecretCleanup(db *gorm.DB) {
    ticker := time.NewTicker(1 * time.Hour)
    go func() {
        for range ticker.C {
            ctx := context.Background()
            if err := CleanupExpiredSecrets(ctx, db); err != nil {
                log.Printf("Secret cleanup failed: %v", err)
            }
        }
    }()
}
```

### Step 4: Write Integration Tests (5 minutes)

**File**: `internal/identity/rotation/integration_test.go` (new)

**Tests**:

1. `TestClientAuthentication_WithOldSecret`: Old secret works during grace period
2. `TestClientAuthentication_WithNewSecret`: New secret works immediately
3. `TestClientAuthentication_AfterGracePeriod`: Old secret rejected after grace period
4. `TestClientCreation_InitialSecret`: Client creation generates initial secret
5. `TestCleanupExpiredSecrets`: Cleanup job marks expired secrets

## Acceptance Criteria Checklist

- [ ] GetActiveSecretVersions method added to SecretRotationService
- [ ] Client authentication validates against all active secrets
- [ ] Client creation generates initial secret (version 1)
- [ ] Audit events created for authentication and initial secret generation
- [ ] Cleanup job marks expired secrets as "expired" status
- [ ] Integration tests: old secret validation, new secret validation, grace period expiration
- [ ] All tests passing (≥85% coverage)
- [ ] golangci-lint passes (no errors)
- [ ] Code committed with conventional commit message

## Exit Criteria

- Client authentication supports multi-secret validation
- Grace period expiration enforced
- Cleanup job operational
- Integration tests pass (≥85% coverage)
- Committed: "feat(rotation): add backward compatibility for multi-secret auth (P5.08 Phase 4)"

## Time Tracking

- Estimated: 45 minutes
- Actual: TBD

## Notes

- Backward compatibility critical for zero-downtime rotation
- Clients can continue using old secret during grace period (default: 24 hours)
- New secret immediately valid after rotation
- Cleanup job prevents indefinite accumulation of expired secrets
- Audit logging tracks which secret version used for authentication (rotation monitoring)
