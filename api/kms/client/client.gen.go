// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1-0.20250618140738-aae687ce8fe9 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes  = "BearerAuth.Scopes"
	SessionAuthScopes = "SessionAuth.Scopes"
)

// Defines values for ElasticKeyStatus.
const (
	Active   ElasticKeyStatus = "active"
	Deleted  ElasticKeyStatus = "deleted"
	Inactive ElasticKeyStatus = "inactive"
)

// ElasticKey defines model for ElasticKey.
type ElasticKey struct {
	// Algorithm Cryptographic algorithm
	Algorithm *string `json:"algorithm,omitempty"`

	// Description Description
	Description *string `json:"description,omitempty"`

	// ElasticKeyId Unique UUID for the elastic key
	ElasticKeyId *openapi_types.UUID `json:"elastic_key_id,omitempty"`

	// ImportAllowed Import allowed flag
	ImportAllowed *bool `json:"import_allowed,omitempty"`

	// Name Friendly name
	Name *string `json:"name,omitempty"`

	// Provider Provider type
	Provider *string `json:"provider,omitempty"`

	// Status Current status
	Status *ElasticKeyStatus `json:"status,omitempty"`

	// TenantId Tenant ID for multi-tenant isolation
	TenantId *openapi_types.UUID `json:"tenant_id,omitempty"`

	// VersioningAllowed Versioning allowed flag
	VersioningAllowed *bool `json:"versioning_allowed,omitempty"`
}

// ElasticKeyStatus Current status
type ElasticKeyStatus string

// ElasticKeyCreate defines model for ElasticKeyCreate.
type ElasticKeyCreate struct {
	// Algorithm Cryptographic algorithm
	Algorithm string `json:"algorithm"`

	// Description Description of the elastic key's purpose
	Description *string `json:"description,omitempty"`

	// ImportAllowed Whether external key import is allowed
	ImportAllowed *bool `json:"import_allowed,omitempty"`

	// Name Friendly name for the elastic key
	Name string `json:"name"`

	// Provider Key provider type
	Provider string `json:"provider"`

	// VersioningAllowed Whether key versioning is allowed
	VersioningAllowed *bool `json:"versioning_allowed,omitempty"`
}

// ElasticKeyUpdate defines model for ElasticKeyUpdate.
type ElasticKeyUpdate struct {
	// Description Updated description
	Description *string `json:"description,omitempty"`

	// Name Updated friendly name
	Name string `json:"name"`
}

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code string `json:"code"`

	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Request ID for tracing
	RequestId *openapi_types.UUID `json:"request_id,omitempty"`
}

// MaterialKey defines model for MaterialKey.
type MaterialKey struct {
	// ClearPublic Public key material (for asymmetric keys)
	ClearPublic *string `json:"clear_public,omitempty"`

	// ElasticKeyId Parent elastic key UUID
	ElasticKeyId *openapi_types.UUID `json:"elastic_key_id,omitempty"`

	// ExpirationDate Date when key expires
	ExpirationDate *time.Time `json:"expiration_date,omitempty"`

	// GenerateDate Date when key was generated
	GenerateDate *time.Time `json:"generate_date,omitempty"`

	// ImportDate Date when key was imported
	ImportDate *time.Time `json:"import_date,omitempty"`

	// MaterialKeyId Material key UUID
	MaterialKeyId *openapi_types.UUID `json:"material_key_id,omitempty"`

	// RevocationDate Date when key was revoked
	RevocationDate *time.Time `json:"revocation_date,omitempty"`

	// TenantId Tenant ID for multi-tenant isolation
	TenantId *openapi_types.UUID `json:"tenant_id,omitempty"`
}

// MaterialKeyGenerate Request body for generating a new material key (empty object)
type MaterialKeyGenerate = map[string]interface{}

// MaterialKeyImport defines model for MaterialKeyImport.
type MaterialKeyImport struct {
	// Jwk JSON Web Key in compact JSON format to import
	Jwk string `json:"jwk"`
}

// Algorithms defines model for Algorithms.
type Algorithms = []string

// ElasticKeyID defines model for ElasticKeyID.
type ElasticKeyID = openapi_types.UUID

// ElasticKeyIDs defines model for ElasticKeyIDs.
type ElasticKeyIDs = []openapi_types.UUID

// ImportAllowed defines model for ImportAllowed.
type ImportAllowed = bool

// MaterialKeyID defines model for MaterialKeyID.
type MaterialKeyID = openapi_types.UUID

// MaterialKeyIDs defines model for MaterialKeyIDs.
type MaterialKeyIDs = []openapi_types.UUID

// MaterialKeyPageNumber defines model for MaterialKeyPageNumber.
type MaterialKeyPageNumber = int

// MaterialKeyPageSize defines model for MaterialKeyPageSize.
type MaterialKeyPageSize = int

// MaxExpirationDate defines model for MaxExpirationDate.
type MaxExpirationDate = time.Time

// MaxGenerateDate defines model for MaxGenerateDate.
type MaxGenerateDate = time.Time

// MaxImportDate defines model for MaxImportDate.
type MaxImportDate = time.Time

// MaxRevocationDate defines model for MaxRevocationDate.
type MaxRevocationDate = time.Time

// MinExpirationDate defines model for MinExpirationDate.
type MinExpirationDate = time.Time

// MinGenerateDate defines model for MinGenerateDate.
type MinGenerateDate = time.Time

// MinImportDate defines model for MinImportDate.
type MinImportDate = time.Time

// MinRevocationDate defines model for MinRevocationDate.
type MinRevocationDate = time.Time

// Names defines model for Names.
type Names = []string

// PageNumber defines model for PageNumber.
type PageNumber = int

// PageSize defines model for PageSize.
type PageSize = int

// Providers defines model for Providers.
type Providers = []string

// Sorts defines model for Sorts.
type Sorts = []string

// Statuses defines model for Statuses.
type Statuses = []string

// VersioningAllowed defines model for VersioningAllowed.
type VersioningAllowed = bool

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// DecryptTextBody defines parameters for Decrypt.
type DecryptTextBody = string

// EncryptTextBody defines parameters for Encrypt.
type EncryptTextBody = string

// EncryptParams defines parameters for Encrypt.
type EncryptParams struct {
	// Context Additional authenticated data for encryption context
	Context *string `form:"context,omitempty" json:"context,omitempty"`
}

// GenerateKeyParams defines parameters for GenerateKey.
type GenerateKeyParams struct {
	// Context Additional authenticated data for encryption context
	Context *string `form:"context,omitempty" json:"context,omitempty"`

	// Alg Algorithm for key generation
	Alg *string `form:"alg,omitempty" json:"alg,omitempty"`
}

// ListMaterialKeysParams defines parameters for ListMaterialKeys.
type ListMaterialKeysParams struct {
	// MaterialKeyIds Filter by material key IDs
	MaterialKeyIds *MaterialKeyIDs `form:"material_key_ids,omitempty" json:"material_key_ids,omitempty"`

	// MinGenerateDate Minimum generation date
	MinGenerateDate *MinGenerateDate `form:"min_generate_date,omitempty" json:"min_generate_date,omitempty"`

	// MaxGenerateDate Maximum generation date
	MaxGenerateDate *MaxGenerateDate `form:"max_generate_date,omitempty" json:"max_generate_date,omitempty"`

	// MinImportDate Minimum import date
	MinImportDate *MinImportDate `form:"min_import_date,omitempty" json:"min_import_date,omitempty"`

	// MaxImportDate Maximum import date
	MaxImportDate *MaxImportDate `form:"max_import_date,omitempty" json:"max_import_date,omitempty"`

	// MinExpirationDate Minimum expiration date
	MinExpirationDate *MinExpirationDate `form:"min_expiration_date,omitempty" json:"min_expiration_date,omitempty"`

	// MaxExpirationDate Maximum expiration date
	MaxExpirationDate *MaxExpirationDate `form:"max_expiration_date,omitempty" json:"max_expiration_date,omitempty"`

	// MinRevocationDate Minimum revocation date
	MinRevocationDate *MinRevocationDate `form:"min_revocation_date,omitempty" json:"min_revocation_date,omitempty"`

	// MaxRevocationDate Maximum revocation date
	MaxRevocationDate *MaxRevocationDate `form:"max_revocation_date,omitempty" json:"max_revocation_date,omitempty"`

	// PageNumber Page number for material keys pagination
	PageNumber *MaterialKeyPageNumber `form:"page_number,omitempty" json:"page_number,omitempty"`

	// PageSize Page size for material keys pagination
	PageSize *MaterialKeyPageSize `form:"page_size,omitempty" json:"page_size,omitempty"`
}

// SignTextBody defines parameters for Sign.
type SignTextBody = string

// VerifyTextBody defines parameters for Verify.
type VerifyTextBody = string

// ListElasticKeysParams defines parameters for ListElasticKeys.
type ListElasticKeysParams struct {
	// ElasticKeyIds Filter by elastic key IDs
	ElasticKeyIds *ElasticKeyIDs `form:"elastic_key_ids,omitempty" json:"elastic_key_ids,omitempty"`

	// Names Filter by elastic key names
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Providers Filter by providers
	Providers *Providers `form:"providers,omitempty" json:"providers,omitempty"`

	// Algorithms Filter by algorithms
	Algorithms *Algorithms `form:"algorithms,omitempty" json:"algorithms,omitempty"`

	// VersioningAllowed Filter by versioning allowed flag
	VersioningAllowed *VersioningAllowed `form:"versioning_allowed,omitempty" json:"versioning_allowed,omitempty"`

	// ImportAllowed Filter by import allowed flag
	ImportAllowed *ImportAllowed `form:"import_allowed,omitempty" json:"import_allowed,omitempty"`

	// Statuses Filter by elastic key statuses
	Statuses *Statuses `form:"statuses,omitempty" json:"statuses,omitempty"`

	// Sorts Sort fields
	Sorts *Sorts `form:"sorts,omitempty" json:"sorts,omitempty"`

	// PageNumber Page number for pagination
	PageNumber *PageNumber `form:"page_number,omitempty" json:"page_number,omitempty"`

	// PageSize Page size for pagination
	PageSize *PageSize `form:"page_size,omitempty" json:"page_size,omitempty"`
}

// ListAllMaterialKeysParams defines parameters for ListAllMaterialKeys.
type ListAllMaterialKeysParams struct {
	// ElasticKeyIds Filter by elastic key IDs
	ElasticKeyIds *ElasticKeyIDs `form:"elastic_key_ids,omitempty" json:"elastic_key_ids,omitempty"`

	// MaterialKeyIds Filter by material key IDs
	MaterialKeyIds *MaterialKeyIDs `form:"material_key_ids,omitempty" json:"material_key_ids,omitempty"`

	// MinGenerateDate Minimum generation date
	MinGenerateDate *MinGenerateDate `form:"min_generate_date,omitempty" json:"min_generate_date,omitempty"`

	// MaxGenerateDate Maximum generation date
	MaxGenerateDate *MaxGenerateDate `form:"max_generate_date,omitempty" json:"max_generate_date,omitempty"`

	// MinImportDate Minimum import date
	MinImportDate *MinImportDate `form:"min_import_date,omitempty" json:"min_import_date,omitempty"`

	// MaxImportDate Maximum import date
	MaxImportDate *MaxImportDate `form:"max_import_date,omitempty" json:"max_import_date,omitempty"`

	// MinExpirationDate Minimum expiration date
	MinExpirationDate *MinExpirationDate `form:"min_expiration_date,omitempty" json:"min_expiration_date,omitempty"`

	// MaxExpirationDate Maximum expiration date
	MaxExpirationDate *MaxExpirationDate `form:"max_expiration_date,omitempty" json:"max_expiration_date,omitempty"`

	// MinRevocationDate Minimum revocation date
	MinRevocationDate *MinRevocationDate `form:"min_revocation_date,omitempty" json:"min_revocation_date,omitempty"`

	// MaxRevocationDate Maximum revocation date
	MaxRevocationDate *MaxRevocationDate `form:"max_revocation_date,omitempty" json:"max_revocation_date,omitempty"`

	// PageNumber Page number for material keys pagination
	PageNumber *MaterialKeyPageNumber `form:"page_number,omitempty" json:"page_number,omitempty"`

	// PageSize Page size for material keys pagination
	PageSize *MaterialKeyPageSize `form:"page_size,omitempty" json:"page_size,omitempty"`
}

// CreateElasticKeyJSONRequestBody defines body for CreateElasticKey for application/json ContentType.
type CreateElasticKeyJSONRequestBody = ElasticKeyCreate

// UpdateElasticKeyJSONRequestBody defines body for UpdateElasticKey for application/json ContentType.
type UpdateElasticKeyJSONRequestBody = ElasticKeyUpdate

// DecryptTextRequestBody defines body for Decrypt for text/plain ContentType.
type DecryptTextRequestBody = DecryptTextBody

// EncryptTextRequestBody defines body for Encrypt for text/plain ContentType.
type EncryptTextRequestBody = EncryptTextBody

// ImportMaterialKeyJSONRequestBody defines body for ImportMaterialKey for application/json ContentType.
type ImportMaterialKeyJSONRequestBody = MaterialKeyImport

// GenerateMaterialKeyJSONRequestBody defines body for GenerateMaterialKey for application/json ContentType.
type GenerateMaterialKeyJSONRequestBody = MaterialKeyGenerate

// SignTextRequestBody defines body for Sign for text/plain ContentType.
type SignTextRequestBody = SignTextBody

// VerifyTextRequestBody defines body for Verify for text/plain ContentType.
type VerifyTextRequestBody = VerifyTextBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateElasticKeyWithBody request with any body
	CreateElasticKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateElasticKey(ctx context.Context, body CreateElasticKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteElasticKey request
	DeleteElasticKey(ctx context.Context, elasticKeyID ElasticKeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetElasticKey request
	GetElasticKey(ctx context.Context, elasticKeyID ElasticKeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateElasticKeyWithBody request with any body
	UpdateElasticKeyWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateElasticKey(ctx context.Context, elasticKeyID ElasticKeyID, body UpdateElasticKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DecryptWithBody request with any body
	DecryptWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DecryptWithTextBody(ctx context.Context, elasticKeyID ElasticKeyID, body DecryptTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EncryptWithBody request with any body
	EncryptWithBody(ctx context.Context, elasticKeyID ElasticKeyID, params *EncryptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EncryptWithTextBody(ctx context.Context, elasticKeyID ElasticKeyID, params *EncryptParams, body EncryptTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateKey request
	GenerateKey(ctx context.Context, elasticKeyID ElasticKeyID, params *GenerateKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportMaterialKeyWithBody request with any body
	ImportMaterialKeyWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportMaterialKey(ctx context.Context, elasticKeyID ElasticKeyID, body ImportMaterialKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateMaterialKeyWithBody request with any body
	GenerateMaterialKeyWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateMaterialKey(ctx context.Context, elasticKeyID ElasticKeyID, body GenerateMaterialKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMaterialKey request
	DeleteMaterialKey(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMaterialKey request
	GetMaterialKey(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeMaterialKey request
	RevokeMaterialKey(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMaterialKeys request
	ListMaterialKeys(ctx context.Context, elasticKeyID ElasticKeyID, params *ListMaterialKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignWithBody request with any body
	SignWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignWithTextBody(ctx context.Context, elasticKeyID ElasticKeyID, body SignTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyWithBody request with any body
	VerifyWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VerifyWithTextBody(ctx context.Context, elasticKeyID ElasticKeyID, body VerifyTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListElasticKeys request
	ListElasticKeys(ctx context.Context, params *ListElasticKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllMaterialKeys request
	ListAllMaterialKeys(ctx context.Context, params *ListAllMaterialKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateElasticKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateElasticKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateElasticKey(ctx context.Context, body CreateElasticKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateElasticKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteElasticKey(ctx context.Context, elasticKeyID ElasticKeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteElasticKeyRequest(c.Server, elasticKeyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetElasticKey(ctx context.Context, elasticKeyID ElasticKeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetElasticKeyRequest(c.Server, elasticKeyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateElasticKeyWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateElasticKeyRequestWithBody(c.Server, elasticKeyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateElasticKey(ctx context.Context, elasticKeyID ElasticKeyID, body UpdateElasticKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateElasticKeyRequest(c.Server, elasticKeyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DecryptWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDecryptRequestWithBody(c.Server, elasticKeyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DecryptWithTextBody(ctx context.Context, elasticKeyID ElasticKeyID, body DecryptTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDecryptRequestWithTextBody(c.Server, elasticKeyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EncryptWithBody(ctx context.Context, elasticKeyID ElasticKeyID, params *EncryptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptRequestWithBody(c.Server, elasticKeyID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EncryptWithTextBody(ctx context.Context, elasticKeyID ElasticKeyID, params *EncryptParams, body EncryptTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptRequestWithTextBody(c.Server, elasticKeyID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateKey(ctx context.Context, elasticKeyID ElasticKeyID, params *GenerateKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateKeyRequest(c.Server, elasticKeyID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportMaterialKeyWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportMaterialKeyRequestWithBody(c.Server, elasticKeyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportMaterialKey(ctx context.Context, elasticKeyID ElasticKeyID, body ImportMaterialKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportMaterialKeyRequest(c.Server, elasticKeyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateMaterialKeyWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateMaterialKeyRequestWithBody(c.Server, elasticKeyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateMaterialKey(ctx context.Context, elasticKeyID ElasticKeyID, body GenerateMaterialKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateMaterialKeyRequest(c.Server, elasticKeyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMaterialKey(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMaterialKeyRequest(c.Server, elasticKeyID, materialKeyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMaterialKey(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMaterialKeyRequest(c.Server, elasticKeyID, materialKeyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeMaterialKey(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeMaterialKeyRequest(c.Server, elasticKeyID, materialKeyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMaterialKeys(ctx context.Context, elasticKeyID ElasticKeyID, params *ListMaterialKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMaterialKeysRequest(c.Server, elasticKeyID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignRequestWithBody(c.Server, elasticKeyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignWithTextBody(ctx context.Context, elasticKeyID ElasticKeyID, body SignTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignRequestWithTextBody(c.Server, elasticKeyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyWithBody(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyRequestWithBody(c.Server, elasticKeyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyWithTextBody(ctx context.Context, elasticKeyID ElasticKeyID, body VerifyTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyRequestWithTextBody(c.Server, elasticKeyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListElasticKeys(ctx context.Context, params *ListElasticKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListElasticKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllMaterialKeys(ctx context.Context, params *ListAllMaterialKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllMaterialKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateElasticKeyRequest calls the generic CreateElasticKey builder with application/json body
func NewCreateElasticKeyRequest(server string, body CreateElasticKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateElasticKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateElasticKeyRequestWithBody generates requests for CreateElasticKey with any type of body
func NewCreateElasticKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteElasticKeyRequest generates requests for DeleteElasticKey
func NewDeleteElasticKeyRequest(server string, elasticKeyID ElasticKeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetElasticKeyRequest generates requests for GetElasticKey
func NewGetElasticKeyRequest(server string, elasticKeyID ElasticKeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateElasticKeyRequest calls the generic UpdateElasticKey builder with application/json body
func NewUpdateElasticKeyRequest(server string, elasticKeyID ElasticKeyID, body UpdateElasticKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateElasticKeyRequestWithBody(server, elasticKeyID, "application/json", bodyReader)
}

// NewUpdateElasticKeyRequestWithBody generates requests for UpdateElasticKey with any type of body
func NewUpdateElasticKeyRequestWithBody(server string, elasticKeyID ElasticKeyID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDecryptRequestWithTextBody calls the generic Decrypt builder with text/plain body
func NewDecryptRequestWithTextBody(server string, elasticKeyID ElasticKeyID, body DecryptTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewDecryptRequestWithBody(server, elasticKeyID, "text/plain", bodyReader)
}

// NewDecryptRequestWithBody generates requests for Decrypt with any type of body
func NewDecryptRequestWithBody(server string, elasticKeyID ElasticKeyID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s/decrypt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEncryptRequestWithTextBody calls the generic Encrypt builder with text/plain body
func NewEncryptRequestWithTextBody(server string, elasticKeyID ElasticKeyID, params *EncryptParams, body EncryptTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewEncryptRequestWithBody(server, elasticKeyID, params, "text/plain", bodyReader)
}

// NewEncryptRequestWithBody generates requests for Encrypt with any type of body
func NewEncryptRequestWithBody(server string, elasticKeyID ElasticKeyID, params *EncryptParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s/encrypt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateKeyRequest generates requests for GenerateKey
func NewGenerateKeyRequest(server string, elasticKeyID ElasticKeyID, params *GenerateKeyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s/generate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Alg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "alg", runtime.ParamLocationQuery, *params.Alg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportMaterialKeyRequest calls the generic ImportMaterialKey builder with application/json body
func NewImportMaterialKeyRequest(server string, elasticKeyID ElasticKeyID, body ImportMaterialKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportMaterialKeyRequestWithBody(server, elasticKeyID, "application/json", bodyReader)
}

// NewImportMaterialKeyRequestWithBody generates requests for ImportMaterialKey with any type of body
func NewImportMaterialKeyRequestWithBody(server string, elasticKeyID ElasticKeyID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s/import", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateMaterialKeyRequest calls the generic GenerateMaterialKey builder with application/json body
func NewGenerateMaterialKeyRequest(server string, elasticKeyID ElasticKeyID, body GenerateMaterialKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateMaterialKeyRequestWithBody(server, elasticKeyID, "application/json", bodyReader)
}

// NewGenerateMaterialKeyRequestWithBody generates requests for GenerateMaterialKey with any type of body
func NewGenerateMaterialKeyRequestWithBody(server string, elasticKeyID ElasticKeyID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s/materialkey", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMaterialKeyRequest generates requests for DeleteMaterialKey
func NewDeleteMaterialKeyRequest(server string, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "materialKeyID", runtime.ParamLocationPath, materialKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s/materialkey/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMaterialKeyRequest generates requests for GetMaterialKey
func NewGetMaterialKeyRequest(server string, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "materialKeyID", runtime.ParamLocationPath, materialKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s/materialkey/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeMaterialKeyRequest generates requests for RevokeMaterialKey
func NewRevokeMaterialKeyRequest(server string, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "materialKeyID", runtime.ParamLocationPath, materialKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s/materialkey/%s/revoke", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMaterialKeysRequest generates requests for ListMaterialKeys
func NewListMaterialKeysRequest(server string, elasticKeyID ElasticKeyID, params *ListMaterialKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s/materialkeys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaterialKeyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "material_key_ids", runtime.ParamLocationQuery, *params.MaterialKeyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinGenerateDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_generate_date", runtime.ParamLocationQuery, *params.MinGenerateDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxGenerateDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_generate_date", runtime.ParamLocationQuery, *params.MaxGenerateDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinImportDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_import_date", runtime.ParamLocationQuery, *params.MinImportDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxImportDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_import_date", runtime.ParamLocationQuery, *params.MaxImportDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinExpirationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_expiration_date", runtime.ParamLocationQuery, *params.MinExpirationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxExpirationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_expiration_date", runtime.ParamLocationQuery, *params.MaxExpirationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinRevocationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_revocation_date", runtime.ParamLocationQuery, *params.MinRevocationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRevocationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_revocation_date", runtime.ParamLocationQuery, *params.MaxRevocationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_number", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSignRequestWithTextBody calls the generic Sign builder with text/plain body
func NewSignRequestWithTextBody(server string, elasticKeyID ElasticKeyID, body SignTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewSignRequestWithBody(server, elasticKeyID, "text/plain", bodyReader)
}

// NewSignRequestWithBody generates requests for Sign with any type of body
func NewSignRequestWithBody(server string, elasticKeyID ElasticKeyID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s/sign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVerifyRequestWithTextBody calls the generic Verify builder with text/plain body
func NewVerifyRequestWithTextBody(server string, elasticKeyID ElasticKeyID, body VerifyTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewVerifyRequestWithBody(server, elasticKeyID, "text/plain", bodyReader)
}

// NewVerifyRequestWithBody generates requests for Verify with any type of body
func NewVerifyRequestWithBody(server string, elasticKeyID ElasticKeyID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "elasticKeyID", runtime.ParamLocationPath, elasticKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickey/%s/verify", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListElasticKeysRequest generates requests for ListElasticKeys
func NewListElasticKeysRequest(server string, params *ListElasticKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/elastickeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ElasticKeyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "elastic_key_ids", runtime.ParamLocationQuery, *params.ElasticKeyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Providers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "providers", runtime.ParamLocationQuery, *params.Providers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Algorithms != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "algorithms", runtime.ParamLocationQuery, *params.Algorithms); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VersioningAllowed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "versioning_allowed", runtime.ParamLocationQuery, *params.VersioningAllowed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImportAllowed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "import_allowed", runtime.ParamLocationQuery, *params.ImportAllowed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sorts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sorts", runtime.ParamLocationQuery, *params.Sorts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_number", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllMaterialKeysRequest generates requests for ListAllMaterialKeys
func NewListAllMaterialKeysRequest(server string, params *ListAllMaterialKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/materialkeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ElasticKeyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "elastic_key_ids", runtime.ParamLocationQuery, *params.ElasticKeyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaterialKeyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "material_key_ids", runtime.ParamLocationQuery, *params.MaterialKeyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinGenerateDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_generate_date", runtime.ParamLocationQuery, *params.MinGenerateDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxGenerateDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_generate_date", runtime.ParamLocationQuery, *params.MaxGenerateDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinImportDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_import_date", runtime.ParamLocationQuery, *params.MinImportDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxImportDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_import_date", runtime.ParamLocationQuery, *params.MaxImportDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinExpirationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_expiration_date", runtime.ParamLocationQuery, *params.MinExpirationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxExpirationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_expiration_date", runtime.ParamLocationQuery, *params.MaxExpirationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinRevocationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_revocation_date", runtime.ParamLocationQuery, *params.MinRevocationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRevocationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_revocation_date", runtime.ParamLocationQuery, *params.MaxRevocationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_number", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateElasticKeyWithBodyWithResponse request with any body
	CreateElasticKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateElasticKeyResponse, error)

	CreateElasticKeyWithResponse(ctx context.Context, body CreateElasticKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateElasticKeyResponse, error)

	// DeleteElasticKeyWithResponse request
	DeleteElasticKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, reqEditors ...RequestEditorFn) (*DeleteElasticKeyResponse, error)

	// GetElasticKeyWithResponse request
	GetElasticKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, reqEditors ...RequestEditorFn) (*GetElasticKeyResponse, error)

	// UpdateElasticKeyWithBodyWithResponse request with any body
	UpdateElasticKeyWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateElasticKeyResponse, error)

	UpdateElasticKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body UpdateElasticKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateElasticKeyResponse, error)

	// DecryptWithBodyWithResponse request with any body
	DecryptWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DecryptResponse, error)

	DecryptWithTextBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body DecryptTextRequestBody, reqEditors ...RequestEditorFn) (*DecryptResponse, error)

	// EncryptWithBodyWithResponse request with any body
	EncryptWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, params *EncryptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptResponse, error)

	EncryptWithTextBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, params *EncryptParams, body EncryptTextRequestBody, reqEditors ...RequestEditorFn) (*EncryptResponse, error)

	// GenerateKeyWithResponse request
	GenerateKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, params *GenerateKeyParams, reqEditors ...RequestEditorFn) (*GenerateKeyResponse, error)

	// ImportMaterialKeyWithBodyWithResponse request with any body
	ImportMaterialKeyWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportMaterialKeyResponse, error)

	ImportMaterialKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body ImportMaterialKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportMaterialKeyResponse, error)

	// GenerateMaterialKeyWithBodyWithResponse request with any body
	GenerateMaterialKeyWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateMaterialKeyResponse, error)

	GenerateMaterialKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body GenerateMaterialKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateMaterialKeyResponse, error)

	// DeleteMaterialKeyWithResponse request
	DeleteMaterialKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*DeleteMaterialKeyResponse, error)

	// GetMaterialKeyWithResponse request
	GetMaterialKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*GetMaterialKeyResponse, error)

	// RevokeMaterialKeyWithResponse request
	RevokeMaterialKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*RevokeMaterialKeyResponse, error)

	// ListMaterialKeysWithResponse request
	ListMaterialKeysWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, params *ListMaterialKeysParams, reqEditors ...RequestEditorFn) (*ListMaterialKeysResponse, error)

	// SignWithBodyWithResponse request with any body
	SignWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignResponse, error)

	SignWithTextBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body SignTextRequestBody, reqEditors ...RequestEditorFn) (*SignResponse, error)

	// VerifyWithBodyWithResponse request with any body
	VerifyWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyResponse, error)

	VerifyWithTextBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body VerifyTextRequestBody, reqEditors ...RequestEditorFn) (*VerifyResponse, error)

	// ListElasticKeysWithResponse request
	ListElasticKeysWithResponse(ctx context.Context, params *ListElasticKeysParams, reqEditors ...RequestEditorFn) (*ListElasticKeysResponse, error)

	// ListAllMaterialKeysWithResponse request
	ListAllMaterialKeysWithResponse(ctx context.Context, params *ListAllMaterialKeysParams, reqEditors ...RequestEditorFn) (*ListAllMaterialKeysResponse, error)
}

type CreateElasticKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ElasticKey
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateElasticKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateElasticKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteElasticKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteElasticKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteElasticKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetElasticKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ElasticKey
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetElasticKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetElasticKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateElasticKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ElasticKey
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateElasticKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateElasticKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DecryptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DecryptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DecryptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EncryptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EncryptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EncryptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GenerateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportMaterialKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MaterialKey
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ImportMaterialKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportMaterialKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateMaterialKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MaterialKey
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GenerateMaterialKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateMaterialKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMaterialKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteMaterialKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMaterialKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMaterialKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MaterialKey
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMaterialKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMaterialKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeMaterialKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RevokeMaterialKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeMaterialKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMaterialKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MaterialKey
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListMaterialKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMaterialKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SignResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r VerifyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListElasticKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ElasticKey
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListElasticKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListElasticKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllMaterialKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MaterialKey
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAllMaterialKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllMaterialKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateElasticKeyWithBodyWithResponse request with arbitrary body returning *CreateElasticKeyResponse
func (c *ClientWithResponses) CreateElasticKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateElasticKeyResponse, error) {
	rsp, err := c.CreateElasticKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateElasticKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateElasticKeyWithResponse(ctx context.Context, body CreateElasticKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateElasticKeyResponse, error) {
	rsp, err := c.CreateElasticKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateElasticKeyResponse(rsp)
}

// DeleteElasticKeyWithResponse request returning *DeleteElasticKeyResponse
func (c *ClientWithResponses) DeleteElasticKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, reqEditors ...RequestEditorFn) (*DeleteElasticKeyResponse, error) {
	rsp, err := c.DeleteElasticKey(ctx, elasticKeyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteElasticKeyResponse(rsp)
}

// GetElasticKeyWithResponse request returning *GetElasticKeyResponse
func (c *ClientWithResponses) GetElasticKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, reqEditors ...RequestEditorFn) (*GetElasticKeyResponse, error) {
	rsp, err := c.GetElasticKey(ctx, elasticKeyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetElasticKeyResponse(rsp)
}

// UpdateElasticKeyWithBodyWithResponse request with arbitrary body returning *UpdateElasticKeyResponse
func (c *ClientWithResponses) UpdateElasticKeyWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateElasticKeyResponse, error) {
	rsp, err := c.UpdateElasticKeyWithBody(ctx, elasticKeyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateElasticKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdateElasticKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body UpdateElasticKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateElasticKeyResponse, error) {
	rsp, err := c.UpdateElasticKey(ctx, elasticKeyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateElasticKeyResponse(rsp)
}

// DecryptWithBodyWithResponse request with arbitrary body returning *DecryptResponse
func (c *ClientWithResponses) DecryptWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DecryptResponse, error) {
	rsp, err := c.DecryptWithBody(ctx, elasticKeyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDecryptResponse(rsp)
}

func (c *ClientWithResponses) DecryptWithTextBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body DecryptTextRequestBody, reqEditors ...RequestEditorFn) (*DecryptResponse, error) {
	rsp, err := c.DecryptWithTextBody(ctx, elasticKeyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDecryptResponse(rsp)
}

// EncryptWithBodyWithResponse request with arbitrary body returning *EncryptResponse
func (c *ClientWithResponses) EncryptWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, params *EncryptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptResponse, error) {
	rsp, err := c.EncryptWithBody(ctx, elasticKeyID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptResponse(rsp)
}

func (c *ClientWithResponses) EncryptWithTextBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, params *EncryptParams, body EncryptTextRequestBody, reqEditors ...RequestEditorFn) (*EncryptResponse, error) {
	rsp, err := c.EncryptWithTextBody(ctx, elasticKeyID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptResponse(rsp)
}

// GenerateKeyWithResponse request returning *GenerateKeyResponse
func (c *ClientWithResponses) GenerateKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, params *GenerateKeyParams, reqEditors ...RequestEditorFn) (*GenerateKeyResponse, error) {
	rsp, err := c.GenerateKey(ctx, elasticKeyID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateKeyResponse(rsp)
}

// ImportMaterialKeyWithBodyWithResponse request with arbitrary body returning *ImportMaterialKeyResponse
func (c *ClientWithResponses) ImportMaterialKeyWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportMaterialKeyResponse, error) {
	rsp, err := c.ImportMaterialKeyWithBody(ctx, elasticKeyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportMaterialKeyResponse(rsp)
}

func (c *ClientWithResponses) ImportMaterialKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body ImportMaterialKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportMaterialKeyResponse, error) {
	rsp, err := c.ImportMaterialKey(ctx, elasticKeyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportMaterialKeyResponse(rsp)
}

// GenerateMaterialKeyWithBodyWithResponse request with arbitrary body returning *GenerateMaterialKeyResponse
func (c *ClientWithResponses) GenerateMaterialKeyWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateMaterialKeyResponse, error) {
	rsp, err := c.GenerateMaterialKeyWithBody(ctx, elasticKeyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateMaterialKeyResponse(rsp)
}

func (c *ClientWithResponses) GenerateMaterialKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body GenerateMaterialKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateMaterialKeyResponse, error) {
	rsp, err := c.GenerateMaterialKey(ctx, elasticKeyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateMaterialKeyResponse(rsp)
}

// DeleteMaterialKeyWithResponse request returning *DeleteMaterialKeyResponse
func (c *ClientWithResponses) DeleteMaterialKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*DeleteMaterialKeyResponse, error) {
	rsp, err := c.DeleteMaterialKey(ctx, elasticKeyID, materialKeyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMaterialKeyResponse(rsp)
}

// GetMaterialKeyWithResponse request returning *GetMaterialKeyResponse
func (c *ClientWithResponses) GetMaterialKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*GetMaterialKeyResponse, error) {
	rsp, err := c.GetMaterialKey(ctx, elasticKeyID, materialKeyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMaterialKeyResponse(rsp)
}

// RevokeMaterialKeyWithResponse request returning *RevokeMaterialKeyResponse
func (c *ClientWithResponses) RevokeMaterialKeyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, materialKeyID MaterialKeyID, reqEditors ...RequestEditorFn) (*RevokeMaterialKeyResponse, error) {
	rsp, err := c.RevokeMaterialKey(ctx, elasticKeyID, materialKeyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeMaterialKeyResponse(rsp)
}

// ListMaterialKeysWithResponse request returning *ListMaterialKeysResponse
func (c *ClientWithResponses) ListMaterialKeysWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, params *ListMaterialKeysParams, reqEditors ...RequestEditorFn) (*ListMaterialKeysResponse, error) {
	rsp, err := c.ListMaterialKeys(ctx, elasticKeyID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMaterialKeysResponse(rsp)
}

// SignWithBodyWithResponse request with arbitrary body returning *SignResponse
func (c *ClientWithResponses) SignWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignResponse, error) {
	rsp, err := c.SignWithBody(ctx, elasticKeyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignResponse(rsp)
}

func (c *ClientWithResponses) SignWithTextBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body SignTextRequestBody, reqEditors ...RequestEditorFn) (*SignResponse, error) {
	rsp, err := c.SignWithTextBody(ctx, elasticKeyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignResponse(rsp)
}

// VerifyWithBodyWithResponse request with arbitrary body returning *VerifyResponse
func (c *ClientWithResponses) VerifyWithBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyResponse, error) {
	rsp, err := c.VerifyWithBody(ctx, elasticKeyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyResponse(rsp)
}

func (c *ClientWithResponses) VerifyWithTextBodyWithResponse(ctx context.Context, elasticKeyID ElasticKeyID, body VerifyTextRequestBody, reqEditors ...RequestEditorFn) (*VerifyResponse, error) {
	rsp, err := c.VerifyWithTextBody(ctx, elasticKeyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyResponse(rsp)
}

// ListElasticKeysWithResponse request returning *ListElasticKeysResponse
func (c *ClientWithResponses) ListElasticKeysWithResponse(ctx context.Context, params *ListElasticKeysParams, reqEditors ...RequestEditorFn) (*ListElasticKeysResponse, error) {
	rsp, err := c.ListElasticKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListElasticKeysResponse(rsp)
}

// ListAllMaterialKeysWithResponse request returning *ListAllMaterialKeysResponse
func (c *ClientWithResponses) ListAllMaterialKeysWithResponse(ctx context.Context, params *ListAllMaterialKeysParams, reqEditors ...RequestEditorFn) (*ListAllMaterialKeysResponse, error) {
	rsp, err := c.ListAllMaterialKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllMaterialKeysResponse(rsp)
}

// ParseCreateElasticKeyResponse parses an HTTP response from a CreateElasticKeyWithResponse call
func ParseCreateElasticKeyResponse(rsp *http.Response) (*CreateElasticKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateElasticKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElasticKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteElasticKeyResponse parses an HTTP response from a DeleteElasticKeyWithResponse call
func ParseDeleteElasticKeyResponse(rsp *http.Response) (*DeleteElasticKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteElasticKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetElasticKeyResponse parses an HTTP response from a GetElasticKeyWithResponse call
func ParseGetElasticKeyResponse(rsp *http.Response) (*GetElasticKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetElasticKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElasticKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateElasticKeyResponse parses an HTTP response from a UpdateElasticKeyWithResponse call
func ParseUpdateElasticKeyResponse(rsp *http.Response) (*UpdateElasticKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateElasticKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElasticKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDecryptResponse parses an HTTP response from a DecryptWithResponse call
func ParseDecryptResponse(rsp *http.Response) (*DecryptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DecryptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEncryptResponse parses an HTTP response from a EncryptWithResponse call
func ParseEncryptResponse(rsp *http.Response) (*EncryptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EncryptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateKeyResponse parses an HTTP response from a GenerateKeyWithResponse call
func ParseGenerateKeyResponse(rsp *http.Response) (*GenerateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseImportMaterialKeyResponse parses an HTTP response from a ImportMaterialKeyWithResponse call
func ParseImportMaterialKeyResponse(rsp *http.Response) (*ImportMaterialKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportMaterialKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MaterialKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateMaterialKeyResponse parses an HTTP response from a GenerateMaterialKeyWithResponse call
func ParseGenerateMaterialKeyResponse(rsp *http.Response) (*GenerateMaterialKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateMaterialKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MaterialKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteMaterialKeyResponse parses an HTTP response from a DeleteMaterialKeyWithResponse call
func ParseDeleteMaterialKeyResponse(rsp *http.Response) (*DeleteMaterialKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMaterialKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMaterialKeyResponse parses an HTTP response from a GetMaterialKeyWithResponse call
func ParseGetMaterialKeyResponse(rsp *http.Response) (*GetMaterialKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMaterialKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MaterialKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRevokeMaterialKeyResponse parses an HTTP response from a RevokeMaterialKeyWithResponse call
func ParseRevokeMaterialKeyResponse(rsp *http.Response) (*RevokeMaterialKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeMaterialKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListMaterialKeysResponse parses an HTTP response from a ListMaterialKeysWithResponse call
func ParseListMaterialKeysResponse(rsp *http.Response) (*ListMaterialKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMaterialKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MaterialKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSignResponse parses an HTTP response from a SignWithResponse call
func ParseSignResponse(rsp *http.Response) (*SignResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseVerifyResponse parses an HTTP response from a VerifyWithResponse call
func ParseVerifyResponse(rsp *http.Response) (*VerifyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListElasticKeysResponse parses an HTTP response from a ListElasticKeysWithResponse call
func ParseListElasticKeysResponse(rsp *http.Response) (*ListElasticKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListElasticKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ElasticKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAllMaterialKeysResponse parses an HTTP response from a ListAllMaterialKeysWithResponse call
func ParseListAllMaterialKeysResponse(rsp *http.Response) (*ListAllMaterialKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllMaterialKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MaterialKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
