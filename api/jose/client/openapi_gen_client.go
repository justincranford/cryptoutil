// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1-0.20250618140738-aae687ce8fe9 DO NOT EDIT.
package client

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for HealthResponseStatus.
const (
	Healthy   HealthResponseStatus = "healthy"
	Unhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for JWKGenerateRequestAlgorithm.
const (
	ECP256     JWKGenerateRequestAlgorithm = "ECP256"
	ECP384     JWKGenerateRequestAlgorithm = "ECP384"
	ECP521     JWKGenerateRequestAlgorithm = "ECP521"
	OKPEd25519 JWKGenerateRequestAlgorithm = "OKPEd25519"
	Oct128     JWKGenerateRequestAlgorithm = "Oct128"
	Oct192     JWKGenerateRequestAlgorithm = "Oct192"
	Oct256     JWKGenerateRequestAlgorithm = "Oct256"
	Oct384     JWKGenerateRequestAlgorithm = "Oct384"
	Oct512     JWKGenerateRequestAlgorithm = "Oct512"
	RSA2048    JWKGenerateRequestAlgorithm = "RSA2048"
	RSA3072    JWKGenerateRequestAlgorithm = "RSA3072"
	RSA4096    JWKGenerateRequestAlgorithm = "RSA4096"
)

// Defines values for JWKGenerateRequestUse.
const (
	Enc JWKGenerateRequestUse = "enc"
	Sig JWKGenerateRequestUse = "sig"
)

// Defines values for JWKResponseKty.
const (
	EC  JWKResponseKty = "EC"
	OKP JWKResponseKty = "OKP"
	Oct JWKResponseKty = "oct"
	RSA JWKResponseKty = "RSA"
)

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Error Error message.
	Error string `json:"error"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Status HealthResponseStatus `json:"status"`
	Time   time.Time            `json:"time"`
}

// HealthResponseStatus defines model for HealthResponse.Status.
type HealthResponseStatus string

// JWEDecryptRequest defines model for JWEDecryptRequest.
type JWEDecryptRequest struct {
	// JWE Compact JWE to decrypt.
	JWE string `json:"jwe"`

	// Kid Key ID to use for decryption.
	Kid openapi_types.UUID `json:"kid"`
}

// JWEDecryptResponse defines model for JWEDecryptResponse.
type JWEDecryptResponse struct {
	// Error Error message (if decryption failed).
	Error *string `json:"error,omitempty"`

	// Kid Key ID used for decryption.
	Kid *openapi_types.UUID `json:"kid,omitempty"`

	// Plaintext Decrypted plaintext.
	Plaintext *string `json:"plaintext,omitempty"`
}

// JWEEncryptRequest defines model for JWEEncryptRequest.
type JWEEncryptRequest struct {
	// Kid Key ID to use for encryption.
	Kid openapi_types.UUID `json:"kid"`

	// Plaintext Plaintext to encrypt.
	Plaintext string `json:"plaintext"`
}

// JWEEncryptResponse defines model for JWEEncryptResponse.
type JWEEncryptResponse struct {
	// JWE Compact JWE serialization.
	JWE string `json:"jwe"`
}

// JWKGenerateRequest defines model for JWKGenerateRequest.
type JWKGenerateRequest struct {
	// Algorithm Algorithm for key generation.
	Algorithm JWKGenerateRequestAlgorithm `json:"algorithm"`

	// Use Intended use of the key (sig=signing, enc=encryption).
	Use *JWKGenerateRequestUse `json:"use,omitempty"`
}

// JWKGenerateRequestAlgorithm Algorithm for key generation.
type JWKGenerateRequestAlgorithm string

// JWKGenerateRequestUse Intended use of the key (sig=signing, enc=encryption).
type JWKGenerateRequestUse string

// JWKListResponse defines model for JWKListResponse.
type JWKListResponse struct {
	// Count Total number of keys.
	Count int           `json:"count"`
	Keys  []JWKResponse `json:"keys"`
}

// JWKResponse defines model for JWKResponse.
type JWKResponse struct {
	// Algorithm Algorithm used for the key.
	Algorithm string `json:"algorithm"`

	// CreatedAt Unix timestamp when the key was created.
	CreatedAt int64 `json:"created_at"`

	// Kid Key ID (UUIDv7).
	Kid openapi_types.UUID `json:"kid"`

	// Kty Key type.
	Kty JWKResponseKty `json:"kty"`

	// PublicJWK Public key in JWK format.
	PublicJWK *map[string]any `json:"public_jwk,omitempty"`

	// Use Intended use of the key.
	Use *string `json:"use,omitempty"`
}

// JWKResponseKty Key type.
type JWKResponseKty string

// JWKS JSON Web Key Set (RFC 7517).
type JWKS struct {
	Keys []map[string]any `json:"keys"`
}

// JWSSignRequest defines model for JWSSignRequest.
type JWSSignRequest struct {
	// Kid Key ID to use for signing.
	Kid openapi_types.UUID `json:"kid"`

	// Payload Payload to sign (string or base64url-encoded).
	Payload string `json:"payload"`
}

// JWSSignResponse defines model for JWSSignResponse.
type JWSSignResponse struct {
	// JWS Compact JWS serialization.
	JWS string `json:"jws"`
}

// JWSVerifyRequest defines model for JWSVerifyRequest.
type JWSVerifyRequest struct {
	// JWS Compact JWS to verify.
	JWS string `json:"jws"`

	// Kid Optional key ID to use for verification.
	Kid *openapi_types.UUID `json:"kid,omitempty"`
}

// JWSVerifyResponse defines model for JWSVerifyResponse.
type JWSVerifyResponse struct {
	// Error Error message (if invalid).
	Error *string `json:"error,omitempty"`

	// Kid Key ID used for verification.
	Kid *openapi_types.UUID `json:"kid,omitempty"`

	// Payload Decoded payload (if valid).
	Payload *string `json:"payload,omitempty"`

	// Valid Whether the signature is valid.
	Valid bool `json:"valid"`
}

// JWTCreateRequest defines model for JWTCreateRequest.
type JWTCreateRequest struct {
	// Claims JWT claims.
	Claims map[string]any `json:"claims"`

	// Kid Key ID to use for signing.
	Kid openapi_types.UUID `json:"kid"`
}

// JWTCreateResponse defines model for JWTCreateResponse.
type JWTCreateResponse struct {
	// JWT Compact JWT serialization.
	JWT string `json:"jwt"`
}

// JWTVerifyRequest defines model for JWTVerifyRequest.
type JWTVerifyRequest struct {
	// JWT Compact JWT to verify.
	JWT string `json:"jwt"`

	// Kid Optional key ID to use for verification.
	Kid *openapi_types.UUID `json:"kid,omitempty"`
}

// JWTVerifyResponse defines model for JWTVerifyResponse.
type JWTVerifyResponse struct {
	// Claims Decoded claims (if valid).
	Claims *map[string]any `json:"claims,omitempty"`

	// Error Error message (if invalid).
	Error *string `json:"error,omitempty"`

	// Kid Key ID used for verification.
	Kid *openapi_types.UUID `json:"kid,omitempty"`

	// Valid Whether the JWT signature is valid.
	Valid bool `json:"valid"`
}

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// DecryptJWEJSONRequestBody defines body for DecryptJWE for application/json ContentType.
type DecryptJWEJSONRequestBody = JWEDecryptRequest

// EncryptJWEJSONRequestBody defines body for EncryptJWE for application/json ContentType.
type EncryptJWEJSONRequestBody = JWEEncryptRequest

// GenerateJWKJSONRequestBody defines body for GenerateJWK for application/json ContentType.
type GenerateJWKJSONRequestBody = JWKGenerateRequest

// SignJWSJSONRequestBody defines body for SignJWS for application/json ContentType.
type SignJWSJSONRequestBody = JWSSignRequest

// VerifyJWSJSONRequestBody defines body for VerifyJWS for application/json ContentType.
type VerifyJWSJSONRequestBody = JWSVerifyRequest

// CreateJWTJSONRequestBody defines body for CreateJWT for application/json ContentType.
type CreateJWTJSONRequestBody = JWTCreateRequest

// VerifyJWTJSONRequestBody defines body for VerifyJWT for application/json ContentType.
type VerifyJWTJSONRequestBody = JWTVerifyRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetHealth request
	GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DecryptJWEWithBody request with any body
	DecryptJWEWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DecryptJWE(ctx context.Context, body DecryptJWEJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EncryptJWEWithBody request with any body
	EncryptJWEWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EncryptJWE(ctx context.Context, body EncryptJWEJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJWKS request
	ListJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateJWKWithBody request with any body
	GenerateJWKWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateJWK(ctx context.Context, body GenerateJWKJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJWK request
	DeleteJWK(ctx context.Context, kid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJWK request
	GetJWK(ctx context.Context, kid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJWKS request
	GetJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignJWSWithBody request with any body
	SignJWSWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignJWS(ctx context.Context, body SignJWSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyJWSWithBody request with any body
	VerifyJWSWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VerifyJWS(ctx context.Context, body VerifyJWSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJWTWithBody request with any body
	CreateJWTWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJWT(ctx context.Context, body CreateJWTJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyJWTWithBody request with any body
	VerifyJWTWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VerifyJWT(ctx context.Context, body VerifyJWTJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLivez request
	GetLivez(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReadyz request
	GetReadyz(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DecryptJWEWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDecryptJWERequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DecryptJWE(ctx context.Context, body DecryptJWEJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDecryptJWERequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EncryptJWEWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptJWERequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EncryptJWE(ctx context.Context, body EncryptJWEJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptJWERequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJWKSRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateJWKWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateJWKRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateJWK(ctx context.Context, body GenerateJWKJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateJWKRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJWK(ctx context.Context, kid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJWKRequest(c.Server, kid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJWK(ctx context.Context, kid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJWKRequest(c.Server, kid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJWKSRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignJWSWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignJWSRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignJWS(ctx context.Context, body SignJWSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignJWSRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyJWSWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyJWSRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyJWS(ctx context.Context, body VerifyJWSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyJWSRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJWTWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJWTRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJWT(ctx context.Context, body CreateJWTJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJWTRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyJWTWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyJWTRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyJWT(ctx context.Context, body VerifyJWTJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyJWTRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLivez(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLivezRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReadyz(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReadyzRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetHealthRequest generates requests for GetHealth
func NewGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDecryptJWERequest calls the generic DecryptJWE builder with application/json body
func NewDecryptJWERequest(server string, body DecryptJWEJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDecryptJWERequestWithBody(server, "application/json", bodyReader)
}

// NewDecryptJWERequestWithBody generates requests for DecryptJWE with any type of body
func NewDecryptJWERequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwe/decrypt")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEncryptJWERequest calls the generic EncryptJWE builder with application/json body
func NewEncryptJWERequest(server string, body EncryptJWEJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEncryptJWERequestWithBody(server, "application/json", bodyReader)
}

// NewEncryptJWERequestWithBody generates requests for EncryptJWE with any type of body
func NewEncryptJWERequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwe/encrypt")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListJWKSRequest generates requests for ListJWKS
func NewListJWKSRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateJWKRequest calls the generic GenerateJWK builder with application/json body
func NewGenerateJWKRequest(server string, body GenerateJWKJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateJWKRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateJWKRequestWithBody generates requests for GenerateJWK with any type of body
func NewGenerateJWKRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwk/generate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJWKRequest generates requests for DeleteJWK
func NewDeleteJWKRequest(server string, kid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "kid", runtime.ParamLocationPath, kid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwk/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJWKRequest generates requests for GetJWK
func NewGetJWKRequest(server string, kid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "kid", runtime.ParamLocationPath, kid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwk/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJWKSRequest generates requests for GetJWKS
func NewGetJWKSRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSignJWSRequest calls the generic SignJWS builder with application/json body
func NewSignJWSRequest(server string, body SignJWSJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignJWSRequestWithBody(server, "application/json", bodyReader)
}

// NewSignJWSRequestWithBody generates requests for SignJWS with any type of body
func NewSignJWSRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jws/sign")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVerifyJWSRequest calls the generic VerifyJWS builder with application/json body
func NewVerifyJWSRequest(server string, body VerifyJWSJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVerifyJWSRequestWithBody(server, "application/json", bodyReader)
}

// NewVerifyJWSRequestWithBody generates requests for VerifyJWS with any type of body
func NewVerifyJWSRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jws/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateJWTRequest calls the generic CreateJWT builder with application/json body
func NewCreateJWTRequest(server string, body CreateJWTJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJWTRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateJWTRequestWithBody generates requests for CreateJWT with any type of body
func NewCreateJWTRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwt/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVerifyJWTRequest calls the generic VerifyJWT builder with application/json body
func NewVerifyJWTRequest(server string, body VerifyJWTJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVerifyJWTRequestWithBody(server, "application/json", bodyReader)
}

// NewVerifyJWTRequestWithBody generates requests for VerifyJWT with any type of body
func NewVerifyJWTRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwt/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLivezRequest generates requests for GetLivez
func NewGetLivezRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/livez")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReadyzRequest generates requests for GetReadyz
func NewGetReadyzRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/readyz")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetHealthWithResponse request
	GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error)

	// DecryptJWEWithBodyWithResponse request with any body
	DecryptJWEWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DecryptJWEResponse, error)

	DecryptJWEWithResponse(ctx context.Context, body DecryptJWEJSONRequestBody, reqEditors ...RequestEditorFn) (*DecryptJWEResponse, error)

	// EncryptJWEWithBodyWithResponse request with any body
	EncryptJWEWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptJWEResponse, error)

	EncryptJWEWithResponse(ctx context.Context, body EncryptJWEJSONRequestBody, reqEditors ...RequestEditorFn) (*EncryptJWEResponse, error)

	// ListJWKSWithResponse request
	ListJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJWKSResponse, error)

	// GenerateJWKWithBodyWithResponse request with any body
	GenerateJWKWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateJWKResponse, error)

	GenerateJWKWithResponse(ctx context.Context, body GenerateJWKJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateJWKResponse, error)

	// DeleteJWKWithResponse request
	DeleteJWKWithResponse(ctx context.Context, kid openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteJWKResponse, error)

	// GetJWKWithResponse request
	GetJWKWithResponse(ctx context.Context, kid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetJWKResponse, error)

	// GetJWKSWithResponse request
	GetJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJWKSResponse, error)

	// SignJWSWithBodyWithResponse request with any body
	SignJWSWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignJWSResponse, error)

	SignJWSWithResponse(ctx context.Context, body SignJWSJSONRequestBody, reqEditors ...RequestEditorFn) (*SignJWSResponse, error)

	// VerifyJWSWithBodyWithResponse request with any body
	VerifyJWSWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyJWSResponse, error)

	VerifyJWSWithResponse(ctx context.Context, body VerifyJWSJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyJWSResponse, error)

	// CreateJWTWithBodyWithResponse request with any body
	CreateJWTWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJWTResponse, error)

	CreateJWTWithResponse(ctx context.Context, body CreateJWTJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJWTResponse, error)

	// VerifyJWTWithBodyWithResponse request with any body
	VerifyJWTWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyJWTResponse, error)

	VerifyJWTWithResponse(ctx context.Context, body VerifyJWTJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyJWTResponse, error)

	// GetLivezWithResponse request
	GetLivezWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLivezResponse, error)

	// GetReadyzWithResponse request
	GetReadyzWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadyzResponse, error)
}

type GetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthResponse
}

// Status returns HTTPResponse.Status
func (r GetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DecryptJWEResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JWEDecryptResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DecryptJWEResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DecryptJWEResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EncryptJWEResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JWEEncryptResponse
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EncryptJWEResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EncryptJWEResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJWKSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JWKListResponse
}

// Status returns HTTPResponse.Status
func (r ListJWKSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJWKSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateJWKResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *JWKResponse
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GenerateJWKResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateJWKResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJWKResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteJWKResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJWKResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJWKResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JWKResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetJWKResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJWKResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJWKSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JWKS
}

// Status returns HTTPResponse.Status
func (r GetJWKSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJWKSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignJWSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JWSSignResponse
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SignJWSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignJWSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyJWSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JWSVerifyResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r VerifyJWSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyJWSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJWTResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JWTCreateResponse
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateJWTResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJWTResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyJWTResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JWTVerifyResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r VerifyJWTResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyJWTResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLivezResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLivezResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLivezResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReadyzResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReadyzResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReadyzResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetHealthWithResponse request returning *GetHealthResponse
func (c *ClientWithResponses) GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error) {
	rsp, err := c.GetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthResponse(rsp)
}

// DecryptJWEWithBodyWithResponse request with arbitrary body returning *DecryptJWEResponse
func (c *ClientWithResponses) DecryptJWEWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DecryptJWEResponse, error) {
	rsp, err := c.DecryptJWEWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDecryptJWEResponse(rsp)
}

func (c *ClientWithResponses) DecryptJWEWithResponse(ctx context.Context, body DecryptJWEJSONRequestBody, reqEditors ...RequestEditorFn) (*DecryptJWEResponse, error) {
	rsp, err := c.DecryptJWE(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDecryptJWEResponse(rsp)
}

// EncryptJWEWithBodyWithResponse request with arbitrary body returning *EncryptJWEResponse
func (c *ClientWithResponses) EncryptJWEWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptJWEResponse, error) {
	rsp, err := c.EncryptJWEWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptJWEResponse(rsp)
}

func (c *ClientWithResponses) EncryptJWEWithResponse(ctx context.Context, body EncryptJWEJSONRequestBody, reqEditors ...RequestEditorFn) (*EncryptJWEResponse, error) {
	rsp, err := c.EncryptJWE(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptJWEResponse(rsp)
}

// ListJWKSWithResponse request returning *ListJWKSResponse
func (c *ClientWithResponses) ListJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJWKSResponse, error) {
	rsp, err := c.ListJWKS(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJWKSResponse(rsp)
}

// GenerateJWKWithBodyWithResponse request with arbitrary body returning *GenerateJWKResponse
func (c *ClientWithResponses) GenerateJWKWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateJWKResponse, error) {
	rsp, err := c.GenerateJWKWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateJWKResponse(rsp)
}

func (c *ClientWithResponses) GenerateJWKWithResponse(ctx context.Context, body GenerateJWKJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateJWKResponse, error) {
	rsp, err := c.GenerateJWK(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateJWKResponse(rsp)
}

// DeleteJWKWithResponse request returning *DeleteJWKResponse
func (c *ClientWithResponses) DeleteJWKWithResponse(ctx context.Context, kid openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteJWKResponse, error) {
	rsp, err := c.DeleteJWK(ctx, kid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJWKResponse(rsp)
}

// GetJWKWithResponse request returning *GetJWKResponse
func (c *ClientWithResponses) GetJWKWithResponse(ctx context.Context, kid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetJWKResponse, error) {
	rsp, err := c.GetJWK(ctx, kid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJWKResponse(rsp)
}

// GetJWKSWithResponse request returning *GetJWKSResponse
func (c *ClientWithResponses) GetJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJWKSResponse, error) {
	rsp, err := c.GetJWKS(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJWKSResponse(rsp)
}

// SignJWSWithBodyWithResponse request with arbitrary body returning *SignJWSResponse
func (c *ClientWithResponses) SignJWSWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignJWSResponse, error) {
	rsp, err := c.SignJWSWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignJWSResponse(rsp)
}

func (c *ClientWithResponses) SignJWSWithResponse(ctx context.Context, body SignJWSJSONRequestBody, reqEditors ...RequestEditorFn) (*SignJWSResponse, error) {
	rsp, err := c.SignJWS(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignJWSResponse(rsp)
}

// VerifyJWSWithBodyWithResponse request with arbitrary body returning *VerifyJWSResponse
func (c *ClientWithResponses) VerifyJWSWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyJWSResponse, error) {
	rsp, err := c.VerifyJWSWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyJWSResponse(rsp)
}

func (c *ClientWithResponses) VerifyJWSWithResponse(ctx context.Context, body VerifyJWSJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyJWSResponse, error) {
	rsp, err := c.VerifyJWS(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyJWSResponse(rsp)
}

// CreateJWTWithBodyWithResponse request with arbitrary body returning *CreateJWTResponse
func (c *ClientWithResponses) CreateJWTWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJWTResponse, error) {
	rsp, err := c.CreateJWTWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJWTResponse(rsp)
}

func (c *ClientWithResponses) CreateJWTWithResponse(ctx context.Context, body CreateJWTJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJWTResponse, error) {
	rsp, err := c.CreateJWT(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJWTResponse(rsp)
}

// VerifyJWTWithBodyWithResponse request with arbitrary body returning *VerifyJWTResponse
func (c *ClientWithResponses) VerifyJWTWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyJWTResponse, error) {
	rsp, err := c.VerifyJWTWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyJWTResponse(rsp)
}

func (c *ClientWithResponses) VerifyJWTWithResponse(ctx context.Context, body VerifyJWTJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyJWTResponse, error) {
	rsp, err := c.VerifyJWT(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyJWTResponse(rsp)
}

// GetLivezWithResponse request returning *GetLivezResponse
func (c *ClientWithResponses) GetLivezWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLivezResponse, error) {
	rsp, err := c.GetLivez(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLivezResponse(rsp)
}

// GetReadyzWithResponse request returning *GetReadyzResponse
func (c *ClientWithResponses) GetReadyzWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadyzResponse, error) {
	rsp, err := c.GetReadyz(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReadyzResponse(rsp)
}

// ParseGetHealthResponse parses an HTTP response from a GetHealthWithResponse call
func ParseGetHealthResponse(rsp *http.Response) (*GetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDecryptJWEResponse parses an HTTP response from a DecryptJWEWithResponse call
func ParseDecryptJWEResponse(rsp *http.Response) (*DecryptJWEResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DecryptJWEResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JWEDecryptResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEncryptJWEResponse parses an HTTP response from a EncryptJWEWithResponse call
func ParseEncryptJWEResponse(rsp *http.Response) (*EncryptJWEResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EncryptJWEResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JWEEncryptResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListJWKSResponse parses an HTTP response from a ListJWKSWithResponse call
func ParseListJWKSResponse(rsp *http.Response) (*ListJWKSResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJWKSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JWKListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateJWKResponse parses an HTTP response from a GenerateJWKWithResponse call
func ParseGenerateJWKResponse(rsp *http.Response) (*GenerateJWKResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateJWKResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest JWKResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteJWKResponse parses an HTTP response from a DeleteJWKWithResponse call
func ParseDeleteJWKResponse(rsp *http.Response) (*DeleteJWKResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJWKResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetJWKResponse parses an HTTP response from a GetJWKWithResponse call
func ParseGetJWKResponse(rsp *http.Response) (*GetJWKResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJWKResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JWKResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetJWKSResponse parses an HTTP response from a GetJWKSWithResponse call
func ParseGetJWKSResponse(rsp *http.Response) (*GetJWKSResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJWKSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JWKS
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSignJWSResponse parses an HTTP response from a SignJWSWithResponse call
func ParseSignJWSResponse(rsp *http.Response) (*SignJWSResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignJWSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JWSSignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseVerifyJWSResponse parses an HTTP response from a VerifyJWSWithResponse call
func ParseVerifyJWSResponse(rsp *http.Response) (*VerifyJWSResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyJWSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JWSVerifyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateJWTResponse parses an HTTP response from a CreateJWTWithResponse call
func ParseCreateJWTResponse(rsp *http.Response) (*CreateJWTResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJWTResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JWTCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseVerifyJWTResponse parses an HTTP response from a VerifyJWTWithResponse call
func ParseVerifyJWTResponse(rsp *http.Response) (*VerifyJWTResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyJWTResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JWTVerifyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLivezResponse parses an HTTP response from a GetLivezWithResponse call
func ParseGetLivezResponse(rsp *http.Response) (*GetLivezResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLivezResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReadyzResponse parses an HTTP response from a GetReadyzWithResponse call
func ParseGetReadyzResponse(rsp *http.Response) (*GetReadyzResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReadyzResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
